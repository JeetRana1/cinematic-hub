<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Outfit:wght@300;400;500;600;700;800&display=swap"
    rel="stylesheet">
  <!-- CRITICAL: Block all redirects IMMEDIATELY -->
  <script>
    // Block window.open completely
    const originalOpen = window.open;
    window.open = function (url) {
      console.log('ðŸš« BLOCKED: window.open(' + url + ')');
      return null;
    };

    // Block eval
    window.eval = function () {
      console.log('ðŸš« BLOCKED: eval()');
      return undefined;
    };

    console.log('âœ… Security barrier loaded');
  </script>

  <script>
    // Global error reporting to help surface runtime issues in the console
    window.addEventListener('error', function (evt) {
      try {
        // Provide richer context for errors (filename, line, column) to help debugging cross-origin 'Script error' cases
        const info = {
          message: evt && (evt.error || evt.message) ? (evt.error && evt.error.message ? evt.error.message : (evt.message || '(no message)')) : '(no event)',
          filename: evt && evt.filename ? evt.filename : null,
          lineno: evt && typeof evt.lineno !== 'undefined' ? evt.lineno : null,
          colno: evt && typeof evt.colno !== 'undefined' ? evt.colno : null,
          error: evt && evt.error ? evt.error : null
        };
        console.error('Global JS error:', info);
      } catch (_) { }
    });
    window.addEventListener('unhandledrejection', function (evt) {
      try { console.error('Unhandled rejection:', evt && evt.reason ? evt.reason : evt); } catch (_) { }
    });

    // Protect console from being cleared by third-party scripts and collect logs in an in-page panel
    (function () {
      if (typeof console === 'undefined') return;

      // Save originals
      try {
        console._orig = {
          log: console.log.bind(console),
          info: console.info ? console.info.bind(console) : console.log.bind(console),
          warn: console.warn ? console.warn.bind(console) : console.log.bind(console),
          error: console.error ? console.error.bind(console) : console.log.bind(console),
          clear: console.clear ? console.clear.bind(console) : function () { }
        };
      } catch (e) { console._orig = null; }


      // In-memory buffer and helper
      console._buffer = [];
      function pushLog(level, args) {
        const text = Array.from(args).map(a => {
          try { return (typeof a === 'object') ? JSON.stringify(a) : String(a); } catch (e) { return String(a); }
        }).join(' ');
        const line = document.createElement('div'); line.className = 'log-line'; line.style.padding = '6px 0'; line.style.borderBottom = '1px solid rgba(255,255,255,0.03)';
        line.innerText = `[${level}] ${text}`;
        const b = document.getElementById('devLogBody'); if (b) { b.insertBefore(line, b.firstChild); }
        console._buffer.push({ level, text, time: Date.now() });
      }

      // Override console methods to also write to panel
      if (console._orig) {
        console.log = function () { console._orig.log.apply(console, arguments); pushLog('log', arguments); };
        console.info = function () { console._orig.info.apply(console, arguments); pushLog('info', arguments); };
        console.warn = function () { console._orig.warn.apply(console, arguments); pushLog('warn', arguments); };
        console.error = function () { console._orig.error.apply(console, arguments); pushLog('error', arguments); };
        console.clear = function () {
          // count attempts and show a short message but DO NOT clear the panel
          console._clearAttempts = (console._clearAttempts || 0) + 1;
          pushLog('warn', ['console.clear() blocked (#' + console._clearAttempts + ')']);
          // Keep the Dev Log visible so you can inspect attempts
          const p = document.getElementById('devLogPanel'); if (p) p.style.display = 'block';
        };
      }

      // Reinforce override every 1s in case some script tries to replace console
      setInterval(() => {
        if (!console._orig) return;
        if (console.log !== (function () { }) && console.log.name !== 'bound log' && console.log !== console._orig.log && console._orig.log) { console.log = function () { console._orig.log.apply(console, arguments); pushLog('log', arguments); }; }
        if (console._orig && console.clear !== console._orig.clear && typeof console.clear === 'function') {
          // ensure our clear is active
          console.clear = function () { console._clearAttempts = (console._clearAttempts || 0) + 1; pushLog('warn', ['console.clear() blocked (#' + console._clearAttempts + ')']); const p = document.getElementById('devLogPanel'); if (p) p.style.display = 'block'; };
        }
      }, 1000);

    })();
  </script>

  <style>
    @media (orientation: portrait) {
      .user-name.hide-mobile {
        display: none !important;
      }
    }
  </style>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="screen-orientation" content="portrait">
  <meta name="theme-color" content="#000000">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Cinematic Hub</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="preconnect" href="https://firestore.googleapis.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <link rel="preconnect" href="https://www.youtube.com">
  <link rel="stylesheet" href="css/continue-watching.css?v=12&t=20250208d" /><link rel="stylesheet" href="css/subtitles.css" />
  <link rel="stylesheet" href="css/image-enhancement.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />

  <style>
    @keyframes ripple {
      to {
        transform: scale(2.5);
        opacity: 0;
      }
    }

    /* Pulse Animation */
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(166, 108, 255, 0.7);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(166, 108, 255, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(166, 108, 255, 0);
      }
    }

    .topbar-wrapper {
      width: 100%;
      max-width: none;
      margin: 0;
      padding: 0;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 30000;
      pointer-events: none;
      /* Let clicks pass through to hero mainly, but enable pointer-events on children */
    }

    .topbar-component,
    #userMenuComponent {
      pointer-events: auto;
    }

    /* Responsive Adjustments */
    @media (max-width: 768px) {
      .stream-button {
        padding: 10px 24px;
        font-size: 0.95rem;
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    *::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    *::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
    }

    *::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(167, 139, 250, 0.6), rgba(251, 113, 133, 0.6));
      border-radius: 10px;
      transition: all 0.3s ease;
    }

    *::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(167, 139, 250, 0.8), rgba(251, 113, 133, 0.8));
    }

    /* Animated Background */
    .bg-particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.6;
      pointer-events: none;
      overflow: hidden;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      background: linear-gradient(45deg, var(--primary, #6b66ff), #ff6b6b);
      opacity: 0.3;
      animation: float 15s infinite ease-in-out;
      box-shadow: 0 0 15px 3px rgba(255, 255, 255, 0.4);
    }

    @keyframes float {

      0%,
      100% {
        transform: translateY(0) translateX(0);
      }

      25% {
        transform: translateY(-20px) translateX(10px);
      }

      50% {
        transform: translateY(0) translateX(20px);
      }

      75% {
        transform: translateY(20px) translateX(10px);
      }
    }

    :root {
      --scrollbar-thumb: #ffffff;
      --scrollbar-thumb-hover: #0a0a0f;
      --scrollbar-track: #0f0f15;
      --modal-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.65), 0 1.5px 8px rgba(0, 0, 0, 0.35);
      --primary-gradient: linear-gradient(90deg, #a78bfa, #fb7185);
      --bg-color: #030305;
      --bg-gradient: linear-gradient(180deg, #030305 0%, #0a0a0f 50%, #05050a 100%);
      --glass-bg: rgba(15, 15, 25, 0.7);
      --glass-border: rgba(255, 255, 255, 0.08);
      --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      --hover-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
      --text-color: #ffffff;
      --text-secondary: rgba(255, 255, 255, 0.65);
      --modal-bg: rgba(0, 0, 0, 0.98);
      --modal-content-bg: rgba(15, 15, 25, 0.95);
    }

    @media (max-width: 768px) {
      .poster {
        height: 260px;
      }
    }

    /* Improved scrolling and header layout */
    html {
      scroll-behavior: smooth;
      scroll-padding-top: 80px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    html,
    body {
      max-width: 100%;
      overflow-x: hidden;
    }

    @supports (left: env(safe-area-inset-left)) {
      @media (orientation: landscape) and (max-width: 1024px) {
        html,
        body {
          width: 100dvw;
          min-height: 100dvh;
        }

        body {
          position: relative;
          left: calc(-1 * env(safe-area-inset-left));
          width: calc(100dvw + env(safe-area-inset-left) + env(safe-area-inset-right));
          padding-left: env(safe-area-inset-left) !important;
          padding-right: env(safe-area-inset-right) !important;
        }

        body::before,
        body::after,
        .bg-particles {
          left: 0;
          right: 0;
          width: auto;
        }
      }
    }

    body {
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
      scrollbar-gutter: stable;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      max-width: 1500px;
      margin: 1.5rem auto 0.5rem;
      padding: 0 1.5rem;
    }

    .section-title i {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
      font-size: 0.95rem;
    }

    .section-title .pill {
      padding: 6px 10px;
      background: rgba(255,255,255,0.03);
      border-radius: 999px;
      font-size: 0.85rem;
      color: var(--text-secondary);
      font-weight: 600;
      margin-left: 8px;
    }

    .cat-btn.active {
      background: var(--primary-gradient);
      color: #fff;
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(167,139,250,0.18);
      border-color: rgba(255,255,255,0.06);
    }

    .particle {
      will-change: transform, opacity;
      animation-duration: 18s;
      opacity: 0.28;
      box-shadow: 0 0 8px rgba(255,255,255,0.25);
    }

    @media (max-width: 420px) {
      .poster {
        height: 220px;
      }
    }

    body {
      font-family: 'Poppins', sans-serif;
      background-color: #030305;
      background-image: linear-gradient(180deg, #030305 0%, #0a0a0f 45%, #05050a 100%);
      color: var(--text-color);
      min-height: 100vh;
      padding: 0;
      background-attachment: fixed;
      background-repeat: no-repeat;
      position: relative;
      overflow-x: hidden;
    }

    html.home-pseudo-fullscreen,
    body.home-pseudo-fullscreen {
      width: 100dvw !important;
      height: 100dvh !important;
      max-width: 100dvw !important;
      max-height: 100dvh !important;
      margin: 0 !important;
      padding: 0 !important;
      overflow-x: hidden !important;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
      z-index: 1;
    }

    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(circle at 20% 30%, rgba(167, 139, 250, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(251, 113, 133, 0.04) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(99, 102, 241, 0.02) 0%, transparent 70%);
      pointer-events: none;
      z-index: 1;
      animation: gradientShift 20s ease-in-out infinite;
    }

    @keyframes gradientShift {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: 0.8;
        transform: scale(1.1);
      }
    }

    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(50px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .container {
      width: 100%;
      max-width: none;
      margin: 0;
      padding: 0;
      position: relative;
      z-index: 2;
      animation: slideInUp 0.6s ease-out;
    }

    /* Mini user menu (profiles/settings/logout) */
    /* New Clear All button styles */
    .cw-clear-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(135deg, #ff7a7a, #ff3b3b);
      color: #fff;
      font-weight: 600;
      box-shadow: 0 6px 16px rgba(255, 59, 59, 0.25);
      cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
    }

    .cw-clear-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(255, 59, 59, 0.35);
      filter: saturate(1.1);
    }

    .cw-clear-btn:active {
      transform: translateY(0);
      box-shadow: 0 4px 12px rgba(255, 59, 59, 0.2);
    }

    .cw-clear-icon {
      width: 24px;
      height: 24px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.22);
      border: 1px solid rgba(255, 255, 255, 0.28);
      line-height: 1;
      flex-shrink: 0;
    }

    .cw-clear-icon i {
      font-size: 13px;
      color: #fff;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.25);
    }

    .cw-clear-text {
      font-size: 14px;
    }

    .app-usermenu {
      margin-left: auto;
      z-index: 1200;
      position: relative;
      display: flex;
      align-items: center;
    }

    .app-userbtn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      padding: 4px 12px 4px 4px;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(8px);
      color: white;
      font-weight: 500;
      font-size: 0.85rem;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      height: 36px;
      transform-origin: center;
      position: relative;
    }

    .app-userbtn:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px) scale(1.02);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }

    .app-userbtn:active {
      transform: translateY(0) scale(0.98);
      transition-duration: 0.1s;
    }

    .app-userbtn:focus {
      outline: 2px solid rgba(255, 255, 255, 0.35);
      outline-offset: 2px;
    }

    .app-avatar {
      width: 28px;
      height: 28px;
      border-radius: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--avatar-bg, #6b66ff) !important;
      /* Default color if not set */
      background-color: var(--avatar-bg, #6b66ff) !important;
      /* Fallback */
      color: white !important;
      font-weight: 500;
      overflow: hidden;
      font-size: 0.8rem;
      flex-shrink: 0;
      /* Remove any potential gradient */
      background-image: none !important;
    }

    .app-userbtn::after {
      content: 'â—€';
      font-size: 8px;
      margin-left: 4px;
      opacity: 0.7;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      transform: rotate(0deg);
      transform-origin: center;
    }

    .app-userbtn[aria-expanded="true"]::after {
      transform: rotate(-90deg);
    }

    .app-userbtn:hover::after {
      opacity: 1;
    }

    .app-userdropdown {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 220px;
      display: none;
      flex-direction: column;
      background: rgba(22, 22, 25, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      margin-top: 8px;
      overflow: hidden;
      z-index: 9999;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(16px);
      padding: 6px 0;
      opacity: 0;
      transform: translateY(-8px);
      transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      will-change: opacity, transform;
    }

    .app-userdropdown.visible {
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .app-userdropdown.show {
      display: flex;
    }

    .app-userdropdown button {
      appearance: none;
      background: transparent;
      color: rgba(255, 255, 255, 0.9);
      border: none;
      padding: 10px 20px;
      text-align: left;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .app-userdropdown button::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 3px;
      background: var(--primary-gradient);
      transform: scaleY(0);
      transform-origin: top;
      transition: transform 0.2s ease;
    }

    .app-userdropdown button:hover {
      background: rgba(255, 255, 255, 0.05);
      color: white;
      padding-left: 20px;
    }

    .app-userdropdown button:hover::before {
      transform: scaleY(1);
    }

    .app-userdropdown button i {
      width: 20px;
      text-align: center;
      opacity: 0.8;
      font-size: 1rem;
    }

    .app-userdropdown button .menu-item-text {
      flex: 1;
    }

    .app-userdropdown button .menu-item-badge {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .app-userdropdown button i {
      width: 20px;
      text-align: center;
      opacity: 0.8;
    }

    /* When modal is open, keep user menu visible and properly positioned */
    .modal-open .app-usermenu {
      filter: none;
      opacity: 1;
      pointer-events: auto;
      position: fixed;
      top: 20px;
      right: 20px;
    }

    /* Hide the username text on smaller screens */
    @media (max-width: 768px) {
      .app-username {
        display: none;
      }

      .app-userbtn {
        padding: 4px;
      }
    }

    /* Hide continue watching section during search */
    body.searching .continue-watching-section {
      display: none !important;
    }

    /* Push search results down when searching */
    body.searching #moviesContainer {
      margin-top: 140px;
    }

    @media (max-width: 768px) {
      body.searching #moviesContainer {
        margin-top: 70px;
      }
    }



    /* Modern User Menu Component */
    #userMenuComponent {
      position: fixed;
      right: 2rem;
      top: 1rem;
      z-index: 1001;
    }

    /* User Menu Button */
    .user-menu-btn {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      background: rgba(30, 30, 35, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 0.5rem 1rem 0.5rem 0.75rem;
      color: white;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .user-menu-btn:hover {
      background: rgba(40, 40, 45, 0.9);
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
    }

    .user-menu-btn:active {
      transform: translateY(0);
    }

    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 60%;
      /* Increased from 50% to 60% for a more rounded look */
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      flex-shrink: 0;
      font-weight: 600;
      font-size: 14px;
      color: white;
      transition: all 0.3s ease;
    }

    .user-menu-btn:hover .user-avatar {
      transform: scale(1.05);
    }

    .user-name {
      font-weight: 500;
      font-size: 0.95rem;
      white-space: nowrap;
    }

    .user-caret {
      transition: transform 0.3s ease;
      opacity: 0.7;
    }

    .user-menu-btn:hover .user-caret {
      opacity: 1;
    }

    /* Dropdown Menu */
    .user-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      background: rgba(30, 30, 35, 0.98);
      backdrop-filter: blur(20px);
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      min-width: 220px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1002;
    }

    .user-dropdown::before {
      content: '';
      position: absolute;
      top: -6px;
      right: 20px;
      width: 12px;
      height: 12px;
      background: inherit;
      transform: rotate(45deg);
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      border-left: 1px solid rgba(255, 255, 255, 0.08);
    }

    /* Dropdown Items */
    .dropdown-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.85rem 1.25rem;
      color: rgba(255, 255, 255, 0.9);
      text-decoration: none;
      font-size: 0.925rem;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .dropdown-item:hover {
      background: rgba(255, 255, 255, 0.05);
      color: #fff;
      padding-left: 1.5rem;
    }

    .dropdown-item i {
      width: 20px;
      text-align: center;
      color: #8b5cf6;
      font-size: 1.1em;
      transition: all 0.3s ease;
    }

    .dropdown-item:hover i {
      transform: scale(1.1);
      color: #a78bfa;
    }

    .dropdown-divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.08);
      margin: 0.25rem 0;
    }

    /* Updates Modal */
    .updates-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(4, 8, 18, 0.62);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 2500;
      padding: 1rem;
    }

    .topbar-wrapper #updatesModal {
      pointer-events: auto;
    }

    .updates-modal-overlay.show {
      display: flex;
    }

    .updates-modal-card {
      width: min(720px, 96vw);
      max-height: min(84vh, 900px);
      overflow: auto;
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: linear-gradient(145deg, rgba(15, 22, 42, 0.82), rgba(12, 18, 34, 0.78));
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      color: #eef2ff;
    }

    .updates-modal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 1rem 1.1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .updates-modal-title {
      margin: 0;
      font-size: 1.15rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.55rem;
    }

    .updates-modal-title i {
      color: #fb7185;
    }

    .updates-close-btn {
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: rgba(255, 255, 255, 0.05);
      color: #fff;
      border-radius: 10px;
      width: 36px;
      height: 36px;
      cursor: pointer;
      transition: all 0.18s ease;
    }

    .updates-close-btn:hover {
      background: rgba(251, 113, 133, 0.2);
      border-color: rgba(251, 113, 133, 0.5);
    }

    .updates-modal-body {
      padding: 1rem 1.1rem 0.8rem;
    }

    .updates-version {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.78rem;
      color: #d1d5db;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      border-radius: 999px;
      padding: 0.28rem 0.65rem;
      margin-bottom: 0.75rem;
    }

    .updates-summary {
      margin: 0 0 0.8rem;
      color: rgba(255, 255, 255, 0.88);
      line-height: 1.45;
      font-size: 0.95rem;
    }

    .updates-list {
      margin: 0;
      padding: 0 0 0 1.1rem;
      color: rgba(255, 255, 255, 0.92);
      line-height: 1.45;
      font-size: 0.92rem;
    }

    .updates-list li {
      margin: 0 0 0.4rem;
    }

    .updates-section {
      margin-top: 0.85rem;
      padding-top: 0.65rem;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }

    .updates-section-title {
      margin: 0 0 0.45rem;
      font-size: 0.9rem;
      font-weight: 700;
      color: #f8fafc;
      letter-spacing: 0.01em;
    }

    .updates-modal-foot {
      display: flex;
      justify-content: flex-end;
      padding: 0.9rem 1.1rem 1rem;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.02);
    }

    .updates-cta {
      border: none;
      border-radius: 10px;
      padding: 0.62rem 1rem;
      font-weight: 700;
      color: #fff;
      background: linear-gradient(135deg, #ef4444, #fb7185);
      cursor: pointer;
      box-shadow: 0 12px 24px rgba(239, 68, 68, 0.28);
    }

    /* Active State */
    .user-menu-btn.active {
      background: rgba(40, 40, 45, 0.95);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    .user-menu-btn.active .user-caret {
      transform: rotate(180deg);
    }

    .user-menu-btn.active+.user-dropdown {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    /* Brand component */
    #brandComponent {
      position: fixed;
      left: 2rem;
      top: 1rem;
      z-index: 1001;
      backdrop-filter: blur(10px);
      padding: 0.5rem 1rem;
      border-radius: 12px;

    }

    .brand {
      display: flex;
      flex-direction: column;
      line-height: 1;
    }

    .brand-title {
      font-size: 8.5rem;
      font-weight: 1000px;
      background: linear-gradient(135deg, #a78bfa 0%, #fb7185 50%, #fbbf24 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0;
      letter-spacing: -1px;
      display: flex;
      align-items: center;
      gap: 0.3em;
    }

    .brand-sub {
      font-size: 4rem;
      opacity: 0.7;
      letter-spacing: 0.5px;
      margin-top: 2px;
    }

    /* Search component */
    #searchComponent {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 560px;
      margin: 0 auto;
      top: 1rem;
      z-index: 20000;
      background: none;
      border-radius: 999px;
    }

    .search-top {
      display: flex;
      align-items: center;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 999px;
      padding: 0.4rem 0.6rem 0.4rem 1.1rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(14px) saturate(140%);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      width: 100%;
      max-width: 560px;
      margin: 0 auto;
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.08);
      position: relative;
      z-index: 20001;
    }

    .search-top:hover {
      border-color: rgba(255, 255, 255, 0.25);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.12);
    }

    .search-top:focus-within {
      transform: translateY(-1px);
      box-shadow: 0 14px 34px rgba(0, 0, 0, 0.45), 0 0 0 2px rgba(255, 255, 255, 0.22);
      border-color: rgba(255, 255, 255, 0.35);
      background: rgba(255, 255, 255, 0.12);
    }

    .search-top input {
      background: transparent;
      border: none;
      color: #f4f6ff;
      padding: 0.55rem 0.6rem 0.55rem 0.2rem;
      width: 100%;
      outline: none;
      font-size: 0.98rem;
      font-weight: 500;
      letter-spacing: 0.2px;
    }

    .search-top input::placeholder {
      color: rgba(255, 255, 255, 0.55);
      font-weight: 400;
    }

    /* Right-side circular search button */
    #searchBtn {
      width: 36px;
      height: 36px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12);
    }

    #searchBtn:hover {
      background: rgba(255, 255, 255, 0.18);
    }

    #searchBtn svg {
      width: 16px;
      height: 16px;
    }

    @media (max-width: 900px) {
      #searchComponent {
        max-width: 520px;
      }

      .search-top {
        max-width: 520px;
      }
    }

    @media (max-width: 640px) {
      #searchComponent {
        left: 1rem;
        right: 1rem;
        transform: none;
        max-width: none;
      }

      .search-top {
        max-width: none;
        padding: 0.35rem 0.5rem 0.35rem 0.9rem;
      }

      #searchBtn {
        width: 34px;
        height: 34px;
      }
    }

    @media (max-width: 420px) {
      .search-top input {
        font-size: 0.92rem;
      }
    }

    /* Adjust topbar to account for fixed user menu */
    .topbar-wrapper {
      padding-right: 100px;
      /* Make space for the fixed user menu */
    }

    /* Menu divider */
    .menu-divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 4px 0;
    }

    .logout-btn {
      color: #ff6b6b !important;
    }

    /* Dropdown container - positioned outside the topbar */
    .dropdown-container {
      position: static;
      /* Changed from relative to prevent containment */
      display: inline-block;
      /* Make it only take necessary space */
      z-index: 1000;
      /* Higher than topbar */
    }

    /* User menu container */
    .user-menu-container {
      position: relative;
      height: 100%;
      display: flex;
      align-items: center;
      z-index: 1001;
      /* Higher than topbar */
      /* Ensure this creates a new stacking context */
      transform: translateZ(0);
    }

    /* Dropdown menu styles */
    .dropdown-menu {
      position: absolute;
      right: 0;
      top: 100%;
      /* Changed from calc(100% + 10px) */
      margin-top: 10px;
      /* Added margin instead of including in top */
      background: rgba(20, 20, 30, 0.98);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 0.5rem 0;
      min-width: 200px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
      z-index: 1002;
      /* Keep this higher than topbar */
      opacity: 0;
      visibility: hidden;
      transform: translateY(-5px);
      transition: all 0.2s ease-out;
      /* Ensure no background bleeds through */
      background-clip: padding-box;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-5px);
      transition: all 0.2s ease-out;
    }

    .user-menu-container:hover .dropdown-menu,
    .dropdown-menu.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
    }

    .topbar-content {
      display: flex;
      align-items: center;
      position: relative;
      width: 100%;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: nowrap;
      z-index: 10;
    }

    .topbar-search {
      flex: 1;
      max-width: 600px;
      margin: 0 auto;
      display: flex;
      justify-content: center;
    }

    /* Responsive adjustments */
    @media (min-width: 1025px) {
      .topbar-content {
        gap: 1.5rem;
      }

      .search-top {
        max-width: 600px;
        width: 100%;
      }

      .brand {
        flex-shrink: 0;
      }

      .app-usermenu {
        flex-shrink: 0;
      }
    }

    @media (max-width: 1024px) {
      .topbar {
        padding: 1rem;
        gap: 0.75rem;
      }

      .topbar-content {
        gap: 0.75rem;
      }

      .topbar-search {
        flex: 1;
        max-width: none;
      }

      .search-top {
        width: 100%;
        max-width: 450px;
      }

      .brand-title {
        font-size: 1.1rem;
      }

      .brand-sub {
        font-size: 0.7rem;
      }
    }

    @media (max-width: 768px) {
      .topbar {
        padding: 0.75rem 1rem;
        gap: 0.5rem;
      }

      .topbar-content {
        gap: 0.5rem;
      }

      .brand {
        display: none;
      }

      .topbar-search {
        flex: 1;
      }

      .search-top {
        max-width: none;
        width: 100%;
      }

      .search-top input {
        width: 100%;
        max-width: none;
        min-width: 120px;
      }
    }

    @media (max-width: 480px) {
      .topbar {
        padding: 0.5rem 0.75rem;
        top: 0.5rem;
        border-radius: 8px;
      }

      .search-top {
        padding: 4px 6px;
        gap: 4px;
      }

      .search-top input {
        padding: 6px 8px;
        font-size: 0.9rem;
        min-width: 100px;
      }

      .home-btn {
        width: 32px;
        height: 32px;
        margin: 0 2px;
      }

      .home-btn svg {
        width: 14px;
        height: 14px;
      }

      .app-userbtn {
        padding: 4px;
        gap: 4px;
      }

      .app-avatar {
        width: 28px;
        height: 28px;
        font-size: 0.75rem;
      }

      .app-username {
        display: none;
      }
    }

    @media (max-width: 360px) {
      .topbar {
        padding: 0.5rem;
      }

      .search-top input {
        font-size: 0.85rem;
        padding: 5px 6px;
      }

      .home-btn {
        width: 28px;
        height: 28px;
      }

      .app-avatar {
        width: 26px;
        height: 26px;
      }
    }

    .brand {
      display: flex;
      flex-direction: column;
    }

    .brand-title {
      font-size: 1.25rem;
      margin: 0;
      letter-spacing: 0.4px;
      color: white;
      font-weight: 600;
      background: linear-gradient(90deg, #a78bfa, #fb7185);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .brand-sub {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 3px;
    }

    /* Home and search buttons */
    .home-btn {
      background: rgba(20, 20, 25, 0.8);
      border: 1.5px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 0;
      margin: 0 4px;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(8px);
    }

    .home-btn::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border: 1.5px solid transparent;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.6), rgba(139, 92, 246, 0.8));
      background-origin: border-box;
      background-clip: border-box;
      -webkit-background-clip: border-box;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .home-btn:hover::before {
      opacity: 1;
    }

    .home-btn svg {
      width: 16px;
      height: 16px;
      fill: white;
    }

    .home-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.25);
    }

    .home-btn:active {
      transform: translateY(0);
    }

    /* Modern Dark Search Bar */
    .search-top {
      --search-bg: rgba(20, 20, 25, 0.8);
      --search-border: rgba(99, 102, 241, 0.2);
      --search-focus: rgba(99, 102, 241, 0.4);
      --search-text: rgba(255, 255, 255, 0.9);
      --search-placeholder: rgba(255, 255, 255, 0.5);
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--search-bg);
      border: 1.5px solid var(--search-border);
      border-radius: 14px;
      padding: 12px 18px;
      transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(12px) saturate(180%);
      will-change: transform, box-shadow, border-color;
      position: relative;
      overflow: hidden;
    }

    /* Enhanced gradient border effect */
    .search-top {
      position: relative;
      overflow: visible;
      border-radius: 14px;
      background-clip: padding-box;
    }

    .search-top::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border: 3px solid var(--search-border);
      border-radius: 16px;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
    }

    .search-top:focus-within::before {
      opacity: 1;
      transform: scale(1.01);
    }

    /* Search icon with subtle animation */
    .search-top .search-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--search-placeholder);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      z-index: 1;
      opacity: 0.7;
    }

    /* Search bar focus/hover states */
    .search-top:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.15);
      border-color: rgba(99, 102, 241, 0.3);
    }

    /* Hover and focus states */
    .search-top:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
      border-color: var(--search-focus);
    }

    .search-top:focus-within,
    .search-top.active {
      background: rgba(25, 25, 30, 0.9);
      border-color: transparent;
      box-shadow: 0 12px 40px rgba(99, 102, 241, 0.2);
      transform: translateY(-2px);
    }

    .search-top:focus-within::before,
    .search-top.active::before {
      opacity: 1;
    }

    .search-top:focus-within .search-icon {
      color: #8b5cf6;
      opacity: 1;
      transform: scale(1.1);
    }

    /* Modern input field with smooth animations */
    .search-top input {
      background: transparent;
      border: none;
      border-radius: 20px;
      padding: 8px 12px 8px 12px;
      color: var(--search-text);
      font-size: 0.95rem;
      width: 100%;
      min-width: 200px;
      outline: none;
      transition: all 0.4s cubic-bezier(0.2, 0.8, 0.4, 1);
      font-family: 'Poppins', sans-serif;
      font-weight: 400;
      caret-color: #8b5cf6;
      letter-spacing: 0.3px;
      transform-origin: left center;
      box-shadow: 0 0 0 1px transparent;
    }

    .search-top:focus-within input {
      transform: scale(1.02);
      padding-left: 16px;
      box-shadow: none;
    }

    /* Enhanced input wrapper with animated effects */
    .search-input-wrapper {
      position: relative;
      flex: 1;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.03);
      transition: all 0.3s ease;
      overflow: hidden;
      border: 1px solid rgba(139, 92, 246, 0.3);
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
    }

    .search-top:focus-within .search-input-wrapper {
      background: rgba(255, 255, 255, 0.06);
      transform: translateY(0);
      box-shadow: 0 2px 12px rgba(139, 92, 246, 0.15);
    }

    /* Search results container */
    .search-results-container {
      position: fixed;
      top: 100px;
      /* Position from top of viewport */
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      width: 90%;
      max-width: 800px;
      max-height: 70vh;
      background: rgba(15, 15, 20, 0.98);
      border-radius: 16px;
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
      overflow: hidden;
      z-index: 2000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 1.5rem;
      box-sizing: border-box;
      /* Subtle gradient border effect */
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
      /* Subtle top highlight */
      position: relative;
    }

    /* Add subtle highlight to the top edge */
    .search-results-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      z-index: 1;
    }

    .search-top:focus-within+.search-results-container {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    /* Add overlay when search is active */
    .search-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      z-index: 1999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .search-top:focus-within~.search-overlay {
      opacity: 1;
      visibility: visible;
    }

    /* Subtle gradient border effect */
    .search-input-wrapper::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 8px;
      padding: 1px;
      background: linear-gradient(135deg,
          rgba(139, 92, 246, 0.4) 0%,
          rgba(99, 102, 241, 0.4) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask-composite: exclude;
      opacity: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
      transform: scale(0.98);
    }

    .search-top:focus-within .search-input-wrapper::before {
      opacity: 1;
      transform: scale(1);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        opacity: 0.8;
      }

      50% {
        opacity: 1;
      }

      100% {
        opacity: 0.8;
      }
    }

    /* Input placeholder animation */
    .search-top input::placeholder {
      color: rgba(255, 255, 255, 0.4);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      transform-origin: left center;
      font-weight: 300;
      letter-spacing: 0.2px;
    }

    .search-top:focus-within input::placeholder {
      transform: translateX(8px) scale(0.9);
      opacity: 0.7;
    }

    .search-top input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }


    /* Search button */
    /* Enhanced search button */
    .search-top button {
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      padding: 0.5rem;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
      z-index: 1;
    }

    /* Button hover effect */
    .search-top button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--btn-hover);
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: -1;
    }

    .search-top button::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.6s ease, height 0.6s ease, opacity 0.6s ease;
      opacity: 0;
      z-index: -1;
    }

    .search-top button:hover {
      color: white;
      transform: scale(1.1);
    }

    .search-top button:hover::before {
      opacity: 1;
    }

    .search-top button:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 2px 10px rgba(99, 102, 241, 0.2);
      background: var(--btn-active);
    }

    .search-top button:active::after {
      width: 200%;
      height: 200%;
      opacity: 0;
    }

    /* Ripple effect on click */
    @keyframes ripple {
      to {
        width: 200%;
        height: 200%;
        opacity: 0;
      }
    }

    .search-top button::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .search-top button:hover {
      transform: translateY(-1px) scale(1.05);
      box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
    }

    .search-top button:active {
      transform: translateY(1px) scale(0.98);
    }

    .search-top button:hover::after {
      opacity: 1;
    }

    /* Animation for search icon */
    @keyframes pulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.1);
      }

      100% {
        transform: scale(1);
      }
    }

    .search-top:focus-within .search-icon {
      animation: pulse 1.5s infinite;
    }

    /* Clear All button â€“ clean glass UI with icon animations */
    .clear-button {
      display: inline-flex;
      align-items: center;
      top: 40px;
      gap: 12px;
      padding: 0.7rem 1.15rem;
      border-radius: 999px;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      color: var(--text-color);
      font-weight: 500;
      font-size: 0.95rem;
      letter-spacing: 0.2px;
      backdrop-filter: blur(8px) saturate(120%);
      -webkit-backdrop-filter: blur(8px) saturate(120%);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background 0.2s ease, opacity 0.2s ease;
      cursor: pointer;
    }

    .clear-button i {
      width: 20px;
      height: 20px;
      display: inline-grid;
      place-items: center;
      color: var(--text-color);
      transition: transform 0.25s ease, color 0.2s ease, filter 0.2s ease;
    }

    .clear-button:hover {
      transform: translateY(-1px);
      border-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 12px 36px rgba(99, 102, 241, 0.25);
    }

    .clear-button:hover i {
      color: var(--accent);
    }

    .clear-button:active {
      transform: translateY(0);
    }

    .clear-button:active i {
      transform: rotate(0deg) scale(0.98);
    }

    .clear-button.is-empty {
      opacity: 0.55;
      cursor: default;
    }

    /* Dustbin dump animation */
    @keyframes dumpAnim {
      0% {
        transform: rotate(0deg) translateY(0);
      }

      30% {
        transform: rotate(-18deg) translateY(-1px);
      }

      60% {
        transform: rotate(-10deg) translateY(-1px);
      }

      100% {
        transform: rotate(0deg) translateY(0);
      }
    }

    .clear-button i.dump-anim {
      animation: dumpAnim 0.6s ease;
    }

    /* Confirmation Modal Styles */
    .confirm-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(6px) saturate(110%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.2s ease-out;
    }

    .confirm-modal {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 1.75rem 1.5rem;
      max-width: 520px;
      width: min(92vw, 520px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      animation: modalIn 0.24s cubic-bezier(0.22, 1, 0.36, 1);
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(8px) saturate(120%);
    }

    .confirm-modal.resume-confirm-modal {
      border-radius: 20px;
      width: min(92vw, 560px);
      padding: 1.85rem 1.6rem 1.35rem;
      background:
        radial-gradient(120% 120% at 10% 0%, rgba(23, 48, 95, 0.28) 0%, rgba(9, 12, 24, 0.95) 62%),
        linear-gradient(160deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
      border: 1px solid rgba(123, 175, 255, 0.24);
      box-shadow:
        0 30px 80px rgba(4, 8, 20, 0.7),
        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
    }

    .confirm-modal::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 16px;
      padding: 1px;
      /* border width */
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.02));
      -webkit-mask:
        linear-gradient(#000 0 0) content-box,
        linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
      mask:
        linear-gradient(#000 0 0) content-box,
        linear-gradient(#000 0 0);
      mask-composite: exclude;
      pointer-events: none;
    }

    .confirm-modal.closing {
      animation: modalOut 0.2s ease forwards;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    @keyframes modalIn {
      from {
        opacity: 0;
        transform: translateY(8px) scale(0.98);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes modalOut {
      from {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      to {
        opacity: 0;
        transform: translateY(8px) scale(0.98);
      }
    }

    .confirm-modal-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 1.5rem;
    }

    .confirm-modal-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent), #ff6b6b);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
    }

    .confirm-modal.resume-confirm-modal .confirm-modal-header {
      margin-bottom: 1.25rem;
      gap: 14px;
    }

    .confirm-modal.resume-confirm-modal .confirm-modal-icon {
      width: 42px;
      height: 42px;
      font-size: 19px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.96), rgba(220, 228, 255, 0.88));
      color: #111729;
      box-shadow: 0 8px 24px rgba(104, 151, 255, 0.3);
    }

    .confirm-modal.resume-confirm-modal .confirm-modal-title {
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: -0.01em;
      color: #f4f7ff;
    }

    .confirm-modal-title {
      font-size: 1.35rem;
      font-weight: 600;
      color: var(--text-color);
      margin: 0;
    }

    .confirm-modal-message {
      color: var(--text-secondary);
      font-size: 1rem;
      line-height: 1.6;
      margin-bottom: 2rem;
    }

    .confirm-modal.resume-confirm-modal .confirm-modal-message {
      margin-bottom: 1.8rem;
      color: rgba(231, 238, 255, 0.86);
      font-size: 1.17rem;
      line-height: 1.45;
    }

    .confirm-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 0.25rem;
    }

    .confirm-modal.resume-confirm-modal .confirm-modal-buttons {
      margin-top: 0.55rem;
      gap: 14px;
      justify-content: stretch;
    }

    .confirm-modal-btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'Poppins', sans-serif;
    }

    .confirm-modal.resume-confirm-modal .confirm-modal-btn {
      flex: 1 1 0;
      min-height: 52px;
      border-radius: 14px;
      font-size: 1.05rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      transition: transform 0.18s ease, box-shadow 0.2s ease, background 0.2s ease, border-color 0.2s ease;
    }

    .confirm-modal-btn-cancel {
      background: var(--theme-bg3);
      color: var(--text-color);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .confirm-modal.resume-confirm-modal .confirm-modal-btn-cancel {
      background: linear-gradient(145deg, rgba(20, 38, 74, 0.72), rgba(12, 27, 58, 0.72));
      border: 1px solid rgba(117, 162, 255, 0.35);
      color: rgba(228, 238, 255, 0.96);
    }

    .confirm-modal-btn-cancel:hover {
      background: var(--theme-bg1);
      transform: translateY(-2px);
    }

    .confirm-modal-btn-yes {
      background: linear-gradient(135deg, var(--accent), #ff6b6b);
      color: white;
      box-shadow: 0 4px 16px rgba(166, 108, 255, 0.25);
    }

    .confirm-modal.resume-confirm-modal .confirm-modal-btn-yes {
      background: linear-gradient(140deg, #0f1326 0%, #090b18 100%);
      border: 1px solid rgba(137, 167, 255, 0.36);
      color: #f5f8ff;
      box-shadow:
        0 10px 24px rgba(6, 8, 20, 0.55),
        0 0 24px rgba(89, 128, 255, 0.18);
    }

    .confirm-modal.resume-confirm-modal .confirm-modal-btn-cancel:hover,
    .confirm-modal.resume-confirm-modal .confirm-modal-btn-yes:hover {
      transform: translateY(-2px);
      box-shadow:
        0 14px 30px rgba(6, 8, 20, 0.55),
        0 0 30px rgba(89, 128, 255, 0.24);
    }

    @media (max-width: 640px) {
      .confirm-modal.resume-confirm-modal {
        padding: 1.5rem 1.1rem 1.1rem;
      }

      .confirm-modal.resume-confirm-modal .confirm-modal-title {
        font-size: 1.65rem;
      }

      .confirm-modal.resume-confirm-modal .confirm-modal-message {
        font-size: 1.02rem;
      }

      .confirm-modal.resume-confirm-modal .confirm-modal-buttons {
        flex-direction: column-reverse;
      }
    }

    .confirm-modal-btn-yes:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(166, 108, 255, 0.4);
    }

    .confirm-modal-btn:active {
      transform: translateY(0);
    }

    body.modal-open {
      overflow: hidden;
    }

    /* Action buttons in search area (home and search) share styles */
    .home-btn {
      position: relative;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: white;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      margin: 0 6px;
      padding: 0;
      box-sizing: border-box;
      outline: none;
      flex-shrink: 0;
      backdrop-filter: blur(10px);
    }

    .home-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 12px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      opacity: 0;
      transition: 0.6s;
    }

    .home-btn:hover::before {
      opacity: 1;
    }

    .home-btn:hover {
      transform: translateY(-2px);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
      box-shadow: 0 6px 20px rgba(255, 255, 255, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.2) inset;
      border-color: rgba(255, 255, 255, 0.3);
    }

    .home-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .home-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.25);
    }

    .home-btn:active {
      transform: translateY(0);
    }

    /* Remove default focus outline and add custom focus styles */
    .search-top input:focus {
      outline: none;
    }

    /* Add subtle animation to search results */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .movies-grid {
      animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      margin-top: 8rem;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .movie-card {
      animation: cardFadeIn 0.5s ease-out backwards;
    }

    .movie-card:nth-child(1) {
      animation-delay: 0.05s;
    }

    .movie-card:nth-child(2) {
      animation-delay: 0.1s;
    }

    .movie-card:nth-child(3) {
      animation-delay: 0.15s;
    }

    .movie-card:nth-child(4) {
      animation-delay: 0.2s;
    }

    .movie-card:nth-child(5) {
      animation-delay: 0.25s;
    }

    .movie-card:nth-child(6) {
      animation-delay: 0.3s;
    }

    @keyframes cardFadeIn {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .movies {
      margin-top: 0.6rem;
      padding-top: 1rem;
    }

    /* Category bar styles */
    #categoryBarMount {
      margin: 1.2rem auto 0.25rem !important;
      max-width: 1500px;
      padding: 0 1.5rem;
      box-sizing: border-box;
    }

    .movies-section {
      margin-top: 1.25rem;
      margin-bottom: 0.75rem;
    }

    .section-header {
      margin: 0 auto 1.85rem;
      padding: 0 1.5rem;
    }

    .section-title {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 700;
      line-height: 1.25;
      display: flex;
      align-items: center;
      gap: 0.65rem;
    }

    .category-bar {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin: 0.25rem 0 1.15rem;
      align-items: center;
      justify-content: flex-start;
      max-width: 100%;
      padding: 0;
    }

    .cat-btn {
      padding: 0.65rem 1.25rem;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(20, 24, 36, 0.72);
      color: rgba(255, 255, 255, 0.9);
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      font-size: 0.95rem;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      backdrop-filter: blur(16px) saturate(150%);
      -webkit-backdrop-filter: blur(16px) saturate(150%);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      position: relative;
      overflow: hidden;
      letter-spacing: 0.3px;
    }

    .cat-btn::before {
      content: none;
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: transparent;
      transform: translate(-50%, -50%);
      transition: width 0.5s ease, height 0.5s ease;
    }

    .cat-btn:hover {
      transform: translateY(-3px);
      border-color: rgba(130, 150, 190, 0.55);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(180, 200, 240, 0.14) inset;
      background: rgba(28, 34, 50, 0.82);
    }

    .cat-btn:active {
      transform: translateY(-1px) scale(0.98);
      box-shadow: 0 4px 12px rgba(167, 139, 250, 0.2);
    }

    .cat-btn:focus-visible {
      outline: none;
      border-color: rgba(167, 139, 250, 0.6);
      box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.3), 0 8px 20px rgba(167, 139, 250, 0.25);
    }

    .cat-btn.active {
      background: rgba(255, 255, 255, 0.16);
      color: #fff;
      border-color: rgba(255, 255, 255, 0.46);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.32), 0 0 0 1px rgba(255, 255, 255, 0.16) inset;
      transform: translateY(-3px);
      font-weight: 700;
    }

    .cat-btn.active::before {
      width: 0;
      height: 0;
      background: transparent;
    }

    .filter-group {
      position: relative;
      margin-left: 0.2rem;
    }

    .filter-toggle-btn {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.65rem 1.05rem;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(20, 24, 36, 0.72);
      color: rgba(255, 255, 255, 0.92);
      font-family: 'Poppins', sans-serif;
      font-size: 0.92rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.25s ease;
    }

    .filter-toggle-btn:hover {
      transform: translateY(-2px);
      border-color: rgba(255, 255, 255, 0.34);
      background: rgba(28, 34, 50, 0.85);
    }

    .filter-toggle-btn.active {
      border-color: rgba(255, 255, 255, 0.42);
      background: rgba(255, 255, 255, 0.16);
    }

    .filter-count {
      min-width: 18px;
      height: 18px;
      border-radius: 999px;
      padding: 0 5px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.72rem;
      font-weight: 700;
      background: rgba(255, 255, 255, 0.14);
      color: #fff;
    }

    .filter-count.hidden {
      display: none;
    }

    .genre-filter-panel {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      width: min(360px, calc(100vw - 2rem));
      padding: 0.8rem;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(10, 14, 22, 0.96);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      z-index: 21010;
      opacity: 0;
      transform: translateY(-4px) scale(0.98);
      pointer-events: none;
      transition: opacity 0.18s ease, transform 0.18s ease;
    }

    .genre-filter-panel.open {
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: auto;
    }

    .filter-panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.55rem;
    }

    .filter-panel-title {
      font-size: 0.88rem;
      font-weight: 700;
      letter-spacing: 0.2px;
      color: rgba(255, 255, 255, 0.95);
    }

    .filter-clear-btn {
      border: none;
      background: transparent;
      color: rgba(255, 255, 255, 0.72);
      font-size: 0.82rem;
      font-weight: 600;
      cursor: pointer;
      padding: 0.1rem 0.2rem;
    }

    .filter-clear-btn:hover {
      color: #fff;
    }

    .filter-clear-btn.hidden {
      display: none;
    }

    .filter-options-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.42rem 0.6rem;
      max-height: 280px;
      overflow-y: auto;
      padding-right: 2px;
    }

    .filter-option {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.86rem;
      line-height: 1.2;
      cursor: pointer;
      user-select: none;
      padding: 0.15rem 0.05rem;
    }

    .filter-option input {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
      pointer-events: none;
    }

    .filter-check {
      width: 16px;
      height: 16px;
      min-width: 16px;
      border-radius: 5px;
      border: 1px solid rgba(255, 255, 255, 0.32);
      background: rgba(255, 255, 255, 0.04);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: all 0.18s ease;
      position: relative;
    }

    .filter-check::after {
      content: '';
      width: 8px;
      height: 5px;
      border-left: 2px solid #05070d;
      border-bottom: 2px solid #05070d;
      transform: rotate(-45deg) scale(0.2);
      opacity: 0;
      transition: transform 0.16s ease, opacity 0.16s ease;
      margin-top: -1px;
    }

    .filter-option input:checked+.filter-check {
      background: #ffffff;
      border-color: #ffffff;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.12);
    }

    .filter-option input:checked+.filter-check::after {
      opacity: 1;
      transform: rotate(-45deg) scale(1);
    }

    .filter-option:hover .filter-check {
      border-color: rgba(255, 255, 255, 0.52);
    }

    @media (max-width: 640px) {
      .genre-filter-panel {
        width: min(320px, calc(100vw - 1.2rem));
      }

      .filter-options-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Report Problem Modal Styles */
    .report-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(6px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      animation: fadeIn 0.2s ease-out;
    }

    .report-modal {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 1.5rem;
      width: min(92vw, 640px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      animation: modalIn 0.24s cubic-bezier(0.22, 1, 0.36, 1);
    }

    .report-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 1rem;
    }

    .report-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .report-grid.full {
      grid-template-columns: 1fr;
    }

    .report-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .report-field label {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .report-input,
    .report-select,
    .report-textarea {
      background: var(--theme-bg3);
      border: 1px solid var(--glass-border);
      color: var(--text-color);
      border-radius: 10px;
      padding: 10px 12px;
      font-family: 'Poppins', sans-serif;
      font-size: 0.95rem;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .report-input:focus,
    .report-select:focus,
    .report-textarea:focus {
      border-color: rgba(166, 108, 255, 0.6);
      box-shadow: 0 0 0 2px rgba(166, 108, 255, 0.2);
    }

    /* Force darker, higher-contrast dropdown menu for the native <select> */
    .report-select {
      color-scheme: dark;
      background: rgba(8, 6, 12, 0.85);
    }

    .report-select option,
    .report-select optgroup {
      background-color: #0b0810;
      color: #fff;
    }

    /* Improve visibility of hovered/selected option in browsers that honor it */
    .report-select option:checked {
      background-color: #1a1220;
      color: #fff;
    }

    .report-textarea {
      min-height: 140px;
      resize: vertical;
    }

    .report-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 1rem;
    }

    .btn-ghost {
      padding: 0.65rem 1.1rem;
      border-radius: 10px;
      border: 1px solid var(--glass-border);
      background: var(--theme-bg3);
      color: var(--text-color);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-ghost:hover {
      transform: translateY(-1px);
    }

    .btn-primary {
      padding: 0.65rem 1.1rem;
      border-radius: 10px;
      border: 1px solid transparent;
      background: linear-gradient(135deg, var(--accent), #ff6b6b);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(166, 108, 255, 0.35);
      transition: transform 0.2s ease;
    }

    .btn-primary:hover {
      transform: translateY(-1px);
    }

    /* Report modal: custom dropdown styled like settings.html */
    .report-modal .custom-select {
      position: relative;
      width: 100%;
      user-select: none;
    }

    .report-modal .select-selected {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid var(--glass-border);
      color: #fff;
      cursor: pointer;
      transition: border-color .2s ease, box-shadow .2s ease, transform .15s ease;
    }

    .report-modal .select-selected:hover {
      transform: translateY(-1px);
    }

    .report-modal .select-arrow {
      display: flex;
      align-items: center;
    }

    .report-modal .select-arrow svg {
      width: 16px;
      height: 16px;
      fill: #cfc9ff;
      opacity: .85;
      transition: transform .2s ease;
    }

    .report-modal .select-items {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      right: 0;
      background: rgba(10, 8, 16, 0.95);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.6);
      padding: 6px;
      display: none;
      max-height: 220px;
      overflow-y: auto;
      z-index: 10002;
    }

    .report-modal .select-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      border-radius: 10px;
      color: #e9e6ff;
      cursor: pointer;
      transition: background .15s ease, box-shadow .15s ease, transform .05s ease;
    }

    .report-modal .select-option:hover {
      background: rgba(120, 70, 255, 0.15);
      box-shadow: inset 0 0 0 1px rgba(166, 108, 255, 0.35);
    }

    .report-modal .select-option[data-selected="true"] {
      background: linear-gradient(135deg, var(--accent), #ff6b6b);
      color: #fff;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.12) inset;
    }

    .report-modal .select-active .select-items {
      display: block;
    }

    .report-modal .select-active .select-arrow svg {
      transform: rotate(180deg);
    }

    /* hide original select but keep it functional if shown by assistive tech */
    .report-modal select.report-select {
      position: absolute;
      inset: auto auto auto -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
    }

    @media (max-width: 768px) {
      .search-top {
        padding: 8px 12px;
        border-radius: 10px;
      }

      .search-top input {
        width: 100%;
        max-width: none;
        font-size: 0.9rem;
      }

      .search-top button {
        width: 34px;
        height: 34px;
      }

      .topbar {
        padding: 0.75rem 1rem;
        flex-wrap: wrap;
        gap: 12px;
      }

      .topbar-search {
        order: 3;
        width: 100%;
        margin-top: 8px;
      }
    }

    header {
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      background: linear-gradient(135deg, rgba(15, 15, 25, 0.8) 0%, rgba(10, 10, 15, 0.9) 100%);
      border-radius: 20px;
      padding: 3rem 2rem;
      margin-bottom: 2rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.03) inset;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    header:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.08) inset;
    }

    header::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle at 30% 50%, rgba(167, 139, 250, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 70% 50%, rgba(251, 113, 133, 0.08) 0%, transparent 50%);
      opacity: 0.6;
      pointer-events: none;
      animation: headerGlow 15s ease-in-out infinite;
    }

    @keyframes headerGlow {

      0%,
      100% {
        transform: translate(0, 0) rotate(0deg);
      }

      50% {
        transform: translate(10px, 10px) rotate(5deg);
      }
    }

    h1 {
      font-weight: 700;
      font-size: 3.2rem;
      letter-spacing: -0.5px;
      text-align: center;
      margin-bottom: 0.75rem;
      background: linear-gradient(135deg, #a78bfa 0%, #fb7185 50%, #fbbf24 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 40px rgba(167, 139, 250, 0.3);
      position: relative;
      z-index: 1;
    }

    .subtitle {
      text-align: center;
      opacity: 0.85;
      font-weight: 400;
      margin-bottom: 1.5rem;
      font-size: 1.15rem;
      color: rgba(255, 255, 255, 0.8);
      letter-spacing: 0.3px;
      position: relative;
      z-index: 1;
    }

    /* legacy .search removed in favor of topbar search */
    .search {
      display: none !important;
    }

    #searchInput {
      flex: 1;
      padding: 15px 25px;
      font-size: 1rem;
      border: none;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(34, 34, 34, 0.2);
      color: var(--text-color);
      font-family: 'Poppins', sans-serif;
    }

    #searchInput::placeholder {
      color: var(--text-secondary);
    }

    /* Search button styles now handled by .home-btn class */

    @media (max-width: 1400px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
        gap: 1.25rem;
      }
    }

    @media (max-width: 1200px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        gap: 1.25rem;
      }
    }

    @media (max-width: 992px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 1.25rem;
        padding: 0 1rem;
      }
    }

    @media (max-width: 768px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 1rem;
        padding: 0 0.75rem;
      }
    }

    @media (max-width: 576px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        gap: 0.75rem;
        padding: 0 0.75rem;
      }

      .poster {
        width: 100% !important;
        max-width: 100% !important;
        min-width: 0 !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
      }

      .movie-title {
        font-size: 0.85rem;
        -webkit-line-clamp: 1;
        line-clamp: 1;
        max-height: 1.4em;
      }
    }

    @media (max-width: 420px) {
      .movies {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.85rem;
      }
    }

    /* Movies Grid Container */
    .movies-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 1.35rem;
      width: 100%;
      max-width: 1500px;
      margin: 0.85rem auto 0.9rem;
      padding: 0 1.5rem;
      box-sizing: border-box;
    }

    .movie-card {
      width: 100%;
      display: flex;
      flex-direction: column;
      background: linear-gradient(135deg, rgba(20, 20, 30, 0.7) 0%, rgba(15, 15, 25, 0.8) 100%);
      border-radius: 16px;
      overflow: hidden;
      transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.04) inset;
      cursor: pointer;
      position: relative;
      will-change: transform, box-shadow, border-color;
      transform: translateZ(0);
      transform-style: preserve-3d;
      aspect-ratio: 2/3;
    }

    .movie-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, transparent 55%, rgba(0, 0, 0, 0.95) 100%);
      z-index: 1;
      opacity: 0;
      transition: opacity 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .movie-card::after {
      content: '';
      position: absolute;
      inset: -1.5px;
      background: linear-gradient(135deg, rgba(167, 139, 250, 0.4), rgba(251, 113, 133, 0.3));
      border-radius: 16px;
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: -1;
      filter: blur(10px);
    }

    .movie-card:hover {
      transform: translateY(-12px) scale(1.025);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(167, 139, 250, 0.25) inset;
      border-color: rgba(167, 139, 250, 0.5);
    }

    .movie-card:hover::before {
      opacity: 1;
    }

    .movie-card:hover::after {
      opacity: 0.8;
    }

    .poster {
      position: relative;
      width: 100%;
      padding-top: 150%;
      /* restore original poster height for desktop */
      overflow: hidden;
      background: #1a1a1a;
      max-width: none;
      margin-left: 0;
      margin-right: 0;
    }

    /* Responsive: 3 per row on all screens, smaller posters on mobile */
    @media (max-width: 900px) {
      .movies-grid {
        grid-template-columns: repeat(3, 1fr);
        max-width: 100vw;
        gap: 1rem;
      }

      .poster {
        max-width: none;
        width: 100%;
        padding-top: 150%;
      }
    }

    @media (max-width: 600px) {
      #categoryBarMount {
        padding: 0 0.9rem;
        margin-top: 0.95rem !important;
      }

      .section-header {
        padding: 0 0.9rem;
        margin-bottom: 1.45rem;
      }

      .section-title {
        font-size: 1.1rem;
      }

      .movies-grid {
        grid-template-columns: repeat(3, 1fr);
        gap: 0.85rem;
        padding: 0 0.9rem;
      }

      .poster {
        max-width: none;
        width: 100%;
        padding-top: 150%;
      }
    }

    .movie-title-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
      padding: 12px 10px;
      color: white;
      font-size: 0.9rem;
      font-weight: 600;
      text-align: center;
      opacity: 0;
      transform: translateY(6px);
      transition: all 0.25s ease;
      z-index: 2;
      pointer-events: none;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .movie-card:hover .movie-title-overlay {
      opacity: 1;
      transform: translateY(0);
    }

    .movie-card:hover .movie-title-overlay {
      opacity: 1;
      transform: translateY(0);
    }

    .poster img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.3s ease, opacity 0.3s ease;
      background: linear-gradient(45deg, #1a1a1a 0%, #2d2d2d 100%);
    }

    .poster img[src*="placeholder"] {
      opacity: 0.7;
    }

    /* Video placeholder inside modal: lightweight until user clicks Play */
    .video-placeholder {
      width: 100%;
      height: 100%;
      position: relative;
      cursor: pointer;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .video-placeholder img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: brightness(0.6);
      display: block;
    }

    .video-play-btn {
      position: absolute;
      width: 84px;
      height: 84px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .video-play-btn::after {
      content: '';
      display: block;
      width: 0;
      height: 0;
      border-top: 14px solid transparent;
      border-bottom: 14px solid transparent;
      border-left: 20px solid rgb(250, 0, 0);
      margin-left: 6px;
    }

    /* Modal hero: large backdrop with poster and meta */
    .modal-hero {
      position: relative;
      width: 100%;
      height: 360px;
      border-top-left-radius: 24px;
      border-top-right-radius: 24px;
      overflow: hidden;
      margin-bottom: 18px;
    }

    /* StreamVerse-inspired Modal Design */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.94);
      z-index: 9999;
      backdrop-filter: blur(25px) saturate(1.8);
      overflow-y: auto;
      justify-content: center;
      align-items: center;
      padding: 20px;
      scrollbar-width: none;
    }

    .modal::-webkit-scrollbar {
      display: none;
    }


    .modal-content {
      position: relative;
      max-width: 900px;
      width: 100%;
      background: #0b0c10;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 50px 100px rgba(0, 0, 0, 1);
      border: 1px solid rgba(255, 255, 255, 0.05);
      margin: 0 auto;
      max-height: 95vh;
      overflow-y: auto;
    }

    .modal-hero {
      position: relative;
      height: 400px;
      width: 100%;
      overflow: hidden;
    }

    .modal-hero .hero-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center 20%;
      filter: brightness(0.45);
      z-index: 1;
    }

    .modal-hero::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 150px;
      background: linear-gradient(to top, #0b0c10, transparent);
      z-index: 4;
      /* Overlay top of trailer for blending */
      pointer-events: none;
    }

    .hero-inner {
      position: relative;
      margin-top: -160px;
      padding: 0 40px 30px;
      display: flex;
      gap: 35px;
      z-index: 10;
      align-items: flex-end;
    }

    .poster-thumb {
      width: 240px;
      min-width: 240px;
      aspect-ratio: 2/3;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
      background: #000;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .poster-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Trailer Play Icon Overlay */
    .modal-hero {
      cursor: pointer;
    }

    .play-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0);
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 5;
      /* Above video and gradient */
    }

    .modal-hero:hover .play-overlay {
      opacity: 1;
      background: rgba(0, 0, 0, 0.4);
    }

    .play-overlay i {
      font-size: 5.5rem;
      color: #fff;
      filter: drop-shadow(0 0 20px rgba(0, 0, 0, 0.5));
      transform: scale(0.6);
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .modal-hero:hover .play-overlay i {
      transform: scale(1);
      opacity: 1;
    }

    /* Integrated Trailer - Plays in Hero Position */
    .trailer-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      /* Between background (1) and gradient (4) */
      background: #000;
      display: none;
      animation: fadeIn 0.8s ease;
      overflow: hidden;
    }

    .trailer-container #trailerPlayer {
      width: 100%;
      height: 100%;
    }

    .trailer-container iframe {
      width: 100%;
      height: 100%;
      border: none;
      filter: brightness(0.9) saturate(1.05);
    }

    .close-trailer {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 18px;
      cursor: pointer;
      z-index: 40;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }


    .hero-meta {
      flex: 1;
      padding-bottom: 20px;
    }

    .hero-meta h2 {
      font-size: 2.5rem;
      font-weight: 850;
      margin-bottom: 8px;
      color: #fff;
      line-height: 1.05;
      letter-spacing: -0.5px;
    }

    .modal-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      font-size: 0.95rem;
      color: #ccc;
    }

    .meta-divider {
      color: #444;
    }

    .rating-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255, 255, 255, 0.1);
      padding: 4px 12px;
      border-radius: 6px;
      color: #ffc107;
      font-weight: 600;
    }

    /* Featured Hero (Main Page) */
    .featured-hero {
      position: relative;
      height: 100vh;
      width: 100%;
      display: flex;
      align-items: center;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      transition: background-image 0.5s ease;
    }

    .featured-hero-bg {
      /* Keep for backwards compatibility but make it invisible */
      display: none;
    }

    .featured-hero::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background:
        radial-gradient(circle at 25% 30%, rgba(0, 0, 0, 0.65) 0%, rgba(0, 0, 0, 0) 55%),
        linear-gradient(to right, rgba(7, 8, 12, 0.92) 0%, rgba(7, 8, 12, 0.55) 40%, rgba(7, 8, 12, 0.15) 100%);
      z-index: 1;
    }

    /* Subtle bottom blend so hero transitions into page background */
    .featured-hero::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 16%;
      background: linear-gradient(to bottom, rgba(15, 16, 20, 0) 0%, rgba(15, 16, 20, 0.45) 72%, #0f1014 100%);
      z-index: 2;
      pointer-events: none;
    }

    /* Subtle top fade + edge vignette for better blend */
    .featured-hero::before,
    .featured-hero::after {
      pointer-events: none;
    }

    .featured-hero::after {
      box-shadow: inset 0 26px 34px -28px rgba(15, 16, 20, 0.55);
    }

    .featured-hero-content {
      position: relative;
      z-index: 5;
      width: 100%;
      max-width: 700px;
      padding: 0 2rem;
      /* Shift the hero text to the right on larger screens */
      margin-left: 12rem;
    }

    /* Responsive adjustments for the hero content positioning */
    @media (max-width: 1200px) {
      .featured-hero-content {
        margin-left: 8rem;
        max-width: 650px;
      }
    }

    .featured-hero-title,
    .featured-hero-overview,
    .featured-hero-meta,
    .featured-hero-actions {
      max-width: 800px;
    }

    .featured-hero-badge {
      display: inline-block;
      padding: 6px 14px;
      background: linear-gradient(135deg, #e50914 0%, #b20710 100%);
      color: #fff;
      font-size: 0.85rem;
      font-weight: 800;
      border-radius: 4px;
      margin-bottom: 20px;
      letter-spacing: 1.5px;
      box-shadow: 0 4px 15px rgba(229, 9, 20, 0.4);
    }

    .featured-hero-title {
      font-size: 4.5rem;
      font-weight: 900;
      line-height: 1;
      margin-bottom: 15px;
      color: #fff;
      letter-spacing: -2px;
      font-family: 'Outfit', sans-serif;
    }

    .featured-hero-meta {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 25px;
      font-size: 1.1rem;
      color: #eee;
      font-weight: 500;
    }

    .featured-hero-rating {
      color: #ffc107;
      display: flex;
      align-items: center;
      gap: 6px;
      font-weight: 700;
    }

    .featured-hero-year {
      opacity: 0.9;
    }

    .featured-hero-type {
      text-transform: uppercase;
      font-size: 0.9rem;
      letter-spacing: 1px;
      opacity: 0.8;
    }

    .featured-hero-overview {
      font-size: 1.15rem;
      line-height: 1.5;
      color: rgba(255, 255, 255, 0.8);
      margin-bottom: 35px;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
      max-width: 500px;
    }

    .featured-hero-actions {
      display: flex;
      gap: 15px;
    }

    .featured-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 32px;
      border-radius: 10px;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: none;
    }

    .featured-btn.primary {
      background: #e50914;
      color: #fff;
      box-shadow: 0 6px 22px rgba(229, 9, 20, 0.35);
    }

    .featured-btn.primary:hover {
      background: #f40612;
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 10px 28px rgba(229, 9, 20, 0.45);
    }

    .featured-btn.secondary {
      background: rgba(109, 109, 110, 0.7);
      color: #fff;
      backdrop-filter: blur(10px);
    }

    .featured-btn.secondary:hover {
      background: rgba(109, 109, 110, 0.4);
      transform: translateY(-3px) scale(1.02);
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @media (max-width: 1024px) {
      .featured-hero-title {
        font-size: 3.5rem;
      }

      .featured-hero {
        height: 70vh;
      }

      /* Reduce hero left offset on medium screens */
      .featured-hero-content {
        margin-left: 4rem;
        max-width: 600px;
      }
    }

    @media (max-width: 768px) {
      .featured-hero {
        height: auto;
        min-height: 70vh;
        background-size: cover;
        background-position: center top;
        background-repeat: no-repeat;
        padding: 0 25px;
        width: 100vw;
        margin-left: calc(50% - 50vw);
        margin-right: calc(50% - 50vw);
        border-radius: 0;
      }
      body {
        padding: 0 !important;
      }

      .featured-hero-title {
        font-size: 2.8rem;
      }

      .featured-hero-overview {
        font-size: 1rem;
        -webkit-line-clamp: 2;
        line-clamp: 2;
      }

      .featured-btn {
        padding: 12px 24px;
        font-size: 1rem;
      }

      /* Small screens: minimize left offset and adjust padding */
      .featured-hero-content {
        margin-left: 1.25rem;
        padding: 0 1rem;
        max-width: 100%;
      }
    }

    @media (max-width: 480px) {
      .featured-hero {
        min-height: 65vh;
        background-size: cover;
        background-position: center 20%;
      }
    }

    .hero-actions {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-top: 35px;
      /* Moved down significantly */
    }

    .stream-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 30px;
      /* Slightly bigger padding */
      border-radius: 14px;
      font-weight: 700;
      font-size: 1rem;
      /* Slightly bigger font */
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid transparent;
      white-space: nowrap;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .stream-btn i {
      font-size: 1.1rem;
    }

    .primary-stream {
      background: linear-gradient(135deg, #ff0000 0%, #a70000 100%);
      color: #fff;
      box-shadow: 0 8px 25px rgba(229, 9, 20, 0.4);
    }


    .primary-stream:hover {
      background: linear-gradient(135deg, #ff1a1a 0%, #c40000 100%);
      transform: translateY(-3px) scale(1.03);
      box-shadow: 0 12px 30px rgba(229, 9, 20, 0.5);
    }

    .secondary-stream {
      background: rgba(255, 255, 255, 0.05);
      color: #fff;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .secondary-stream:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-3px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    }

    .genres {
      padding: 0 35px 15px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .genres span {
      background: rgba(255, 255, 255, 0.05);
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 0.9rem;
      color: #aaa;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .overview {
      padding: 0 35px 25px;
      font-size: 0.95rem;
      line-height: 1.5;
      color: #ddd;
      max-width: 800px;
    }

    .modal-info {
      padding: 0 35px 35px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
      padding-top: 25px;
    }

    .info-item {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .info-item strong {
      color: #666;
      text-transform: uppercase;
      font-size: 0.8rem;
      letter-spacing: 1px;
    }

    .info-item span {
      color: #fff;
      font-size: 1.1rem;
    }

    /* Modal Close Button */
    .close-btn {
      position: absolute;
      top: 25px;
      right: 25px;
      width: 45px;
      height: 45px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      z-index: 100;
      transition: 0.3s;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .close-btn:hover {
      background: #fff;
      color: #000;
    }

    /* Light Theme Adjustments for Modal */
    [data-theme="light"] .modal-content {
      background: #fff;
      border-color: rgba(0, 0, 0, 0.1);
    }

    [data-theme="light"] .hero-meta h2,
    [data-theme="light"] .info-item span {
      color: #000;
    }

    [data-theme="light"] .overview {
      color: #333;
    }

    [data-theme="light"] .modal-meta {
      color: #666;
    }

    [data-theme="light"] .info-item strong {
      color: #888;
    }

    [data-theme="light"] .modal-hero::after {
      background: linear-gradient(to top, #fff, transparent);
    }

    [data-theme="light"] .secondary-stream {
      background: rgba(0, 0, 0, 0.05);
      color: #000;
    }

    [data-theme="light"] .genres span {
      background: rgba(0, 0, 0, 0.05);
      color: #666;
    }



    /* Keep rating yellow */
    .modal.playing .movie-rating {
      color: #ffd700 !important;
    }

    /* When playing, reduce heavy visual effects to improve playback smoothness */
    .modal.playing {
      background: rgba(0, 0, 0, 0.98);
      backdrop-filter: none;
    }

    .modal.playing .modal-content {
      box-shadow: none;
      border: none;
      background: #0b0b0b;
    }

    /* When playing (dark content), force readable light text inside modal */
    .modal.playing .modal-content,
    .modal.playing .modal-content p,
    .modal.playing .overview,
    .modal.playing .modal-info p,
    .modal.playing .modal-info strong {
      color: rgba(255, 255, 255, 0.92) !important;
    }

    /* Keep rating yellow */
    .modal.playing .movie-rating {
      color: #ffd700 !important;
    }

    /* Badge that shows which MOVIE_* constant controls this card (edit the corresponding CSS blocks below)
       This helps you identify the movie code in VS Code and tweak styles per-movie. */
    .movie-code-badge {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 4px 8px;
      font-size: 0.75rem;
      border-radius: 6px;
      z-index: 5;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    /* Rating badge overlay on poster cards (modern pill style) */
    .poster .rating-badge {
      position: absolute;
      top: 10px;
      left: 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(20, 20, 20, 0.85);
      border: 1px solid rgba(255, 193, 7, 0.28);
      border-radius: 9999px;
      /* pill */
      color: #ffc107;
      font-weight: 700;
      font-size: 0.9rem;
      z-index: 6;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      pointer-events: none;
      /* keep clicks going to the card */
    }

    .poster .rating-badge .star {
      line-height: 1;
      font-size: 1rem;
      transform: translateY(-0.5px);
    }

    .poster .rating-badge .value {
      line-height: 1;
    }

    .poster .trending-rank-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      background: rgba(20, 20, 20, 0.85);
      border: 1px solid rgba(255, 61, 87, 0.3);
      border-radius: 8px;
      color: #ff3d57;
      font-weight: 700;
      font-size: 0.95rem;
      z-index: 6;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      pointer-events: none;
      letter-spacing: 0.5px;
    }

    .movie-card:hover .poster img {
      transform: scale(1.05);
      opacity: 0.9;
    }

    .movie-info {
      padding: 0.75rem;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .movie-title {
      font-size: 1.1rem;
      margin-bottom: 8px;
      font-weight: 500;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      line-clamp: 2;
      overflow: hidden;
      text-overflow: ellipsis;
      max-height: 2.8em;
      line-height: 1.4;
    }

    .movie-rating {
      color: #ffd700;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .play-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      width: 50px;
      height: 50px;
      background: rgba(32, 32, 32, 0.9);
      /* Netflix red with transparency */
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease, background-color 0.2s ease;
      z-index: 2;
      pointer-events: none;
      opacity: 0;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .movie-card:hover .play-icon {
      background: rgb(27, 27, 27, 0.8);
      /* Solid Netflix red on hover */
      transform: translate(-50%, -50%) scale(1.1);
    }

    .movie-card:hover .play-icon {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }

    .play-icon::before {
      content: '';
      width: 0;
      height: 0;
      border-top: 12px solid transparent;
      border-bottom: 12px solid transparent;
      border-left: 18px solid rgb(255, 0, 0);
      margin-left: 4px;
      transition: all 0.2s ease;
    }

    .movie-card:hover .play-icon::before {
      border-top-width: 14px;
      border-bottom-width: 14px;
      border-left-width: 20px;
      margin-left: 6px;
    }

    .card-edit-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.06);
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      cursor: pointer;
      z-index: 4;
      color: white;
      font-size: 14px;
    }

    .movie-card:hover .play-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    /* Responsive StreamVerse Modal */
    @media (max-width: 900px) {
      .hero-inner {
        flex-direction: column;
        align-items: center;
        margin-top: -120px;
        text-align: center;
        padding: 0 20px 30px;
      }

      .poster-thumb {
        width: 200px;
        min-width: 200px;
      }

      .hero-meta h2 {
        font-size: 2rem;
      }

      .modal-meta {
        justify-content: center;
      }

      .hero-actions {
        justify-content: center;
      }

      .overview,
      .genres,
      .modal-info {
        padding: 0 20px 30px;
      }

      .modal-info {
        grid-template-columns: 1fr 1fr;
      }
    }

    @media (max-width: 500px) {
      .modal {
        padding: 0;
      }

      .modal-content {
        border-radius: 0;
      }

      .modal-hero {
        height: 350px;
      }

      .modal-info {
        grid-template-columns: 1fr;
      }
    }


    .close-btn {
      position: absolute;
      top: 1.25rem;
      right: 1.5rem;
      font-size: 1.75rem;
      cursor: pointer;
      z-index: 10;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      color: #ffffff;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      will-change: transform, background-color;
      transform-origin: center;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      backdrop-filter: blur(10px);
    }

    .close-btn:hover {
      background: rgba(229, 9, 20, 0.9);
      border-color: rgba(229, 9, 20, 1);
      transform: rotate(90deg) scale(1.1);
      box-shadow: 0 4px 15px rgba(229, 9, 20, 0.4);
    }

    .close-btn:active {
      transform: rotate(90deg) scale(0.95);
      transition-duration: 0.15s;
    }

    /* Bookmark/Star Button - Inline version */
    .bookmark-btn-inline {
      display: inline-flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.85rem 1.5rem;
      font-size: 0.95rem;
      cursor: pointer;
      border-radius: 12px;
      color: #ffc107;
      background: rgba(255, 193, 7, 0.12);
      border: 1px solid rgba(255, 193, 7, 0.3);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      white-space: nowrap;
      letter-spacing: 0.3px;
    }

    .bookmark-btn-inline:hover {
      background: rgba(255, 193, 7, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
      border-color: rgba(255, 193, 7, 0.4);
    }

    .bookmark-btn-inline:active {
      transform: translateY(0);
    }

    .bookmark-btn-inline.bookmarked {
      background: rgba(255, 193, 7, 0.25);
      border-color: rgba(255, 193, 7, 0.5);
    }

    .bookmark-btn-inline i {
      transition: all 0.2s ease;
      font-size: 1.1rem;
    }

    .bookmark-btn-inline.bookmarked i {
      font-weight: 900;
    }

    @media (max-width: 768px) {
      .bookmark-btn-inline {
        width: 100%;
        justify-content: center;
      }


    }

    .bookmark-text {
      white-space: nowrap;
    }

    /* Light theme adjustments */
    [data-theme="light"] .bookmark-btn-inline {
      background: rgba(255, 215, 0, 0.15);
      border-color: rgba(255, 215, 0, 0.4);
    }

    [data-theme="light"] .bookmark-btn-inline:hover {
      background: rgba(255, 215, 0, 0.3);
    }

    [data-theme="light"] .bookmark-btn-inline.bookmarked {
      background: rgba(255, 215, 0, 0.4);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .bookmark-btn-inline {
        width: 100%;
        justify-content: center;
      }
    }

    /* Light theme contrast improvements */
    [data-theme="light"] .close-btn {
      background: rgba(0, 0, 0, 0.08);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
    }

    [data-theme="light"] .close-btn:hover {
      background: rgba(0, 0, 0, 0.12);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.12);
    }

    [data-theme="light"] .close-btn:active {
      background: rgba(0, 0, 0, 0.18);
    }

    .modal-header {
      padding: 2rem 2.5rem 1rem;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.3) 0%, transparent 100%);
    }

    #modalTitle {
      font-size: 2.2rem;
      margin: 0 0 0.75rem 0;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #e0e0e0 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      line-height: 1.2;
      letter-spacing: -0.5px;
    }

    .modal-meta {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.7);
      font-weight: 500;
    }

    .meta-divider {
      color: rgba(255, 255, 255, 0.3);
    }

    .rating-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      background: rgba(255, 193, 7, 0.15);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 20px;
      color: #ffc107;
      font-weight: 600;
    }

    .rating-badge i {
      font-size: 0.85rem;
    }

    /* Modern Custom Dropdown Styles for Series Selector */
    .series-picker {
      display: flex;
      flex-direction: row;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
      padding: 0;
    }

    .hero-meta .series-picker {
      width: 100%;
      margin-top: 12px;
      align-items: flex-start;
    }

    .series-meta {
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.95rem;
      font-weight: 500;
      flex: 0 0 auto;
    }

    .hero-meta .series-meta {
      width: 100%;
      margin-bottom: 10px;
    }

    .series-selectors {
      display: flex;
      flex-direction: row;
      gap: 16px;
      align-items: center;
      flex: 1;
    }

    .hero-meta .series-selectors {
      width: 100%;
      margin-bottom: 12px;
    }

    .series-play-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      width: 100%;
    }

    .hero-meta .series-play-actions {
      display: none;
    }

    @media (max-width: 600px) {
      .series-selectors {
        flex-direction: column;
        align-items: stretch;
      }

      .series-play-actions {
        flex-direction: column;
      }
    }

    .custom-select-wrapper {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 10px;
    }

    .select-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.3px;
      white-space: nowrap;
    }

    .custom-select {
      position: relative;
      min-width: 180px;
    }

    .select-trigger {
      background: linear-gradient(135deg, rgba(30, 30, 30, 0.95) 0%, rgba(20, 20, 20, 0.95) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 14px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: all 0.3s ease;
      user-select: none;
    }

    .select-trigger:hover {
      border-color: rgba(167, 139, 250, 0.4);
      background: linear-gradient(135deg, rgba(35, 35, 35, 0.95) 0%, rgba(25, 25, 25, 0.95) 100%);
      box-shadow: 0 4px 12px rgba(167, 139, 250, 0.1);
    }

    .custom-select.active .select-trigger {
      border-color: rgba(167, 139, 250, 0.6);
      box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.1);
    }

    .select-value {
      color: #fff;
      font-size: 0.95rem;
      font-weight: 500;
    }

    .select-arrow {
      color: rgba(255, 255, 255, 0.6);
      transition: transform 0.3s ease;
    }

    .custom-select.active .select-arrow {
      transform: rotate(180deg);
    }

    .select-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      background: linear-gradient(135deg, rgba(25, 25, 25, 0.98) 0%, rgba(15, 15, 15, 0.98) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      max-height: 280px;
      overflow-y: auto;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
    }

    .custom-select.active .select-dropdown {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .select-dropdown::-webkit-scrollbar {
      width: 6px;
    }

    .select-dropdown::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
    }

    .select-dropdown::-webkit-scrollbar-thumb {
      background: rgba(167, 139, 250, 0.5);
      border-radius: 10px;
    }

    .select-dropdown::-webkit-scrollbar-thumb:hover {
      background: rgba(167, 139, 250, 0.7);
    }

    .select-option {
      padding: 12px 16px;
      cursor: pointer;
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.93rem;
      transition: all 0.2s ease;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .select-option:last-child {
      border-bottom: none;
    }

    .select-option:hover {
      background: rgba(167, 139, 250, 0.15);
      color: #fff;
      padding-left: 20px;
    }

    .select-option.selected {
      background: rgba(167, 139, 250, 0.2);
      color: #fff;
      font-weight: 600;
    }

    .select-option.selected::before {
      content: 'âœ“ ';
      margin-right: 8px;
      color: rgba(167, 139, 250, 1);
    }

    .trailer-container {
      margin: 0;
      width: 100%;
      aspect-ratio: 16/9;
      border-radius: 0;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      position: relative;
      background: #000;
    }

    #trailerFrame {
      width: 100%;
      height: 100%;
      border: none;
    }

    .trailer-youtube-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 0, 0, 0.95);
      border: none;
      color: #fff;
      padding: 12px 18px;
      border-radius: 8px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      box-shadow: 0 4px 12px rgba(255, 0, 0, 0.4);
      transition: all 0.3s ease;
      z-index: 10;
    }

    .trailer-youtube-btn:hover {
      background: rgba(255, 0, 0, 1);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(255, 0, 0, 0.6);
    }

    .overview {
      margin: 0;
      padding: 1rem 2.5rem;
      line-height: 1.8;
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.8);
      font-weight: 400;
    }

    .genres {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 1.25rem 2.5rem 0.75rem;
    }

    .genre-chip {
      padding: 0.4rem 1rem;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.85rem;
      font-weight: 500;
      letter-spacing: 0.3px;
      transition: all 0.2s ease;
    }

    .genre-chip:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .modal-info {
      padding: 0.75rem 2.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .info-item {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.9rem;
    }

    .info-item i {
      color: rgba(255, 255, 255, 0.5);
      font-size: 0.95rem;
    }

    .info-item strong {
      opacity: 0.7;
      font-weight: 600;
      margin-right: 0.25rem;
    }

    .modal-actions {
      padding: 1.5rem 2.5rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
      background: linear-gradient(0deg, rgba(0, 0, 0, 0.2) 0%, transparent 100%);
    }



    /* Toast notifications */
    .toast-container {
      position: fixed;
      top: 18px;
      right: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 120000;
      /* above modal (6000) and overlays */
      pointer-events: none;
      /* allow clicks through gaps */
    }

    .toast {
      min-width: 260px;
      max-width: 90vw;
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--glass-border);
      background: rgba(22, 22, 28, 0.9);
      color: var(--text-color);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(10px);
      animation: slideIn 280ms ease both;
      pointer-events: auto;
      /* toast itself clickable */
    }

    .toast .icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 28px;
      margin-top: 2px;
      background: rgba(255, 255, 255, 0.06);
    }

    .toast .icon svg {
      width: 16px;
      height: 16px;
      display: block;
    }

    .toast .title {
      font-weight: 600;
      margin-bottom: 2px;
    }

    .toast .msg {
      opacity: 0.9;
    }

    .toast .close {
      margin-left: auto;
      background: transparent;
      border: none;
      color: inherit;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      opacity: 0.8;
    }

    .toast .close:hover {
      opacity: 1;
    }

    .toast.info {
      border-left: 4px solid #60a5fa;
    }

    .toast.success {
      border-left: 4px solid #34d399;
    }

    .toast.warning {
      border-left: 4px solid #fbbf24;
    }

    .toast.error {
      border-left: 4px solid #f87171;
    }

    .toast.info .icon {
      background: rgba(96, 165, 250, 0.15);
    }

    .toast.success .icon {
      background: rgba(52, 211, 153, 0.15);
    }

    .toast.warning .icon {
      background: rgba(251, 191, 36, 0.15);
    }

    .toast.error .icon {
      background: rgba(248, 113, 113, 0.15);
    }

    @keyframes slideIn {
      from {
        transform: translateY(-8px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Light theme adjustments */
    [data-theme="light"] .toast {
      background: rgba(255, 255, 255, 0.94);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.15);
    }

    /* Modern translucent scrollbars (WebKit/Blink) */
    /* Global scrollbars */
    *::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    *::-webkit-scrollbar-track {
      background: transparent;
    }

    *::-webkit-scrollbar-thumb {
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.18);
      border: 2px solid transparent;
      background-clip: padding-box;
    }

    *::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.28);
      background-clip: padding-box;
    }

    /* Light theme tweak */
    [data-theme="light"] *::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.18);
      border: 2px solid transparent;
      background-clip: padding-box;
    }

    [data-theme="light"] *::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.28);
    }

    /* Modal content specific (ensures consistent look inside modal scroll area) */
    .modal-content::-webkit-scrollbar {
      width: 10px;
      background: var(--scrollbar-track);
      border-radius: 12px;
    }

    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }

      .movies {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 1rem;
      }

      .poster {
        height: 260px;
      }

      h1 {
        font-size: 2rem;
      }


    }

    /* ------------------------------------------------------------------
       Per-movie CSS blocks
       Edit these blocks to change sizes/spacing for each movie individually.
       Example: change the height below to make the poster taller/shorter.
       Keep the class name format: .movie-<id>  where <id> is the MOVIE_* id.
       ------------------------------------------------------------------ */
    /* Small phones: leave space for the user button on the right */
    @media (max-width: 480px) {
      #userMenuComponent {
        right: 0.5rem;
        top: 0.5rem;
      }

      .user-menu-btn {
        padding: 4px 8px;
        gap: 6px;
        border-radius: 10px;
      }

      .user-avatar {
        width: 28px;
        height: 28px;
      }

      .user-name {
        display: none;
      }

      .user-dropdown {
        min-width: 200px;
        right: 0;
        left: auto;
        transform: translateY(8px);
      }

      .user-dropdown::before {
        right: 16px;
      }

      /* Constrain search to avoid overlapping user menu */
      #searchComponent {
        top: 0.5rem;
        left: 1rem;
        right: 9.5rem;
        transform: none;
        width: auto;
        max-width: none;
        padding: 0;
      }

      .search-top {
        height: 46px;
        gap: 8px;
        padding: 8px 12px;
        border-radius: 16px;
        max-width: 100%;
        width: 100%;
        background: rgba(20, 20, 28, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
        align-items: center;
        background-clip: padding-box;
      }

      /* Remove outer glow ring on mobile */
      .search-top::before {
        display: none !important;
        opacity: 0 !important;
      }

      .search-top .search-icon {
        width: 18px;
        height: 18px;
        opacity: 0.85;
      }

      .search-top input {
        font-size: 0.92rem;
        line-height: 1.2;
        min-width: 100px;
        padding: 0 6px;
      }

      .search-top:focus-within .search-icon {
        transform: none;
      }

      .search-results-container {
        top: 72px;
        left: 0.5rem;
        right: 0.5rem;
        width: auto;
        transform: none;
        max-height: 65vh;
        padding: 12px;
        border-radius: 14px;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35);
      }
    }

    /* Narrow tablets / large phones */
    @media (max-width: 640px) and (min-width: 481px) {
      #userMenuComponent {
        right: 0.75rem;
        top: 0.75rem;
      }

      #searchComponent {
        top: 0.75rem;
        left: 1rem;
        right: 10rem;
        transform: none;
        width: auto;
      }

      .search-top {
        height: 56px;
        padding: 10px 12px;
        max-width: 100%;
        width: 100%;
        border-radius: 18px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .search-top .home-btn,
      .search-top button {
        width: 48px;
        height: 48px;
        border-radius: 999px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .search-input-wrapper {
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
        border-radius: 999px;
      }

      .search-top input {
        width: 100%;
        min-width: 0;
        padding: 12px 16px;
        font-size: 1rem;
        line-height: 1.25;
      }

      .search-results-container {
        left: 1rem;
        right: 10rem;
        width: auto;
        transform: none;
        top: 84px;
      }
    }

    /* Tablets / landscape phones: 641â€“900px */
    @media (min-width: 641px) and (max-width: 900px) {
      #userMenuComponent {
        right: 1rem;
        top: 1rem;
      }

      /* Leave more room for the user button at this size */
      #searchComponent {
        top: 1rem;
        left: 1rem;
        right: 12rem;
        transform: none;
        width: auto;
      }

      .search-top {
        height: 56px;
        padding: 10px 14px;
        border-radius: 18px;
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(20, 20, 28, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.30);
      }

      .search-top .home-btn,
      .search-top button {
        width: 48px;
        height: 48px;
        border-radius: 999px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .search-input-wrapper {
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .search-top input {
        width: 100%;
        min-width: 0;
        padding: 12px 16px;
        font-size: 1rem;
        line-height: 1.25;
      }

      .search-results-container {
        left: 1rem;
        right: 12rem;
        width: auto;
        transform: none;
        top: 90px;
      }
    }

    /* Unified phones <=600px: make everything inside the search bar fit */
    @media (max-width: 600px) {

      /* Ensure the component uses available width and items don't overflow */
      #searchComponent {
        width: auto;
      }

      .search-top {
        display: flex;
        align-items: center;
        gap: 10px;
        height: 56px;
        padding: 10px 12px;
        background: rgba(20, 20, 28, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 18px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.30);
      }

      .search-top .search-icon {
        width: 16px;
        height: 16px;
        opacity: 0.85;
      }

      /* Circular icon buttons (home, search) */
      .search-top .home-btn,
      .search-top button {
        width: 48px;
        height: 48px;
        border-radius: 999px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.04) inset, 0 6px 16px rgba(0, 0, 0, 0.35);
      }

      .search-input-wrapper {
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .search-top input {
        width: 100%;
        min-width: 0;
        padding: 12px 16px;
        font-size: 1rem;
        line-height: 1.25;
        text-overflow: ellipsis;
      }

      .search-top button:active {
        transform: translateY(0);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      }

      .search-results-container {
        left: 1rem;
        right: 9.5rem;
        width: auto;
        max-height: 65vh;
        top: 84px;
      }
    }

    /* Hide brand on small screens */
    @media (max-width: 640px) {

      #brandComponent,
      .brand {
        display: none !important;
      }
    }

    @media (max-width: 360px) {
      .search-top {
        height: 40px;
        padding: 4px 8px;
      }

      .user-avatar {
        width: 24px;
        height: 24px;
      }
    }

    /* Final search bar override: simple, clean, stable across breakpoints */
    :root {
      --search-height: 50px;
      --search-top-gap: 0.72rem;
      --search-right-safe: 12rem;
      --search-right-offset: 11.2rem;
      --search-collapsed-size: 48px;
      --search-expanded-max: 360px;
    }

    #searchComponent {
      position: fixed !important;
      top: var(--search-top-gap) !important;
      left: auto !important;
      right: var(--search-right-offset) !important;
      transform: none !important;
      width: var(--search-collapsed-size) !important;
      z-index: 20020 !important;
      pointer-events: auto !important;
      transition: width 0.28s cubic-bezier(0.22, 1, 0.36, 1) !important;
    }

    #searchComponent.expanded {
      width: min(var(--search-expanded-max), calc(100vw - var(--search-right-safe) - 1.5rem)) !important;
    }

    #searchComponent .search-top {
      position: relative !important;
      display: flex !important;
      align-items: center !important;
      gap: 8px !important;
      height: var(--search-height) !important;
      min-height: var(--search-height) !important;
      width: 100% !important;
      padding: 0 7px !important;
      border-radius: 999px !important;
      border: 1px solid rgba(255, 255, 255, 0.12) !important;
      background: rgba(18, 20, 27, 0.92) !important;
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.34) !important;
      backdrop-filter: blur(10px) !important;
      -webkit-backdrop-filter: blur(10px) !important;
      transform: none !important;
      overflow: hidden !important;
    }

    #searchComponent .search-top::before {
      display: none !important;
      content: none !important;
    }

    #searchComponent #homeBtn {
      display: none !important;
      width: 34px !important;
      height: 34px !important;
      min-width: 34px !important;
      margin: 0 !important;
      border-radius: 999px !important;
      border: 1px solid rgba(255, 255, 255, 0.14) !important;
      background: rgba(255, 255, 255, 0.07) !important;
      box-shadow: none !important;
      color: rgba(255, 255, 255, 0.86) !important;
    }

    #searchComponent.expanded.has-results #homeBtn {
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
    }

    #searchComponent .search-input-shell {
      flex: 1 1 auto !important;
      min-width: 0 !important;
      max-width: 0 !important;
      border: none !important;
      background: transparent !important;
      box-shadow: none !important;
      padding: 0 !important;
      opacity: 0 !important;
      pointer-events: none !important;
      transform: translateX(-10px) !important;
      transition: max-width 0.28s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.2s ease, transform 0.28s ease !important;
    }

    #searchComponent.expanded .search-input-shell {
      max-width: 420px !important;
      opacity: 1 !important;
      pointer-events: auto !important;
      transform: translateX(0) !important;
    }

    #searchInput {
      width: 100% !important;
      min-width: 0 !important;
      padding: 0 6px !important;
      margin: 0 !important;
      background: transparent !important;
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
      font-size: 0.98rem !important;
      font-weight: 500 !important;
      color: rgba(255, 255, 255, 0.92) !important;
    }

    #searchInput::placeholder {
      color: rgba(255, 255, 255, 0.5) !important;
    }

    /* Keep browser autofill consistent with dark search UI */
    #searchInput:-webkit-autofill,
    #searchInput:-webkit-autofill:hover,
    #searchInput:-webkit-autofill:focus,
    #searchInput:-webkit-autofill:active {
      -webkit-text-fill-color: rgba(255, 255, 255, 0.92) !important;
      caret-color: rgba(255, 255, 255, 0.92) !important;
      -webkit-box-shadow: 0 0 0px 1000px rgba(18, 20, 27, 0.96) inset !important;
      box-shadow: 0 0 0px 1000px rgba(18, 20, 27, 0.96) inset !important;
      border-radius: 999px !important;
      transition: background-color 9999s ease-out 0s !important;
    }

    #searchInput:-moz-autofill {
      box-shadow: 0 0 0px 1000px rgba(18, 20, 27, 0.96) inset !important;
      -moz-text-fill-color: rgba(255, 255, 255, 0.92) !important;
      color: rgba(255, 255, 255, 0.92) !important;
      caret-color: rgba(255, 255, 255, 0.92) !important;
    }

    #searchComponent #searchBtn {
      width: 34px !important;
      height: 34px !important;
      min-width: 34px !important;
      margin: 0 !important;
      border-radius: 999px !important;
      border: 1px solid rgba(255, 255, 255, 0.14) !important;
      background: rgba(255, 255, 255, 0.07) !important;
      box-shadow: none !important;
      transform: none !important;
      color: rgba(255, 255, 255, 0.86) !important;
    }

    #searchComponent #searchBtn::before,
    #searchComponent #searchBtn::after {
      display: none !important;
      content: none !important;
    }

    #searchComponent #searchBtn svg {
      width: 16px !important;
      height: 16px !important;
      opacity: 0.9 !important;
    }

    #searchComponent .search-overlay {
      display: none !important;
    }

    .search-results-container {
      top: calc(var(--search-top-gap) + var(--search-height) + 10px) !important;
      left: auto !important;
      right: var(--search-right-offset) !important;
      transform: none !important;
      width: min(var(--search-expanded-max), calc(100vw - var(--search-right-safe) - 1.5rem)) !important;
    }

    @media (max-width: 900px) {
      :root {
        --search-height: 47px;
        --search-top-gap: 0.6rem;
        --search-right-safe: 10.8rem;
        --search-right-offset: 10rem;
        --search-expanded-max: 320px;
      }
    }

    @media (max-width: 700px) {
      :root {
        --search-height: 45px;
        --search-top-gap: 0.55rem;
        --search-right-safe: 5.55rem;
        --search-right-offset: 4.65rem;
        --search-collapsed-size: 42px;
        --search-expanded-max: 300px;
      }

      #userMenuComponent .user-name {
        display: none !important;
      }

      #userMenuComponent {
        top: 0.55rem !important;
        right: 0.55rem !important;
      }

      #userMenuComponent .user-menu-btn {
        height: 42px !important;
        min-height: 42px !important;
        padding: 0 0.52rem 0 0.42rem !important;
        border-radius: 999px !important;
        gap: 0.38rem !important;
      }

      #userMenuComponent .user-avatar {
        width: 26px !important;
        height: 26px !important;
      }

      #userMenuComponent .user-caret {
        font-size: 0.72rem !important;
        opacity: 0.78 !important;
      }

      #searchComponent {
        top: var(--search-top-gap) !important;
        left: auto !important;
        right: var(--search-right-offset) !important;
        transform: none !important;
      }

      #searchInput {
        font-size: 0.92rem !important;
      }

      .search-results-container {
        left: auto !important;
        right: var(--search-right-offset) !important;
        top: calc(var(--search-top-gap) + var(--search-height) + 8px) !important;
        width: min(var(--search-expanded-max), calc(100vw - var(--search-right-safe) - 1.1rem)) !important;
        transform: none !important;
      }
    }

    @media (max-width: 420px) {
      :root {
        --search-right-safe: 5rem;
        --search-right-offset: 4.15rem;
        --search-expanded-max: 230px;
      }

      .search-results-container {
        width: min(var(--search-expanded-max), calc(100vw - var(--search-right-safe) - 1rem)) !important;
      }
    }
  </style>
</head>

<body>
  <!-- Particle Background -->
  <div class="bg-particles" id="particles"></div>




  <div class="container">
    <!-- Topbar Components -->
    <div class="topbar-wrapper">
      <!-- Brand/Logo Component -->
      <div class="topbar-component" id="brandComponent">
        <div class="brand">
          <h1 class="brand-title">Cinematic Hub</h1>
          <div class="brand-sub">Curated collection</div>
        </div>
      </div>

      <!-- Search Component -->
      <div class="topbar-component" id="searchComponent">
        <div class="search-top" id="searchTop">
          <button id="homeBtn" class="home-btn" aria-label="Home" title="Show all movies">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
              <path
                d="M8.707 1.5a1 1 0 0 0-1.414 0L.646 8.146a.5.5 0 0 0 .708.708L8 2.207l6.646 6.647a.5.5 0 0 0 .708-.708L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.707 1.5Z" />
              <path d="m8 3.293 6 6V13.5a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 13.5V9.293l6-6Z" />
            </svg>
          </button>
          <button id="searchBtn" class="home-btn" aria-label="Search" title="Search movies">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
              <path
                d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0" />
            </svg>
          </button>
          <div class="search-input-shell">
            <input type="text" id="searchInput" placeholder="Search movies, genres, year..." aria-label="Search movies" />
          </div>
          <div class="search-overlay"></div>
        </div>
      </div>

      <!-- Modern User Menu Component -->
      <div id="userMenuComponent">
        <button class="user-menu-btn" id="userMenuBtn">
          <div class="user-avatar" id="userAvatar">
            <img id="userAvatarImg" src="" alt="Profile"
              style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; display: none;">
            <span id="userInitial" style="position: absolute; font-weight: 600; font-size: 14px; color: white;">U</span>
          </div>
          <span class="user-name" id="userName">User</span>
          <i class="fas fa-chevron-down user-caret"></i>
        </button>

        <div class="user-dropdown">
          <a href="profiles.html" class="dropdown-item">
            <i class="fas fa-user"></i>
            <span>Switch Profile</span>
          </a>
          <a href="mylist.html" class="dropdown-item" id="myListLink">
            <i class="far fa-bookmark"></i>
            <span>My List</span>
          </a>
          <a href="settings.html" class="dropdown-item" id="settingsLink">
            <i class="fas fa-cog"></i>
            <span>Settings</span>
          </a>
          <a href="#" class="dropdown-item" id="updatesLink">
            <i class="fas fa-bullhorn"></i>
            <span>Updates</span>
          </a>
          <div class="dropdown-divider"></div>
          <a href="#" class="dropdown-item" id="helpLink">
            <i class="fas fa-question-circle"></i>
            <span>Help Center</span>
          </a>
          <div class="dropdown-divider"></div>
          <a href="#" class="dropdown-item" id="signOutLink">
            <i class="fas fa-sign-out-alt"></i>
            <span>Sign Out</span>
          </a>
        </div>
      </div>

      <div id="updatesModal" class="updates-modal-overlay" aria-hidden="true">
        <div class="updates-modal-card" role="dialog" aria-modal="true" aria-labelledby="updatesModalTitle">
          <div class="updates-modal-head">
            <h3 id="updatesModalTitle" class="updates-modal-title">
              <i class="fas fa-bullhorn"></i>
              <span>Latest Updates</span>
            </h3>
            <button id="updatesCloseBtn" class="updates-close-btn" type="button" aria-label="Close updates modal">
              <i class="fas fa-times"></i>
            </button>
          </div>
          <div class="updates-modal-body">
            <span class="updates-version" id="updatesVersionTag">Build Update</span>
            <p class="updates-summary" id="updatesSummaryText"></p>
            <div id="updatesSections"></div>
          </div>
          <div class="updates-modal-foot">
            <button id="updatesCloseActionBtn" class="updates-cta" type="button">Close</button>
          </div>
        </div>
      </div>

      <script>
        // Show resume prompt modal if there is a valid continue watching entry
        document.addEventListener('DOMContentLoaded', function () {
          try {
            const continueWatchingStr = localStorage.getItem(getContinueWatchingKey());
            const continueWatching = continueWatchingStr ? JSON.parse(continueWatchingStr) : {};
            // Find the most recent valid entry
            const validMovies = Object.values(continueWatching).filter(m => {
              return m && m.progress > 0 && m.progress < 95 && m.title && m.title !== 'Untitled';
            });
            if (validMovies.length > 0) {
              validMovies.sort((a, b) => (Number(b.updatedAt || b.timestamp || 0)) - (Number(a.updatedAt || a.timestamp || 0)));
              const movie = validMovies[0];
              // Only show if not already on player.html and not in search mode
            }
          } catch (e) { console.error('Resume prompt error:', e); }
        });

        // Toggle user dropdown
        const userMenuBtn = document.getElementById('userMenuBtn');

        // Handle dropdown toggle
        if (userMenuBtn) {
          userMenuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            userMenuBtn.classList.toggle('active');
          });

          // Close dropdown when clicking outside
          document.addEventListener('click', (e) => {
            if (!e.target.closest('#userMenuComponent')) {
              userMenuBtn.classList.remove('active');
            }
          });

          // Close dropdown when pressing Escape key
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
              userMenuBtn.classList.remove('active');
            }
          });

          // Handle sign out
          const signOutLink = document.getElementById('signOutLink');
          if (signOutLink) {
            signOutLink.addEventListener('click', async (e) => {
              e.preventDefault();
              try {
                await FirebaseAuth.signOut();
                window.location.href = 'login.html';
              } catch (error) {
                console.error('Error signing out:', error);
              }
            });
          }

          // Handle settings navigation
          const settingsLink = document.getElementById('settingsLink');
          if (settingsLink) {
            settingsLink.addEventListener('click', (e) => {
              userMenuBtn.classList.remove('active');
              // Let the default link behavior handle the navigation
            });
          }


          // Handle updates link (fallback binding for early script path)
          const updatesLink = document.getElementById('updatesLink');
          if (updatesLink && !updatesLink.dataset.fallbackBound) {
            updatesLink.dataset.fallbackBound = '1';
            updatesLink.addEventListener('click', (e) => {
              e.preventDefault();
              userMenuBtn.classList.remove('active');
              const opener = window.showAppUpdatesModal;
              if (typeof opener === 'function') {
                opener();
                return;
              }
              const modal = document.getElementById('updatesModal');
              if (modal) {
                modal.classList.add('show');
                modal.setAttribute('aria-hidden', 'false');
                document.body.style.overflow = 'hidden';
              }
            });
          }

          // Handle help link â†’ open in-app report modal
          const helpLink = document.getElementById('helpLink');
          if (helpLink) {
            helpLink.addEventListener('click', (e) => {
              e.preventDefault();
              userMenuBtn.classList.remove('active');
              if (typeof showReportProblem === 'function') showReportProblem();
            });
          }
        }

        // Load user profile data
        async function loadUserProfile() {
          try {
            console.log('Loading user profile...');
            const user = FirebaseAuth.getUser();
            console.log('Current user:', user);
            if (!user) {
              console.log('No user logged in');
              return;
            }

            // Get the selected profile
            console.log('Fetching profile for user:', user.uid);
            const profile = await FirebaseAuth.getSelectedProfile(user.uid);
            console.log('Retrieved profile:', profile);
            if (!profile) {
              console.log('No profile found for user');
              return;
            }

            const userAvatar = document.getElementById('userAvatar');
            const userAvatarImg = document.getElementById('userAvatarImg');
            const userInitial = document.getElementById('userInitial');
            const userNameEl = document.getElementById('userName');

            if (profile.name && userNameEl) {
              userNameEl.textContent = profile.name;
              userNameEl.classList.remove('hide-mobile');
              if (profile.name.length >= 5 && window.matchMedia('(orientation: portrait)').matches) {
                userNameEl.classList.add('hide-mobile');
              }
            }

            if (profile.avatarUrl) {
              // Show the avatar image if available
              userAvatarImg.src = profile.avatarUrl;
              userAvatarImg.style.display = 'block';
              userInitial.style.display = 'none';

              // Add a fallback in case the image fails to load
              userAvatarImg.onerror = () => {
                userAvatarImg.style.display = 'none';
                if (profile.name) {
                  userInitial.textContent = profile.name.charAt(0).toUpperCase();
                }
                userInitial.style.display = 'flex';
              };
            } else if (profile.name) {
              // Fallback to initial if no avatar URL
              userInitial.textContent = profile.name.charAt(0).toUpperCase();
              userInitial.style.display = 'flex';
              userAvatarImg.style.display = 'none';
            }

            // Update the avatar background with the profile color if available
            if (profile.color) {
              userAvatar.style.background = profile.color;
            }

          } catch (error) {
            console.error('Error loading user profile:', error);
            // Fallback to default if there's an error
            const userNameEl = document.getElementById('userName');
            const userInitial = document.getElementById('userInitial');
            if (userNameEl) userNameEl.textContent = 'User';
            if (userInitial) userInitial.textContent = 'U';
          }
        }

        // Load profile when auth state changes
        console.log('Setting up auth state listener...');
        if (typeof FirebaseAuth !== 'undefined') {
          console.log('FirebaseAuth is defined, version:', FirebaseAuth.SDK_VERSION);

          // Set up auth state listener
          FirebaseAuth.onAuthChanged((user) => {
            console.log('Auth state changed, user:', user ? 'Logged in' : 'Logged out');
            if (user) {
              console.log('User is signed in, loading profile...');
              loadUserProfile();
            } else {
              console.log('No user is signed in');
            }
          });

          // Also try loading immediately in case auth is already done
          console.log('Checking current auth state...');
          const currentUser = FirebaseAuth.getUser();
          console.log('Current user from immediate check:', currentUser);
          if (currentUser) {
            console.log('User already authenticated, loading profile...');
            loadUserProfile();
          }
        }
      </script>
    </div>

    <!-- Featured Hero Section -->
    <section class="featured-hero" id="featuredHero">
      <div class="featured-hero-bg" id="featuredHeroBg"></div>
      <div class="featured-hero-content">
        <div class="featured-hero-badge">NOW STREAMING</div>
        <h1 class="featured-hero-title" id="featuredTitle">Loading...</h1>
        <div class="featured-hero-meta">
          <span class="featured-hero-rating">
            <i class="fas fa-star"></i>
            <span id="featuredRating">-</span>
          </span>
          <span class="featured-hero-year" id="featuredYear">-</span>
          <span class="featured-hero-type">Movie</span>
        </div>
        <p class="featured-hero-overview" id="featuredOverview"></p>
        <div class="featured-hero-actions">
          <button class="featured-btn primary" id="featuredWatchBtn">
            <i class="fas fa-play"></i> Watch Now
          </button>
          <button class="featured-btn secondary" id="featuredDetailsBtn">
            <i class="fas fa-info-circle"></i> More Details
          </button>
        </div>
      </div>
    </section>

    <!-- Continue Watching Section -->
    <section id="continueWatchingSection" class="continue-watching-section" style="display: none;">
      <div class="section-header">
        <h2 class="section-title">
          <i class="fas fa-redo"></i> Continue Watching
        </h2>
        <button id="cwClearAll" class="cw-clear-btn" aria-label="Clear all continue watching" title="Clear All">
          <span class="cw-clear-icon" aria-hidden="true"><i class="fas fa-trash-alt"></i></span>
          <span class="cw-clear-text">Clear All</span>
        </button>
      </div>
      <div class="continue-watching-container" id="continueWatchingContainer"></div>
    </section>

    <!-- Category Buttons Mount -->
    <div id="categoryBarMount" style="margin: 1rem 20px 0;"></div>

    <section class="movies-section" id="popularMoviesSection">
      <div class="section-header">
        <h2 class="section-title">
          <i class="fas fa-fire"></i> Popular Movies
        </h2>
      </div>
      <div class="movies-grid" id="trendingMoviesContainer"></div>
    </section>

    <section class="movies-section" id="popularTVSection">
      <div class="section-header">
        <h2 class="section-title">
          <i class="fas fa-tv"></i> Popular Series
        </h2>
      </div>
      <div class="movies-grid" id="trendingTVContainer"></div>
    </section>

    <div class="movies" id="moviesContainer"></div>
  </div>

  <div class="modal" id="movieModal">
    <div class="modal-content">
      <span class="close-btn" id="closeModal">&times;</span>

      <div class="modal-hero" id="modalHero">
        <div class="hero-bg" id="modalHeroBg"></div>
        <div class="trailer-container" id="trailerContainer">
          <span class="close-trailer" id="closeTrailer">&times;</span>
          <div id="trailerPlayer"></div>
        </div>
        <div class="play-overlay"><i class="fas fa-play"></i></div>
      </div>

      <div class="hero-inner">
        <div class="poster-thumb" id="modalPoster">
          <img id="modalPosterImg" src="" alt="Poster" loading="eager" />
        </div>

        <div class="hero-meta">
          <h2 id="modalTitle"></h2>
          <div class="modal-meta">
            <span class="meta-item" id="modalYear"></span>
            <span class="meta-divider">â€¢</span>
            <span class="meta-item rating-badge">
              <i class="fas fa-star"></i>
              <span id="modalRating"></span>
            </span>
          </div>
          <div class="hero-actions">
            <button class="stream-btn primary-stream" id="streamBtn">
              <i class="fas fa-play"></i>
              <span>Watch Now</span>
            </button>
            <button class="stream-btn secondary-stream" id="streamBtn2">
              <i class="fas fa-play-circle"></i>
              <span>Stream 2</span>
            </button>
            <button class="stream-btn secondary-stream" id="streamBtn3">
              <i class="fas fa-broadcast-tower"></i>
              <span>Stream 3</span>
            </button>
            <button class="stream-btn secondary-stream" id="bookmarkBtn">
              <i class="far fa-bookmark"></i>
              <span class="bookmark-text">Add to List</span>
            </button>
          </div>
          <div class="series-picker" id="seriesPicker" style="display:none;">
            <div class="series-meta" id="seriesMeta"></div>
            <div class="series-selectors">
              <div class="custom-select-wrapper">
                <label class="select-label">Season</label>
                <div class="custom-select" id="seasonSelectWrapper">
                  <div class="select-trigger" id="seasonTrigger">
                    <span class="select-value">Select Season</span>
                    <svg class="select-arrow" width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                      <path d="M2 4l4 4 4-4H2z" />
                    </svg>
                  </div>
                  <div class="select-dropdown" id="seasonDropdown"></div>
                </div>
              </div>
              <div class="custom-select-wrapper">
                <label class="select-label">Episode</label>
                <div class="custom-select" id="episodeSelectWrapper">
                  <div class="select-trigger" id="episodeTrigger">
                    <span class="select-value">Select Episode</span>
                    <svg class="select-arrow" width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                      <path d="M2 4l4 4 4-4H2z" />
                    </svg>
                  </div>
                  <div class="select-dropdown" id="episodeDropdown"></div>
                </div>
              </div>
            </div>
            <select id="seasonSelect" style="display:none;" aria-hidden="true"></select>
            <select id="episodeSelect" style="display:none;" aria-hidden="true"></select>
            <div class="series-play-actions">
              <button id="seriesPlayBtn" class="stream-btn primary-stream">
                <i class="fas fa-play"></i>
                <span>Play Episode</span>
              </button>
              <button id="seriesPlayBtnPlayer" class="stream-btn secondary-stream">
                <i class="fas fa-play-circle"></i>
                <span>Stream 2</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="genres" id="modalGenres"></div>

      <p class="overview" id="modalOverview"></p>

      <div class="modal-info">
        <div class="info-item">
          <strong>Release Date</strong>
          <span id="modalReleaseDate"></span>
        </div>
        <div class="info-item">
          <strong>Status</strong>
          <span id="modalStatus">Released</span>
        </div>
        <div class="info-item" id="directorInfo">
          <strong>Director</strong>
          <span id="modalDirector">N/A</span>
        </div>
      </div>

    </div>
  </div>

  <!-- Toast container -->
  <div id="toastContainer" class="toast-container" aria-live="polite" aria-atomic="true"></div>

  <script>

    // --- Ensure themePresets and isSearching are declared first ---
    const themePresets = {
      glossy: {
        bgs: ['rgba(255,255,255,0.06)', 'rgba(255,0,100,0.10)', 'rgba(0,120,255,0.10)'],
        accent: 'linear-gradient(90deg,#ff6b6b,#6b66ff)',
        particles: ['#ff6b6b', '#6b66ff']
      },
      crimson: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(220,38,38,0.14)', 'rgba(244,63,94,0.12)'],
        accent: 'linear-gradient(90deg,#ef4444,#f97316)',
        particles: ['#ef4444', '#f97316']
      },
      ocean: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(14,165,233,0.14)', 'rgba(6,182,212,0.12)'],
        accent: 'linear-gradient(90deg,#22d3ee,#60a5fa)',
        particles: ['#22d3ee', '#60a5fa']
      },
      emerald: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(5,150,105,0.14)', 'rgba(16,185,129,0.12)'],
        accent: 'linear-gradient(90deg,#10b981,#22c55e)',
        particles: ['#10b981', '#22c55e']
      },
      purple: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(147,51,234,0.14)', 'rgba(99,102,241,0.12)'],
        accent: 'linear-gradient(90deg,#a78bfa,#6366f1)',
        particles: ['#a78bfa', '#6366f1']
      },
      sunset: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(251,146,60,0.16)', 'rgba(236,72,153,0.12)'],
        accent: 'linear-gradient(90deg,#f59e0b,#ec4899)',
        particles: ['#f59e0b', '#ec4899']
      },
      neon: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(34,211,238,0.18)', 'rgba(217,70,239,0.14)'],
        accent: 'linear-gradient(90deg,#22d3ee,#d946ef)',
        particles: ['#22d3ee', '#d946ef']
      },
      graphite: {
        bgs: ['rgba(255,255,255,0.04)', 'rgba(107,114,128,0.18)', 'rgba(75,85,99,0.14)'],
        accent: 'linear-gradient(90deg,#6b7280,#9ca3af)',
        particles: ['#6b7280', '#9ca3af']
      },
      gold: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(234,179,8,0.18)', 'rgba(245,158,11,0.14)'],
        accent: 'linear-gradient(90deg,#eab308,#f59e0b)',
        particles: ['#eab308', '#f59e0b']
      }
    };
    let isSearching = false; // Track if we're currently showing search results

    // ...existing code...
    (function loadYouTubeAPI() {
      if (window.YT && window.YT.Player) return;
      const s = document.createElement('script');
      s.src = 'https://www.youtube.com/iframe_api';
      s.async = true;
      document.head.appendChild(s);
    })();

    let ytPlayer = null;
    let ytPlayerId = null;
    let pendingPlayer = null; // {host, key}
    let ytReady = false;
    const ytQueue = [];
    let currentTrailerKey = null; // Store current trailer key for fallback
    let activeTrailerMessageHandler = null;

    window.onYouTubeIframeAPIReady = function () {
      ytReady = true;
      while (ytQueue.length) {
        const req = ytQueue.shift();
        if (req && req.host && req.key) {
          createYTPlayerFor(req.host, req.key);
        }
      }
    };

    function createYTPlayerFor(host, key) {
      if (!host || !key) return;

      // Queue if API not ready
      if (!ytReady || !window.YT || !YT.Player) {
        ytQueue.push({ host, key });
        pendingPlayer = { host, key };
        return;
      }

      // Store current key for fallback
      currentTrailerKey = key;

      // Clear existing content
      host.innerHTML = '';

      const id = `yt-player-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
      const wrapper = document.createElement('div');
      wrapper.id = id;
      wrapper.style.width = '100%';
      wrapper.style.height = '100%';
      host.appendChild(wrapper);

      ytPlayerId = id;
      ytPlayer = new YT.Player(id, {
        videoId: key,
        playerVars: {
          autoplay: 1,
          rel: 0,
          modestbranding: 1,
          playsinline: 1
        },
        events: {
          onReady: (event) => {
            try { event.target.playVideo(); } catch (_) { }
          },
          onError: (err) => {
            console.warn('YouTube embed error', err);
            // Show error message in player area
            const container = document.getElementById(id);
            if (container && container.parentElement) {
              container.parentElement.innerHTML = `
                <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#1a1a1a;color:#fff;flex-direction:column;gap:15px;padding:20px;text-align:center;">
                  <svg width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                  </svg>
                  <div style="font-size:1.1rem;font-weight:500;">This video cannot be embedded</div>
                  <div style="font-size:0.9rem;color:#999;max-width:400px;">The video owner has restricted playback on other websites.</div>
                  <a href="https://www.youtube.com/watch?v=${key}" target="_blank" style="margin-top:10px;padding:10px 20px;background:#e50914;color:#fff;text-decoration:none;border-radius:6px;font-weight:500;">Watch on YouTube</a>
                </div>
              `;
            }
          }
        }
      });
    }

    // All hardcoded movies removed - using TMDB API instead


    const curatedMovies = [];
    // Note: Using TMDB API instead of hardcoded movies to avoid conflicts

    // Support email config (edit this to your target email)
    const SUPPORT_EMAIL = 'moive776@gmail.com';
    // Email sending is now handled securely via backend API. All client-side EmailJS config and usage removed.

    function showConfirmModal(options = {}) {
      const {
        title = 'Confirm',
        message = '',
        confirmText = 'OK',
        cancelText = 'Cancel',
        iconClass = 'fa-solid fa-circle-question',
        modalClass = ''
      } = options;

      return new Promise((resolve) => {
        // Prevent duplicate modals
        const existing = document.querySelector('.confirm-modal-overlay');
        if (existing) {
          existing.remove();
        }

        const overlay = document.createElement('div');
        overlay.className = 'confirm-modal-overlay';
        const modal = document.createElement('div');
        modal.className = modalClass ? `confirm-modal ${modalClass}` : 'confirm-modal';
        modal.innerHTML = `
          <div class="confirm-modal-header">
            <div class="confirm-modal-icon"><i class="${iconClass}"></i></div>
            <h3 class="confirm-modal-title">${title}</h3>
          </div>
          <div class="confirm-modal-message">${message}</div>
          <div class="confirm-modal-buttons">
            <button class="confirm-modal-btn confirm-modal-btn-cancel" type="button">${cancelText}</button>
            <button class="confirm-modal-btn confirm-modal-btn-yes" type="button">${confirmText}</button>
          </div>
        `;
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        document.body.classList.add('modal-open');

        const close = (result) => {
          modal.classList.add('closing');
          overlay.style.animation = 'fadeOut 0.2s ease-out';
          setTimeout(() => {
            overlay.remove();
            document.body.classList.remove('modal-open');
            document.removeEventListener('keydown', onKey);
            resolve(result);
          }, 200);
        };

        const onKey = (e) => {
          if (e.key === 'Escape') close(false);
          if (e.key === 'Enter') close(true);
        };
        document.addEventListener('keydown', onKey);

        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) close(false);
        });

        modal.querySelector('.confirm-modal-btn-cancel').addEventListener('click', () => close(false));
        modal.querySelector('.confirm-modal-btn-yes').addEventListener('click', () => close(true));
      });
    }

    window.showConfirmModal = showConfirmModal;

    function formatResumeTime(seconds) {
      const total = Math.max(0, Math.floor(Number(seconds) || 0));
      const h = Math.floor(total / 3600);
      const m = Math.floor((total % 3600) / 60);
      const s = total % 60;
      if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      return `${m}:${String(s).padStart(2, '0')}`;
    }

    function getResumePromptData(watchData) {
      if (!watchData || typeof watchData !== 'object') return { canResume: false, resumeSeconds: 0, progress: 0 };

      const duration = Number(watchData.duration) || 0;
      const savedCurrent = Number(watchData.currentTime) || 0;
      const rawProgress = Number(watchData.progress) || 0;
      const percentBased = duration > 0 && rawProgress > 0 ? (duration * rawProgress) / 100 : 0;
      const resumeSeconds = Math.floor(savedCurrent > 0 ? savedCurrent : percentBased);
      const computedProgress = duration > 0 && resumeSeconds > 0 ? (resumeSeconds / duration) * 100 : 0;
      const effectiveProgress = rawProgress > 0 ? rawProgress : computedProgress;
      const canResume = resumeSeconds >= 30 && effectiveProgress < 95;

      return {
        canResume,
        resumeSeconds,
        progress: Math.max(0, Math.round(effectiveProgress))
      };
    }

    async function askResumeChoice(watchData) {
      const resume = getResumePromptData(watchData);
      if (!resume.canResume) return { wantsResume: false, resumeSeconds: 0, prompted: false };

      const progressLine = resume.progress > 0
        ? `<div style="opacity:.8;font-size:13px;margin-top:6px;">Progress: ${resume.progress}%</div>`
        : '';
      const message = `Resume from <strong>${formatResumeTime(resume.resumeSeconds)}</strong>?${progressLine}`;

      let wantsResume = false;
      if (typeof window.showConfirmModal === 'function') {
        wantsResume = await window.showConfirmModal({
          title: 'Continue Watching',
          message,
          confirmText: 'Resume',
          cancelText: 'Start Over',
          iconClass: 'fa-solid fa-circle-play',
          modalClass: 'resume-confirm-modal'
        });
      } else {
        wantsResume = window.confirm(`Resume from ${formatResumeTime(resume.resumeSeconds)}?`);
      }

      return { wantsResume, resumeSeconds: resume.resumeSeconds, prompted: true };
    }

    function showReportProblem() {
      // prevent duplicates
      if (document.querySelector('.report-overlay')) return;
      const overlay = document.createElement('div');
      overlay.className = 'report-overlay';
      const modal = document.createElement('div');
      modal.className = 'report-modal';
      modal.innerHTML = `
          <div class="report-title">
            <i class="fas fa-life-ring"></i>
            Report a Problem
          </div>
          <div class="report-grid">
            <div class="report-field">
              <label for="reportType">Category</label>
              <select id="reportType" class="report-select">
                <option>Playback issue</option>
                <option>Subtitles</option>
                <option>Login / Profiles</option>
                <option>Continue Watching</option>
                <option>Other</option>
              </select>
            </div>
            <div class="report-field">
              <label for="reportEmail">Your email (optional)</label>
              <input id="reportEmail" class="report-input" type="email" placeholder="you@example.com" />
            </div>
          </div>
          <div class="report-grid full" style="margin-top:10px;">
            <div class="report-field">
              <label for="reportSubject">Subject</label>
              <input id="reportSubject" class="report-input" type="text" placeholder="Short summary" />
            </div>
            <div class="report-field">
              <label for="reportDesc">Description</label>
              <textarea id="reportDesc" class="report-textarea" placeholder="Describe what happened, steps to reproduce, expected vs actual..."></textarea>
            </div>
            <label style="display:flex;align-items:center;gap:8px;margin-top:4px;color:var(--text-secondary);font-size:0.9rem;">
              <input id="reportDiag" type="checkbox" checked /> Include diagnostics (browser, page, profile)
            </label>
          </div>
          <div class="report-actions">
            <button class="btn-ghost" id="reportCancel">Cancel</button>
            <button class="btn-primary" id="reportSubmit">Report</button>
          </div>
        `;
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
      document.body.classList.add('modal-open');

      // Add mobile-specific style for report email input
      const style = document.createElement('style');
      style.innerHTML = `
          @media (max-width: 600px) {
            .report-modal .report-input[type="email"] {
              max-width: 220px;
              width: 90%;
              min-width: 140px;
            }
          }
        `;
      document.head.appendChild(style);

      // Prefill user email if available
      try {
        const getUser = window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function' ? window.FirebaseAuth.getUser : null;
        const user = getUser ? getUser() : null;
        if (user && user.email) modal.querySelector('#reportEmail').value = user.email;
      } catch (_) { }

      // Build a custom dropdown for Category, matching settings.html style
      (function () {
        const nativeSelect = modal.querySelector('#reportType');
        if (!nativeSelect) return;
        const field = nativeSelect.parentElement;
        // Create custom structure
        const selectedText = nativeSelect.options[nativeSelect.selectedIndex]?.text || nativeSelect.options[0]?.text || '';
        const custom = document.createElement('div');
        custom.className = 'custom-select';
        custom.innerHTML = `
            <div class="select-selected" tabindex="0">
              <span class="selected-option">${selectedText}</span>
              <span class="select-arrow">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M7 10l5 5 5-5z"></path></svg>
              </span>
            </div>
            <div class="select-items" role="listbox"></div>
          `;
        const items = custom.querySelector('.select-items');
        // Populate items from native select
        Array.from(nativeSelect.options).forEach(opt => {
          const div = document.createElement('div');
          div.className = 'select-option';
          div.textContent = opt.textContent;
          div.dataset.value = opt.value || opt.textContent;
          if (opt.selected) div.setAttribute('data-selected', 'true');
          items.appendChild(div);
        });

        // Hide native select (kept for value/state)
        nativeSelect.classList.add('report-select');
        field.appendChild(custom);

        const selBtn = custom.querySelector('.select-selected');
        const selectedSpan = custom.querySelector('.selected-option');
        const optionDivs = Array.from(items.querySelectorAll('.select-option'));

        function openClose(toggle) {
          const makeOpen = toggle === undefined ? !custom.classList.contains('select-active') : !!toggle;
          custom.classList.toggle('select-active', makeOpen);
        }

        function choose(value, text) {
          nativeSelect.value = value;
          selectedSpan.textContent = text;
          optionDivs.forEach(d => d.removeAttribute('data-selected'));
          const match = optionDivs.find(d => (d.dataset.value === value));
          if (match) match.setAttribute('data-selected', 'true');
          openClose(false);
        }

        selBtn.addEventListener('click', (e) => { e.stopPropagation(); openClose(); });
        selBtn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openClose(); }
          if (e.key === 'Escape') { openClose(false); }
        });
        optionDivs.forEach(d => d.addEventListener('click', () => choose(d.dataset.value, d.textContent)));

        // Close when clicking outside
        const onDocClick = (e) => { if (!custom.contains(e.target)) openClose(false); };
        document.addEventListener('click', onDocClick);
        // Ensure listener removed on modal close
        const prevClose = close;
        close = function () { document.removeEventListener('click', onDocClick); prevClose(); };
      })();

      function close() {
        modal.classList.add('closing');
        overlay.style.animation = 'fadeOut 0.2s ease-out';
        setTimeout(() => { overlay.remove(); document.body.classList.remove('modal-open'); }, 200);
      }
      modal.querySelector('#reportCancel').addEventListener('click', close);
      overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });

      // Submit handler
      const submitBtn = modal.querySelector('#reportSubmit');
      submitBtn.addEventListener('click', () => {
        const t = modal.querySelector('#reportType').value;
        const fromEmail = modal.querySelector('#reportEmail').value.trim();
        const subject = modal.querySelector('#reportSubject').value.trim() || `[${t}] User report`;
        const desc = modal.querySelector('#reportDesc').value.trim();
        const includeDiag = modal.querySelector('#reportDiag').checked;

        const lines = [];
        lines.push(`Category: ${t}`);
        if (fromEmail) lines.push(`Reporter: ${fromEmail}`);
        if (desc) { lines.push(''); lines.push(desc); }
        if (includeDiag) {
          try {
            const getUser = window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function' ? window.FirebaseAuth.getUser : null;
            const user = getUser ? getUser() : null;
            const uid = user && user.uid;
            const profileKey = uid ? localStorage.getItem(`fb_selected_profile_${uid}`) : null;
            lines.push('');
            lines.push('--- Diagnostics ---');
            lines.push(`URL: ${location.href}`);
            lines.push(`Time: ${new Date().toISOString()}`);
            lines.push(`User-Agent: ${navigator.userAgent}`);
            lines.push(`UID: ${uid || 'guest'}`);
            lines.push(`Profile: ${profileKey || 'n/a'}`);
          } catch (_) { }
        }
        const message = lines.join('\n');


        // Set to true if you want to allow fallback to mailto: links, false to only copy to clipboard
        const ALLOW_MAILTO_FALLBACK = false;
        const copyFallback = () => {
          try {
            navigator.clipboard && navigator.clipboard.writeText(message);
            if (window.UIToast && UIToast.info) UIToast.info('Copied report to clipboard', 'Direct send unavailable. Paste into any email/chat.');
          } catch (_) {
            if (window.UIToast && UIToast.warning) UIToast.warning('Direct send unavailable', 'Could not copy automatically.');
          }
        };

        const doMailto = () => {
          if (!ALLOW_MAILTO_FALLBACK) { copyFallback(); return close(); }
          const mailto = `mailto:${encodeURIComponent(SUPPORT_EMAIL)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(message)}`;
          window.location.href = mailto;
          close();
          if (window.UIToast && UIToast.success) UIToast.success('Report prepared', 'Your email client will open a pre-filled report.');
        };

        // Button loading state
        submitBtn.disabled = true;
        const prevText = submitBtn.textContent;
        submitBtn.textContent = 'Sendingâ€¦';

        const finish = (ok) => {
          submitBtn.disabled = false;
          submitBtn.textContent = prevText;
          if (ok) close();
        };

        // Validate config
        const hasEmailJsConfig = EMAILJS.enabled && EMAILJS.serviceId && EMAILJS.templateId && EMAILJS.publicKey;
        if (!hasEmailJsConfig) {
          if (window.UIToast && UIToast.warning) UIToast.warning('Direct send not configured', 'Add your EmailJS keys in testing.html to send without opening email.');
          finish(false);
          return doMailto();
        }

        try {
          const params = {
            to_email: SUPPORT_EMAIL,
            subject,
            message,
            from_email: fromEmail || 'moive776@gmail.com',
            reply_to: fromEmail || SUPPORT_EMAIL,
            category: t,
            site_url: location.href
          };
          window.emailjs.send(EMAILJS.serviceId, EMAILJS.templateId, params).then(() => {
            if (window.UIToast && UIToast.success) UIToast.success('Report sent', 'Thanks for your feedback!');
            finish(true);
          }).catch((err) => {
            if (window.UIToast && UIToast.error) UIToast.error('Direct send failed', (err && err.text) ? String(err.text) : 'Check EmailJS serviceId/templateId and template fields.');
            finish(false);
            doMailto();
          });
        } catch (err) {
          if (window.UIToast && UIToast.error) UIToast.error('Direct send failed', 'Unexpected error while sending.');
          finish(false);
          doMailto();
        }
      });
    }

    // Removed: showClearConfirmation and related Clear All UI

    // Create continue watching row (disabled: using unified loadContinueWatching path)
    function createContinueWatchingRow() {
      // Disabled to prevent duplicate sections; loadContinueWatching manages the single section (by id)
      // Keeping the function to avoid breaking callers; it now returns null so callers simply no-op.
      return null;
      try {
        const continueWatching = JSON.parse(localStorage.getItem('continueWatching') || '{}');
        console.log('Continue watching data:', continueWatching);

        const continueWatchingMovies = Object.entries(continueWatching)
          .map(([id, movie]) => {
            // Ensure all required fields have proper fallbacks
            const movieData = {
              ...movie,
              id: movie.movieId || id,
              movieId: movie.movieId || id,
              title: movie.title || 'Untitled Movie',
              poster: movie.poster || movie.thumbnail || movie.posterUrl || '',
              posterUrl: movie.posterUrl || movie.poster || movie.thumbnail || '',
              thumbnail: movie.thumbnail || movie.poster || movie.posterUrl || '',
              progress: parseFloat(movie.progress) || 0,
              currentTime: parseFloat(movie.currentTime) || 0,
              duration: parseFloat(movie.duration) || 0,
              timestamp: parseInt(movie.timestamp) || Date.now()
            };

            // Calculate progress if not set but we have currentTime and duration
            if ((!movieData.progress || movieData.progress === 0) && movieData.duration > 0) {
              movieData.progress = Math.min(95, (movieData.currentTime / movieData.duration) * 100);
            }

            return movieData;
          })
          .filter(movie => {
            // More lenient validation with better debugging
            const hasValidProgress = movie.progress > 0 && movie.progress <= 100;
            const hasValidTitle = movie.title &&
              movie.title !== 'Untitled Movie' &&
              movie.title !== 'Untitled' &&
              movie.title.trim() !== '';
            const hasValidId = movie.id || movie.movieId;

            // Debug logging
            if (!hasValidProgress) {
              console.log('Skipping movie - Invalid progress:', {
                title: movie.title || 'No title',
                progress: movie.progress,
                id: movie.id || movie.movieId || 'No ID',
                currentTime: movie.currentTime,
                duration: movie.duration
              });
            }
            if (!hasValidTitle) {
              console.log('Skipping movie - Invalid title:', {
                title: movie.title || 'No title',
                id: movie.id || movie.movieId || 'No ID'
              });
            }
            if (!hasValidId) {
              console.log('Skipping movie - Missing ID:', movie.title || 'No title');
            }

            return hasValidProgress && hasValidTitle && hasValidId;
          })
          .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // Sort by most recent

        if (continueWatchingMovies.length === 0) return null;

        const section = document.createElement('div');
        section.className = 'continue-watching-section';
        section.innerHTML = `
          <div class="section-header">
            <h2 class="section-title">
              <i class="fas fa-redo"></i> Continue Watching
            </h2>
            <!-- Clear All button removed -->
          </div>
          <div class="continue-watching-container"></div>
        `;

        const container = section.querySelector('.continue-watching-container');

        // Clear button handler attached later after items render (single attachment)

        continueWatchingMovies.forEach(movie => {
          const title = movie.title || 'Untitled';
          const posterPath = movie.poster || movie.thumbnail || movie.posterUrl || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MDAgNzUwIj4KICA8cmVjdCB3aWR0aD0iNTAwIiBoZWlnaHQ9Ijc1MCIgZmlsbD0iIzFhMWExYSIvPgogIDx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM4MDgwODAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPk5vIFBvc3RlcjwvdGV4dD4KPC9zdmc+';
          const progress = Math.round(movie.progress || 0);

          const card = document.createElement('div');
          card.className = 'continue-watching-card';
          card.innerHTML = `
            <div class="continue-watching-poster">
              <img src="${posterPath}" alt="${title}" loading="lazy" style="object-fit: cover !important; object-position: center center !important; transform: none !important;" />
              <div class="progress-bar">
                <div class="progress" style="width: ${progress}%"></div>
              </div>
              <div class="resume-overlay">
                <div class="resume-button">Resume</div>
              </div>
              <div class="remove-button" title="Remove from Continue Watching">Ã—</div>
            </div>
            <div class="continue-watching-info">
              <h3>${title}</h3>
              <p>${progress}% watched</p>
            </div>
          `;

          // Click to resume - Navigate to the correct player
          card.addEventListener('click', (e) => {
            if (!e.target.closest('.remove-button')) {
              const duration = movie.duration || 0;
              const resumeTime = (duration * progress) / 100;

              // Build the player URL with the movie's details
              const params = new URLSearchParams();
              params.append('id', movie.id);
              params.append('title', movie.title);
              if (movie.posterUrl) params.append('poster', movie.posterUrl);

              // Use the player that was used when watching this movie
              // Default to player1 if playerUsed field is missing
              const playerUsed = (movie.playerUsed || 'player1').toLowerCase();
              const usePlayer2 = playerUsed === 'player2' || playerUsed === 'player-2.nontongo.html' || playerUsed === 'player-2.html';
              const playerBase = usePlayer2 ? 'player-2.html' : 'player.html';
              console.log('ðŸŽ¬ Resuming', movie.title);
              console.log('ðŸ“Š Movie object:', JSON.stringify(movie, null, 2));
              console.log('ðŸ“¹ Player to use:', playerBase, '(playerUsed field:', playerUsed, ')');
              // Navigate to the correct player with the resume time
              window.location.href = `${playerBase}?${params.toString()}&t=${Math.floor(resumeTime)}`;
            }
          });

          // Enhanced remove from continue watching with animation
          const removeBtn = card.querySelector('.remove-button');
          removeBtn.addEventListener('click', async (e) => {
            e.stopPropagation();

            // Add visual feedback
            card.style.transform = 'scale(0.98)';
            card.style.opacity = '0.7';

            // Add a small delay for better UX
            await new Promise(resolve => setTimeout(resolve, 100));

            // Remove from localStorage
            const continueWatching = JSON.parse(localStorage.getItem('continueWatching') || '{}');
            if (continueWatching[movie.id]) {
              delete continueWatching[movie.id];
              localStorage.setItem('continueWatching', JSON.stringify(continueWatching));

              // Animate removal
              card.style.transform = 'translateX(100%)';
              card.style.opacity = '0';
              await new Promise(resolve => setTimeout(resolve, 200));

              card.remove();

              // Remove section if no more continue watching items
              const remainingItems = Object.keys(continueWatching).length;
              if (remainingItems === 0) {
                section.style.opacity = '0';
                section.style.height = '0';
                section.style.margin = '0';
                section.style.padding = '0';
                await new Promise(resolve => setTimeout(resolve, 300));
                section.remove();
              }
            }
          });

          container.appendChild(card);
        });

        return section;
      } catch (error) {
        console.error('Error creating continue watching row:', error);
        return null;
      }
    }

    // Load continue watching from localStorage (scoped per user/profile)
    function getContinueWatchingKey() {
      try {
        const user = (window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function')
          ? window.FirebaseAuth.getUser()
          : null;
        const uid = user && user.uid;
        if (!uid) return 'continueWatching_guest';
        const sel = localStorage.getItem(`fb_selected_profile_${uid}`);
        return sel ? `continueWatching_${uid}_${sel}` : `continueWatching_${uid}`;
      } catch (e) {
        return 'continueWatching_guest';
      }
    }

    // Get bookmark storage key (scoped per user/profile)
    function getBookmarksKey() {
      try {
        const user = (window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function')
          ? window.FirebaseAuth.getUser()
          : null;
        const uid = user && user.uid;
        if (!uid) return 'myList_guest';
        const sel = localStorage.getItem(`fb_selected_profile_${uid}`);
        return sel ? `myList_${uid}_${sel}` : `myList_${uid}`;
      } catch (e) {
        console.error('Error getting bookmarks key:', e);
        return 'myList_guest';
      }
    }

    // Add movie to bookmarks
    function addBookmark(movie) {
      try {
        const key = getBookmarksKey();
        console.log('Adding bookmark with key:', key, 'Movie:', movie.id, movie.title);
        const bookmarksStr = localStorage.getItem(key);
        const bookmarks = bookmarksStr ? JSON.parse(bookmarksStr) : {};

        bookmarks[movie.id] = {
          id: movie.id,
          title: movie.title,
          poster: movie.posterUrl || movie.poster || movie.thumbnail || '',
          rating: movie.rating,
          year: movie.year,
          genres: movie.genres,
          timestamp: Date.now()
        };

        localStorage.setItem(key, JSON.stringify(bookmarks));
        console.log('Bookmark added successfully. Total bookmarks:', Object.keys(bookmarks).length);
        console.log('Current bookmarks:', bookmarks);
        return true;
      } catch (e) {
        console.error('Error adding bookmark:', e);
        return false;
      }
    }

    // Remove movie from bookmarks
    function removeBookmark(movieId) {
      try {
        const key = getBookmarksKey();
        console.log('Removing bookmark with key:', key, 'Movie ID:', movieId);
        const bookmarksStr = localStorage.getItem(key);
        const bookmarks = bookmarksStr ? JSON.parse(bookmarksStr) : {};

        delete bookmarks[movieId];
        localStorage.setItem(key, JSON.stringify(bookmarks));
        console.log('Bookmark removed successfully. Remaining bookmarks:', Object.keys(bookmarks).length);
        return true;
      } catch (e) {
        console.error('Error removing bookmark:', e);
        return false;
      }
    }

    let featuredHeroRotationTimer = null;
    let featuredHeroRotationList = [];
    let featuredHeroRotationIndex = 0;

    function stopFeaturedHeroRotation() {
      if (featuredHeroRotationTimer) {
        clearTimeout(featuredHeroRotationTimer);
        featuredHeroRotationTimer = null;
      }
    }

    function shuffleFeaturedList(list) {
      const arr = Array.isArray(list) ? list.slice() : [];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      return arr;
    }

    function scheduleNextFeaturedHeroTick() {
      stopFeaturedHeroRotation();
      const delay = 3000 + Math.floor(Math.random() * 2001); // 3s - 5s
      featuredHeroRotationTimer = setTimeout(() => {
        if (!featuredHeroRotationList.length) return;

        if (featuredHeroRotationIndex >= featuredHeroRotationList.length) {
          featuredHeroRotationList = shuffleFeaturedList(featuredHeroRotationList);
          featuredHeroRotationIndex = 0;
        }

        const movie = featuredHeroRotationList[featuredHeroRotationIndex];
        featuredHeroRotationIndex += 1;
        if (movie) {
          populateFeaturedHero(movie);
        }
        scheduleNextFeaturedHeroTick();
      }, delay);
    }

    function startFeaturedHeroRotation(movies) {
      const candidates = Array.isArray(movies) ? movies.filter(Boolean).slice(0, 3) : [];
      stopFeaturedHeroRotation();
      featuredHeroRotationList = shuffleFeaturedList(candidates);
      featuredHeroRotationIndex = 0;

      if (!featuredHeroRotationList.length) return;
      populateFeaturedHero(featuredHeroRotationList[0]);
      featuredHeroRotationIndex = 1;
      if (featuredHeroRotationList.length > 1) {
        scheduleNextFeaturedHeroTick();
      }
    }

    // Populate the featured hero section on the main page
    function populateFeaturedHero(movie) {
      if (!movie) return;
      console.log('Populating featured hero:', movie.title);

      const featuredTitle = document.getElementById('featuredTitle');
      const featuredRating = document.getElementById('featuredRating');
      const featuredYear = document.getElementById('featuredYear');
      const featuredOverview = document.getElementById('featuredOverview');
      const featuredHeroBg = document.getElementById('featuredHeroBg');
      const featuredWatchBtn = document.getElementById('featuredWatchBtn');
      const featuredDetailsBtn = document.getElementById('featuredDetailsBtn');
      const featuredHero = document.getElementById('featuredHero');

      if (featuredHero) {
        // Only show on home page and when not searching
        const shouldShow = (!isSearching && currentCategory === 'all');
        featuredHero.style.display = shouldShow ? 'flex' : 'none';
      }

      if (featuredTitle) featuredTitle.textContent = movie.title || movie.name || 'Untitled';

      const rating = movie.rating || (typeof movie.vote_average === 'number' ? movie.vote_average.toFixed(1) : '-');
      if (featuredRating) featuredRating.textContent = rating;

      const year = movie.releaseDate ? movie.releaseDate.split('-')[0] : (movie.year || '');
      if (featuredYear) featuredYear.textContent = year;

      if (featuredOverview) featuredOverview.textContent = movie.overview || '';

      const backdrop = movie.backdrop || (movie.backdrop_path ? `https://image.tmdb.org/t/p/original${movie.backdrop_path}` : '');
      console.log('Featured hero backdrop URL:', backdrop);
      if (featuredHero && backdrop) {
        featuredHero.style.backgroundImage = `url("${backdrop}")`;
        console.log('Applied background to hero element');
      } else {
        console.warn('Could not apply background - featuredHero:', !!featuredHero, 'backdrop:', !!backdrop);
      }

      if (featuredWatchBtn) {
        featuredWatchBtn.onclick = (e) => {
          e.stopPropagation();
          // Open standard player
          const params = new URLSearchParams();
          params.append('id', movie.id);
          params.append('title', movie.title || movie.name);
          const pos = movie.poster || movie.posterUrl || (movie.poster_path ? `https://image.tmdb.org/t/p/original${movie.poster_path}` : '');
          if (pos) params.append('poster', pos);
          window.location.href = `player.html?${params.toString()}`;
        };
      }

      if (featuredDetailsBtn) {
        featuredDetailsBtn.onclick = (e) => {
          e.stopPropagation();
          if (typeof openMovieModal === 'function') {
            openMovieModal(movie);
          }
        };
      }
    }

    // Check if movie is bookmarked
    function isBookmarked(movieId) {
      try {
        const key = getBookmarksKey();
        const bookmarksStr = localStorage.getItem(key);
        const bookmarks = bookmarksStr ? JSON.parse(bookmarksStr) : {};
        const result = !!bookmarks[movieId];
        console.log('Checking bookmark for movie:', movieId, 'Key:', key, 'Result:', result, 'All bookmarks:', bookmarks);
        return result;
      } catch (e) {
        console.error('Error checking bookmark:', e);
        return false;
      }
    }

    // Simple direct loader for continue watching from localStorage only
    async function loadContinueWatchingDirect() {
      console.log('DIRECT LOADER disabled; using Firebase-backed loadContinueWatching instead');
      return loadContinueWatching(true);
      console.log('DIRECT LOADER START');
      try {
        const localData = JSON.parse(localStorage.getItem('continueWatching_local') || '{}');
        console.log('Direct loader - localData:', localData);
        const movies = Object.values(localData).filter(m => m.currentTime >= 30);
        console.log('Direct loader - filtered movies:', movies);
        if (movies.length > 0) {
          console.log('Found', movies.length, 'movies to display');
          // Force render the section
          if (window.ContinueWatchingDisplay) {
            // Remove any existing section first
            const existingSection = document.querySelector('.continue-watching-section');
            if (existingSection) {
              console.log('Removing existing section');
              existingSection.remove();
            }
            
            // Create the section
            const newSection = window.ContinueWatchingDisplay.createContinueWatchingSection();
            console.log('Created new section:', newSection);
            
            if (newSection) {
              // Add a flag to prevent hiding
              newSection.dataset.persistent = 'true';
              
              // Try to insert BEFORE the movies container (not inside it)
              const moviesContainer = document.getElementById('moviesContainer');
              const parent = moviesContainer?.parentNode;
              
              // Find the featured hero section to insert after it
              const featuredHero = document.getElementById('featuredHero');
              
              if (featuredHero && featuredHero.nextSibling) {
                // Insert after featured hero
                parent.insertBefore(newSection, featuredHero.nextSibling);
                console.log('Continue Watching section inserted after featuredHero');
              } else if (parent && moviesContainer) {
                parent.insertBefore(newSection, moviesContainer);
                console.log('Continue Watching section inserted before moviesContainer');
              } else if (moviesContainer) {
                moviesContainer.insertBefore(newSection, moviesContainer.firstChild);
                console.log('Continue Watching section inserted at top of moviesContainer');
              } else {
                // Fallback: add to body or main
                const main = document.querySelector('main') || document.body;
                main.insertBefore(newSection, main.firstChild);
                console.log('Continue Watching section added to main/body');
              }
              
              // Force it to be visible
              newSection.style.display = 'block';
              newSection.style.visibility = 'visible';
              newSection.style.opacity = '1';
              // Defense: Set up interval to keep section visible and re-create if removed
              let defenseCount = 0;
              const keepVisibleInterval = setInterval(() => {
                defenseCount++;
                let section = document.querySelector('.continue-watching-section');
                
                if (!section) {
                  // Section was removed - recreate it
                  console.log('Continue Watching section was removed, recreating...');
                  if (window.ContinueWatchingDisplay) {
                    const newSection2 = window.ContinueWatchingDisplay.createContinueWatchingSection();
                    if (newSection2) {
                      newSection2.dataset.persistent = 'true';
                      newSection2.style.display = 'block';
                      newSection2.style.visibility = 'visible';
                      newSection2.style.opacity = '1';
                      
                  // Insert at the proper position (after featured hero)
                      const main = document.querySelector('main') || document.body;
                      const featuredHero = document.getElementById('featuredHero');
                      if (featuredHero && featuredHero.nextSibling) {
                        main.insertBefore(newSection2, featuredHero.nextSibling);
                      } else {
                        main.insertBefore(newSection2, main.firstChild);
                      }
                      console.log('Continue Watching section recreated at proper position');
                    }
                  }
                } else {
                  // Force section to be visible
                  if (section.style.display === 'none' || section.style.visibility === 'hidden' || section.offsetParent === null) {
                    console.log('Re-showing hidden Continue Watching section');
                    section.style.display = 'block';
                    section.style.visibility = 'visible';
                    section.style.opacity = '1';
                  }
                  
                  // Ensure it's at the proper position (after featured hero)
                  const main = document.querySelector('main') || document.body;
                  const featuredHero = document.getElementById('featuredHero');
                  if (featuredHero && featuredHero.nextSibling && section !== featuredHero.nextSibling) {
                    main.insertBefore(section, featuredHero.nextSibling);
                  }
                }
                
                // Stop checking after 120 seconds (240 checks at 500ms)
                if (defenseCount > 240) {
                  clearInterval(keepVisibleInterval);
                }
              }, 500);
                            // Also use MutationObserver to prevent removal
              const observer = new MutationObserver((mutations) => {
                const section = document.querySelector('.continue-watching-section');
                const featuredHero = document.getElementById('featuredHero');
                if (!section) {
                  console.log('MutationObserver: Section missing, recreating...');
                  if (window.ContinueWatchingDisplay) {
                    const newSection3 = window.ContinueWatchingDisplay.createContinueWatchingSection();
                    if (newSection3) {
                      newSection3.dataset.persistent = 'true';
                      newSection3.style.display = 'block';
                      newSection3.style.visibility = 'visible';
                      newSection3.style.opacity = '1';
                      const main = document.querySelector('main') || document.body;
                      if (featuredHero && featuredHero.nextSibling) {
                        main.insertBefore(newSection3, featuredHero.nextSibling);
                      } else {
                        main.insertBefore(newSection3, main.firstChild);
                      }
                    }
                  }
                }
              });
              
              // Observe the main container for changes
              const mainContainer = document.querySelector('main') || document.body;
              observer.observe(mainContainer, { childList: true, subtree: true });
              
              // Stop observer after 2 minutes
              setTimeout(() => {
                observer.disconnect();
                console.log('MutationObserver disconnected');
              }, 120000);
            }
          } else {
            console.log('ContinueWatchingDisplay not available');
          }
        } else {
          console.log('No movies with sufficient watch time');
        }
      } catch (e) {
        console.error('Direct loader error:', e);
      }
    }

    // Load continue watching from Firebase AND localStorage (merged)
    async function loadContinueWatching(forceShow = false) {
      console.log('LOAD_CONTINUE_WATCHING_START');
      console.log('=== loadContinueWatching: START ===', { forceShow, isSearching });
      
      // Wait for auth/profile to be ready to avoid flicker with wrong storage key
      // Skip this check if Firebase isn't available (local testing mode)
      try {
        if (window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function') {
          if (!window.FirebaseAuth.getUser()) {
            console.log('loadContinueWatching: No Firebase user, retrying...');
            setTimeout(() => loadContinueWatching(forceShow), 250);
            return;
          }
        } else {
          // Firebase not available, proceed with localStorage only
          console.log('Firebase not available, proceeding with localStorage only');
        }
      } catch (e) { 
        console.log('Firebase auth check error:', e);
      }
      // Don't show continue watching if we're in search mode and not forcing a show
      if (isSearching && !forceShow) {
        console.log('loadContinueWatching: In search mode, hiding section');
        const section = document.getElementById('continueWatchingSection');
        if (section) section.style.display = 'none';
        return;
      }

      console.log('=== DEBUG: loadContinueWatching() called ===');
      try {
        // 1. Get Cloud Data
        let cloudData = {};

        // ALWAYS use async method to ensure we get latest data from Firebase
        if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.getAllProgressAsync === 'function') {
          console.log('Loading continue watching from ContinueWatchingManager (async)...');
          cloudData = await window.ContinueWatchingManager.getAllProgressAsync();
        } else if (window.FirebaseSync && window.FirebaseSync.initialized) {
          console.log('Loading continue watching from FirebaseSync...');
          cloudData = await window.FirebaseSync.getContinueWatching();
        } else {
          console.warn('No Firebase source available, trying ContinueWatchingManager sync...');
          if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.getAllProgress === 'function') {
            cloudData = window.ContinueWatchingManager.getAllProgress();
          }
        }

        // 2. Get Local Data (from Player 2 or offline)
        let localData = {};
        try {
          const user = window.FirebaseAuth.getUser();
          const uid = user ? user.uid : null;
          const profileId = uid ? localStorage.getItem(`fb_selected_profile_${uid}`) : null;

          // Check all possible keys
          const keys = ['continueWatching', 'continueWatching_guest', 'continueWatching_local'];
          if (uid) keys.push(`continueWatching_${uid}`);
          if (uid && profileId) keys.push(`continueWatching_${uid}_${profileId}`);

          keys.forEach(key => {
            try {
              const data = JSON.parse(localStorage.getItem(key) || '{}');
              Object.assign(localData, data);
            } catch (e) { }
          });
          console.log('Loaded local continue watching data:', Object.keys(localData).length, 'items');
        } catch (e) { console.warn('Error reading local continue watching:', e); }

        // 3. Merge Data (Cloud wins on conflict, unless Local is newer)
        let continueWatching = { ...cloudData };

        Object.entries(localData).forEach(([id, localMovie]) => {
          const cloudMovie = continueWatching[id];
          if (!cloudMovie) {
            continueWatching[id] = localMovie;
          } else {
            // Compare timestamps
            const localTime = Number(localMovie.updatedAt || localMovie.timestamp || 0);
            const cloudTime = Number(cloudMovie.updatedAt || cloudMovie.timestamp || 0);
            if (localTime > cloudTime) {
              continueWatching[id] = localMovie;
              console.log('Using newer local data for:', localMovie.title);
            }
          }
        });

        console.log('Merged continue watching data:', Object.keys(continueWatching).length, 'items');

        // Log each item for debugging
        Object.entries(continueWatching).forEach(([id, movie]) => {
          console.log('  -', movie.title || 'Untitled', '|', movie.progress || 0, '% | ID:', id);
        });

        // Get movies that have progress
        const continueWatchingMovies = Object.entries(continueWatching).map(([id, movie]) => {
          const mapped = {
            ...movie,
            id: movie.movieId || movie.id || id, // Use movieId first, then id, then key
            movieId: movie.movieId || movie.id || id,
            title: movie.title || 'Untitled',
            progress: parseFloat(movie.progress) || 0,
            currentTime: parseFloat(movie.currentTime) || 0,
            duration: parseFloat(movie.duration) || 0,
            timestamp: parseInt(movie.updatedAt || movie.timestamp) || 0,
            updatedAt: parseInt(movie.updatedAt || movie.timestamp) || 0,
            poster: movie.poster || movie.posterUrl || movie.thumbnail || '',
            posterUrl: movie.posterUrl || movie.poster || movie.thumbnail || ''
          };
          console.log('Mapped movie:', mapped.title, 'Progress:', mapped.progress, 'ID:', mapped.id);
          return mapped;
        });

        // Deduplicate by strong key (movieId/id) first, then fallback to normalized title
        const dedupMap = new Map();
        for (const m of continueWatchingMovies) {
          const keyId = String(m.movieId || m.id || '').trim();
          const keyTitle = String(m.title || '').toLowerCase().trim();
          const key = keyId || `title:${keyTitle}`;

          const existing = dedupMap.get(key);
          if (!existing) {
            dedupMap.set(key, m);
            continue;
          }

          const tsNew = Number(m.updatedAt || m.timestamp || 0);
          const tsOld = Number(existing.updatedAt || existing.timestamp || 0);
          const progNew = Number(m.progress || 0);
          const progOld = Number(existing.progress || 0);

          // Pick newer; if tie, pick higher progress
          if (tsNew > tsOld || (tsNew === tsOld && progNew > progOld)) {
            dedupMap.set(key, m);
          }
        }

        const dedupedMovies = Array.from(dedupMap.values());

        let validMovies = dedupedMovies.filter(movie => {
          const hasProgress = movie.progress > 0 && movie.progress < 95;
          const hasValidId = movie.id || movie.movieId;
          const hasTitle = movie.title && movie.title !== 'Untitled' && movie.title !== 'Unknown Movie';
          const isValid = hasProgress && hasValidId && hasTitle;

          if (!isValid) {
            console.log('Filtered out movie:', movie.title, {
              hasProgress,
              hasValidId,
              hasTitle,
              progress: movie.progress,
              id: movie.id,
              movieId: movie.movieId,
              title: movie.title
            });
          }

          return isValid;
        });

        console.log('Valid movies after filter:', validMovies.length, validMovies.map(m => m.title));

        // Final dedupe pass by movieId/title to avoid edge duplicates after validation
        if (validMovies.length > 1) {
          const byKey = new Map();
          for (const m of validMovies) {
            const keyId = String(m.movieId || m.id || '').trim();
            const keyTitle = String(m.title || '').toLowerCase().trim();
            const key = keyId || `title:${keyTitle}`;
            const existing = byKey.get(key);
            const ts = Number(m.updatedAt || m.timestamp || 0);
            const existingTs = Number(existing?.updatedAt || existing?.timestamp || 0);
            if (!existing || ts > existingTs || (ts === existingTs && (m.progress || 0) > (existing?.progress || 0))) {
              byKey.set(key, m);
            }
          }
          validMovies = Array.from(byKey.values());
        }

        if (validMovies.length === 0) {
          console.log('No valid continue watching items to display');
          const section = document.getElementById('continueWatchingSection');
          if (section) section.style.display = 'none';
          return;
        }

        // Sort by most recently watched (fall back to updatedAt)
        validMovies.sort((a, b) => (Number(b.updatedAt || b.timestamp || 0)) - (Number(a.updatedAt || a.timestamp || 0)));

        // Don't create the section if we're in search mode
        if (isSearching && !forceShow) {
          return;
        }

        // Get or create the continue watching section
        let section = document.getElementById('continueWatchingSection');
        if (!section) {
          section = document.createElement('section');
          section.id = 'continueWatchingSection';
          section.className = 'continue-watching-section';
          section.innerHTML = `
            <div class="section-header">
              <h2 class="section-title">
                <i class="fas fa-redo"></i> Continue Watching
              </h2>
              <!-- Clear All button removed -->
            </div>
            <div class="continue-watching-container" id="continueWatchingContainer"></div>
          `;

          // Insert at the beginning of the movies container
          const moviesContainer = document.getElementById('moviesContainer');
          if (moviesContainer) {
            moviesContainer.insertBefore(section, moviesContainer.firstChild);
          }
        }

        // Clear existing content
        const container = section.querySelector('#continueWatchingContainer');
        if (container) {
          container.innerHTML = '';

          // Add each movie to the container
          validMovies.forEach(movie => {
            const title = movie.title || 'Untitled';
            const posterPath = movie.poster || movie.thumbnail || movie.posterUrl || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MDAgNzUwIj4KICA8cmVjdCB3aWR0aD0iNTAwIiBoZWlnaHQ9Ijc1MCIgZmlsbD0iIzFhMWExYSIvPgogIDx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM4MDgwODAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPk5vIFBvc3RlcjwvdGV4dD4KPC9zdmc+';
            const progress = Math.round(movie.progress || 0);

            const card = document.createElement('div');
            card.className = 'continue-watching-card';
            card.innerHTML = `
              <div class="continue-watching-poster">
                <img src="${posterPath}" alt="${title}" loading="lazy" style="object-fit: cover !important; object-position: center center !important; transform: none !important;" />
                <div class="progress-bar">
                  <div class="progress" style="width: ${progress}%"></div>
                </div>
                <div class="resume-overlay">
                  <div class="resume-button">Resume</div>
                </div>
                <div class="remove-button" title="Remove from Continue Watching">Ã—</div>
              </div>
              <div class="continue-watching-info">
                <h3>${title}</h3>
                <p>${progress}% watched</p>
              </div>
            `;

            // Click to resume
            card.addEventListener('click', (e) => {
              if (!e.target.closest('.remove-button')) {
                const durationSeconds = Number(movie.duration) || 0;
                const progressSeconds = durationSeconds && movie.progress ? (durationSeconds * movie.progress) / 100 : 0;

                // Freshly fetch progress from manager for most accurate resume time
                let managerSeconds = 0;
                try {
                  const mgr = window.ContinueWatchingManager;
                  const mgrProgress = mgr && typeof mgr.getMovieProgress === 'function' ? mgr.getMovieProgress(movie.id || movie.movieId) : null;
                  managerSeconds = mgrProgress && Number(mgrProgress.currentTime) ? Number(mgrProgress.currentTime) : 0;
                } catch (_) { }

                const resumeSeconds = Math.floor(
                  managerSeconds || movie.currentTime || progressSeconds || 0
                );

                const idParam = movie.id ? `&id=${encodeURIComponent(movie.id)}` : '';
                const movieIdParam = movie.id ? `&movieId=${encodeURIComponent(movie.id)}` : '';
                const base = `player.html?title=${encodeURIComponent(movie.title)}&poster=${encodeURIComponent(movie.posterUrl || movie.poster || '')}&trailer=${encodeURIComponent(movie.trailerUrl || '')}${idParam}${movieIdParam}`;

                // Only add t if we have a positive timestamp; otherwise let player prompt using cloud progress
                const url = resumeSeconds > 0 ? `${base}&t=${resumeSeconds}` : base;
                window.location.href = url;
              }
            });

            // Remove button
            const removeButton = card.querySelector('.remove-button');
            if (removeButton) {
              removeButton.addEventListener('click', async (e) => {
                e.stopPropagation();

                const movieId = movie.id || movie.movieId;
                if (movieId) {
                  // 1. Remove from Cloud
                  if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.removeMovieProgress === 'function') {
                    await window.ContinueWatchingManager.removeMovieProgress(movieId);
                  } else if (window.FirebaseSync && window.FirebaseSync.initialized) {
                    await window.FirebaseSync.removeContinueWatchingItem(movieId);
                  }

                  // 2. Remove from Local Storage
                  try {
                    const user = window.FirebaseAuth.getUser();
                    const uid = user ? user.uid : null;
                    const profileId = uid ? localStorage.getItem(`fb_selected_profile_${uid}`) : null;

                    const keys = ['continueWatching'];
                    if (uid) keys.push(`continueWatching_${uid}`);
                    if (uid && profileId) keys.push(`continueWatching_${uid}_${profileId}`);

                    keys.forEach(key => {
                      try {
                        const data = JSON.parse(localStorage.getItem(key) || '{}');
                        if (data[movieId]) {
                          delete data[movieId];
                          localStorage.setItem(key, JSON.stringify(data));
                        }
                      } catch (e) { }
                    });
                  } catch (e) { }

                  // Remove the card with animation
                  card.style.opacity = '0';
                  card.style.transition = 'opacity 0.2s ease';
                  setTimeout(() => {
                    card.remove();

                    // Update trash icon after removal
                    updateTrashIcon();

                    // If no more items, hide the section
                    if (container.children.length === 0) {
                      section.style.display = 'none';
                    }
                  }, 200);
                }
              });
            }

            container.appendChild(card);
          });

          // Update trash icon based on items
          const updateTrashIcon = () => {
            const clearButton = section.querySelector('#clearAllBtn');
            if (!clearButton) return;

            const items = container.querySelectorAll('.continue-watching-card');
            const icon = clearButton.querySelector('i');

            if (items.length > 0) {
              // Filled trash can when there are items
              icon.className = 'fas fa-trash-alt';
              clearButton.style.opacity = '1';
              clearButton.style.pointerEvents = 'auto';
              clearButton.style.cursor = 'pointer';
              clearButton.classList.add('has-items');
              clearButton.classList.remove('is-empty');
            } else {
              // Empty trash can when no items
              icon.className = 'far fa-trash-alt';
              clearButton.style.opacity = '0.6';
              clearButton.style.pointerEvents = 'none';
              clearButton.style.cursor = 'default';
              clearButton.classList.add('is-empty');
              clearButton.classList.remove('has-items');
            }
          };

          // Initial icon update
          updateTrashIcon();

          // Clear All button removed

          // Show the section only if not in search mode
          section.style.display = isSearching ? 'none' : 'block';

          // Listen for continue watching updates from other sources (Firebase sync, etc.)
          const handleContinueWatchingUpdate = () => {
            loadContinueWatching(false);
          };
          window.addEventListener('continueWatchingUpdated', handleContinueWatchingUpdate);
        }

      } catch (error) {
        console.error('Error in loadContinueWatching:', error);
        const section = document.getElementById('continueWatchingSection');
        if (section) section.style.display = 'none';
      }
    }

    // runtime mappings

    // Movies Google Drive Mappings
    const localTrailers = {};
    const driveMovieMappings = {
      "1": "",  // Manjummel Boys (2024)
      "2": "",  // Tourist Family (2025)
      "3": "",  // Kaithi (2019)
      "4": "",  // Vikram (2022)
      "5": "",  // Leo (2023)
      "6": "",  // Coolie (2025)
      "7": "",  // Maharaja (2024)
      "8": "",  // Hi Papa (2023)
      "9": "",  // Kantara (2022)
      "10": "",  // Hridayam (2022)
      "11": "",  // Lokah Chapter 1 (2025)
      "12": "",  // Lucky Bhaskar (2024)
      "13": "",  // Court - State Vs. A Nobody (2025)
      "14": "",  // Master (2021)
      "15": "",  // HIT: The First Case (2020)
      "16": "",  // HIT: The Second Case (2022)
      "17": "",  // HIT: The Third Case (2025)
      "18": "",  // Retro (2025)
      "19": "",  // Kuberaa (2025)
      "20": "",  // Thalaivan Thalaivii (2025)
    };

    // Direct MP4 overrides by normalized title (DISABLED - custom MP4 overrides)
    const mp4Overrides = {};

    // Normalize titles and resolve MP4 override by title robustly
    function normalizeTitleForKey(t) {
      return String(t || '')
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ');
    }

    function getMp4Override(title) {
      const base = normalizeTitleForKey(title);
      if (mp4Overrides[base]) return mp4Overrides[base];
      // try without common suffixes
      const simplified = base
        .replace(/\bchapter\s*\d+\b/g, '')
        .replace(/\bpart\s*\d+\b/g, '')
        .replace(/\bthe\s+/g, '')
        .replace(/\s+/g, ' ')
        .trim();
      return mp4Overrides[simplified] || null;
    }

    // Flag to toggle TMDB-driven catalog rendering
    let useTMDBCatalog = false;

    // Store scroll position before opening modal
    let savedScrollPosition = 0;

    // Elements
    const moviesContainer = document.getElementById('moviesContainer');
    const modal = document.getElementById('movieModal');
    const closeModalBtn = document.getElementById('closeModal');
    const searchComponentEl = document.getElementById('searchComponent');
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const streamBtn = document.getElementById('streamBtn');




    function extractYouTubeId(url) {
      if (!url) return null;
      // Handle standard YouTube URLs
      let m = String(url).match(/(?:v=|be\/)([0-9A-Za-z_-]{6,})/);
      if (m) return m[1];
      // Handle embedded URLs
      m = String(url).match(/embed\/([0-9A-Za-z_-]{6,})/);
      return m ? m[1] : null;
    }

    // Apply per-movie trailerUrl into localTrailers map for playback
    function applyPerMovieUrls() {
      curatedMovies.forEach(m => {
        if (m.trailerUrl) {
          const key = extractYouTubeId(m.trailerUrl);
          if (key) localTrailers[m.id] = key;
        }
      });

      // Update continue watching section when new data is loaded
      const continueWatchingSection = createContinueWatchingRow();
      if (continueWatchingSection) {
        const existingSection = document.querySelector('.continue-watching-section');
        if (existingSection) {
          existingSection.replaceWith(continueWatchingSection);
        } else if (moviesContainer.firstChild) {
          moviesContainer.insertBefore(continueWatchingSection, moviesContainer.firstChild);
        } else {
          moviesContainer.appendChild(continueWatchingSection);
        }
      }
    }

    // Update trailer host markup based on available poster/trailer sources
    function setTrailerHostContent(movie, trailerHost, placeholderImg) {
      if (!movie || !trailerHost || !placeholderImg) return;

      const posterSafe = movie.posterUrl && !movie.posterUrl.includes('archive.org') ? movie.posterUrl : null;
      const key = movie.trailerUrl ? extractYouTubeId(movie.trailerUrl) : localTrailers[movie.id];
      const placeholder = posterSafe || (key ? `https://i.ytimg.com/vi/${key}/hqdefault.jpg` : ('data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%221280%22 height=%22720%22%3E%3Crect fill=%22%23333%22 width=%221280%22 height=%22720%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 font-size=%2250%22 fill=%22%23999%22 text-anchor=%22middle%22 dominant-baseline=%22middle%22%3EPlay Trailer%3C/text%3E%3C/svg%3E'));

      placeholderImg.src = placeholder;

      const isMP4 = movie.trailerUrl && (movie.trailerUrl.endsWith('.mp4') || movie.trailerUrl.includes('.mp4'));
      if (isMP4) {
        trailerHost.dataset.mp4Url = movie.trailerUrl;
        trailerHost.dataset.youtubeKey = '';
        trailerHost.innerHTML = `
          <img id="trailerPlaceholderImg" src="${placeholder}" alt="Trailer preview" style="max-width:100%;height:auto;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%221280%22 height=%22720%22%3E%3Crect fill=%22%23333%22 width=%221280%22 height=%22720%22/%3E%3C/svg%3E'" />
          <div class="video-play-btn" title="Play trailer"></div>
        `;
      } else {
        trailerHost.dataset.youtubeKey = key || '';
        trailerHost.dataset.mp4Url = '';
        trailerHost.innerHTML = `<img id="trailerPlaceholderImg" src="${placeholder}" alt="Trailer preview" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%221280%22 height=%22720%22%3E%3Crect fill=%22%23333%22 width=%221280%22 height=%22720%22/%3E%3C/svg%3E'" /><div class="video-play-btn" title="Play trailer"></div>`;
      }
    }

    // Lazy-fetch TMDB trailers for movies without trailerUrl
    async function ensureMovieTrailer(movie) {
      if (!movie || movie.trailerUrl) return movie.trailerUrl;
      if (!movieDb) return null;

      try {
        let videos = [];
        if (movie.mediaType === 'tv' && typeof movieDb.getTVVideos === 'function') {
          videos = await movieDb.getTVVideos(movie.id);
        } else if (typeof movieDb.getMovieVideos === 'function') {
          videos = await movieDb.getMovieVideos(movie.id);
        } else {
          videos = [];
        }
        const best = videos.find(v => v.site === 'YouTube' && v.type === 'Trailer' && v.official) ||
          videos.find(v => v.site === 'YouTube' && (v.type === 'Trailer' || v.type === 'Teaser')) ||
          videos.find(v => v.site === 'YouTube');

        if (best && best.key) {
          movie.trailerUrl = `https://www.youtube.com/watch?v=${best.key}`;
          localTrailers[movie.id] = best.key;
          return movie.trailerUrl;
        }
      } catch (error) {
        console.warn('Unable to fetch TMDB trailer', movie.id, error);
      }

      // Fallback to YouTube search if API key is provided
      if (YT_API_KEY) {
        try {
          const ytKey = await fetchYouTubeTrailer(movie.title, movie.year || movie.release_date);
          if (ytKey) {
            movie.trailerUrl = `https://www.youtube.com/watch?v=${ytKey}`;
            localTrailers[movie.id] = ytKey;
            return movie.trailerUrl;
          }
        } catch (error) {
          console.warn('YouTube trailer lookup failed', movie.title, error);
        }
      }

      return null;
    }

    // YouTube Data API fallback search
    async function fetchYouTubeTrailer(title, year) {
      if (!YT_API_KEY || !title) return null;
      const query = `${title} official trailer ${year || ''}`.trim();
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=5&q=${encodeURIComponent(query)}&key=${YT_API_KEY}`;
      const resp = await fetch(url);
      if (!resp.ok) {
        console.warn('YouTube API error', resp.status);
        return null;
      }
      const data = await resp.json();
      const items = data.items || [];
      const pick = items.find(i => (i.snippet?.title || '').toLowerCase().includes('trailer')) || items[0];
      return pick && pick.id && pick.id.videoId ? pick.id.videoId : null;
    }


    // Display Movies
    let currentCategory = 'all'; // category filter state

    // Category mapping by movie id
    const categoryMap = {
      bollywood: [22, 23, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], // Court - State Vs. A Nobody, HIT: The First Case (Hindi)
      tollywood: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26], // South Indian set (Tamil/Telugu/etc.)
    };

    /**
     * Filter TMDB movies by category based on original language
     * Bollywood: Hindi language (hi)
     * Tollywood: South Indian languages (Tamil, Telugu, Kannada, Malayalam)
     */
    function filterTMDBByCategory(movies, category) {
      if (!movies || !Array.isArray(movies)) return [];

      if (category === 'bollywood') {
        // Filter for Hindi language movies
        return movies.filter(movie => movie.original_language === 'hi');
      } else if (category === 'tollywood') {
        // Filter for South Indian languages: Tamil, Telugu, Kannada, Malayalam
        const southIndianLanguages = ['ta', 'te', 'kn', 'ml'];
        return movies.filter(movie => southIndianLanguages.includes(movie.original_language));
      }

      return movies;
    }

    /**
     * Filter content for anime (TV shows with Animation genre, Japanese language/origin)
     */
    function filterAnimeContent(content) {
      if (!content || !Array.isArray(content)) return [];

      return content.filter(item => {
        // Must have Animation genre (this is the key requirement for anime)
        const hasAnimationGenre = item.genres && item.genres.some(genre =>
          genre && genre.toLowerCase().includes('animation')
        );

        // Include only if it has the Animation genre
        return hasAnimationGenre;
      });
    }

    // Update URL state for category and search
    function updateURLState({ category, search }) {
      const url = new URL(window.location);

      if (category !== null) {
        if (category === 'all') {
          url.searchParams.delete('category');
        } else {
          url.searchParams.set('category', category);
        }
      }

      if (search !== null) {
        if (!search) {
          url.searchParams.delete('search');
        } else {
          url.searchParams.set('search', search);
        }
      }

      // Use history.replaceState to update URL without triggering page reload
      window.history.replaceState(null, '', url.toString());
    }

    // Prevent race conditions when switching categories quickly
    let isCategoryLoading = false;
    let currentCategoryLoadId = 0;
    const GENRE_FILTER_OPTIONS = [
      'Action',
      'Adventure',
      'Animation',
      'Comedy',
      'Crime',
      'Documentary',
      'Drama',
      'Family',
      'Fantasy',
      'History',
      'Horror',
      'Music',
      'Mystery',
      'Romance',
      'Science Fiction',
      'TV Movie',
      'Thriller',
      'War',
      'Western'
    ];
    const TMDB_GENRE_ID_TO_NAME = {
      12: 'Adventure',
      14: 'Fantasy',
      16: 'Animation',
      18: 'Drama',
      27: 'Horror',
      28: 'Action',
      35: 'Comedy',
      36: 'History',
      37: 'Western',
      53: 'Thriller',
      80: 'Crime',
      99: 'Documentary',
      10402: 'Music',
      10749: 'Romance',
      10751: 'Family',
      10752: 'War',
      10759: 'Action & Adventure',
      10762: 'Kids',
      10763: 'News',
      10764: 'Reality',
      10765: 'Sci-Fi & Fantasy',
      10766: 'Soap',
      10767: 'Talk',
      10768: 'War & Politics',
      878: 'Science Fiction'
    };
    const selectedGenreFilters = new Set();
    let categoryBarListenerAttached = false;
    let categoryBarChangeListenerAttached = false;
    let filterOutsideClickAttached = false;
    let reopenFilterPanelAfterMount = false;
    let keepGenreFilterPanelOpen = false;
    // If true, suppress auto-scrolling during initial page load
    window.initialPageLoad = true;

    // Prevent any scripts from forcing a scrollIntoView on the hero/section-title during initial load
    (function() {
      const orig = Element.prototype.scrollIntoView;
      Element.prototype.scrollIntoView = function(...args) {
        try {
          // If it's the main section title and we're in initial load, silently ignore the call
          if (window.initialPageLoad && this && this.matches && this.matches('.section-title')) {
            return;
          }
        } catch (e) { /* ignore */ }
        return orig.apply(this, args);
      };
    })();
    if ('scrollRestoration' in history) { history.scrollRestoration = 'manual'; }

    // Load scroll debug helper (added)
    (function(){
      try { var s = document.createElement('script'); s.src = 'js/scroll-debug.js'; document.head.appendChild(s); } catch(e) {}
    })();

    function applyCategory(cat) {
      // Prevent multiple simultaneous category loads
      if (isCategoryLoading) {
        console.log('Category change already in progress, ignoring:', cat);
        return;
      }

      const loadId = ++currentCategoryLoadId;
      isCategoryLoading = true;

      currentCategory = cat;

      // Reset search state
      isSearching = false;
      document.body.classList.remove('searching');

      // Update URL with category parameter
      updateURLState({ category: cat, search: null });

      // Hide/show sections based on category
      const isHome = (cat === 'all');
      const popularSection = document.getElementById('popularMoviesSection');
      const popularTVSection = document.getElementById('popularTVSection');
      const featuredHero = document.getElementById('featuredHero');

      if (popularSection) popularSection.style.display = isHome ? '' : 'none';
      if (popularTVSection) popularTVSection.style.display = isHome ? '' : 'none';
      if (featuredHero) featuredHero.style.display = isHome ? 'flex' : 'none';
      if (!isHome) {
        stopFeaturedHeroRotation();
      } else if (featuredHeroRotationList.length > 1 && !featuredHeroRotationTimer) {
        scheduleNextFeaturedHeroTick();
      }

      // TMDB-driven catalog handling
      if (useTMDBCatalog) {
        // Show/hide continue watching section only when cards exist.
        const cwSection = document.getElementById('continueWatchingSection');
        if (cwSection) {
          const hasCards = !!cwSection.querySelector('.continue-watching-card');
          cwSection.style.display = (isSearching || !hasCards) ? 'none' : '';
        }

        // Update category bar active state
        mountCategoryBar();

        // Series â†’ switch to TV mode
        if (cat === 'series' && typeof setTMDBMode === 'function' && typeof loadAllTMDBTV === 'function') {
          setTMDBMode('tv');
          loadAllTMDBTV().then(shows => {
            // Check if this is still the current load
            if (loadId !== currentCategoryLoadId) return;
            displayMovies(shows, false, 'Series');
            // Scroll to movies section (skip during initial page load)
            if (!window.initialPageLoad) {
              setTimeout(() => {
                const title = document.querySelector('.section-title');
                if (!window.initialPageLoad && title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }, 100);
            }
            isCategoryLoading = false;
            // Re-enable category buttons
            mountCategoryBar();
          }).catch(error => {
            console.error('Error loading series:', error);
            isCategoryLoading = false;
            // Re-enable category buttons
            mountCategoryBar();
          });
          return;
        }

        // Anime â†’ load both movies and TV shows, then filter for anime content
        if (cat === 'anime') {
          // If TMDB is not loaded yet, load it first
          if (!useTMDBCatalog && typeof loadAllTMDBMovies === 'function') {
            console.log('Loading TMDB catalog for anime...');
            loadAllTMDBMovies(10).then(() => {
              console.log('TMDB movies loaded, now loading anime...');
              applyCategory('anime'); // Re-apply anime category now that TMDB is loaded
            }).catch(error => {
              console.error('Failed to load TMDB for anime:', error);
              // Fall back to local catalog
              const animeContent = filterAnimeContent(curatedMovies);
              if (animeContent.length === 0) {
                moviesContainer.innerHTML = '';
                const noResults = document.createElement('div');
                noResults.style.textAlign = 'center';
                noResults.style.padding = '2rem';
                noResults.innerHTML = `
                  <h2 class="section-title">Anime</h2>
                  <p>No anime content available at this time.</p>
                `;
                moviesContainer.appendChild(noResults);
              } else {
                displayMovies(animeContent, false, 'Anime');
              }
              isCategoryLoading = false;
              mountCategoryBar();
            });
            return;
          }

          setTMDBMode('movie'); // Use movie mode for anime movies

          // Load only movies, then filter for anime content
          if (typeof loadAllTMDBMovies === 'function') {
            loadAllTMDBMovies(10).then(movies => {
              // Check if this is still the current load
              if (loadId !== currentCategoryLoadId) return;

              const animeContent = filterAnimeContent(movies);
              if (animeContent.length === 0) {
                // Show message when no anime found
                moviesContainer.innerHTML = '';
                const noResults = document.createElement('div');
                noResults.style.textAlign = 'center';
                noResults.style.padding = '2rem';
                noResults.innerHTML = `
                  <h2 class="section-title">Anime</h2>
                  <p>No anime content found. Try refreshing the page or check back later.</p>
                `;
                moviesContainer.appendChild(noResults);
              } else {
                // Sort by release date (newest first)
                const sortedAnimeContent = animeContent.sort((a, b) => {
                  const dateA = new Date(a.release_date || a.releaseDate || '1900-01-01');
                  const dateB = new Date(b.release_date || b.releaseDate || '1900-01-01');
                  return dateB - dateA; // Newest first
                });
                displayMovies(sortedAnimeContent, false, 'Anime');
              }
              // Scroll to movies section (skip during initial page load)
              if (!window.initialPageLoad) {
                setTimeout(() => {
                  const title = document.querySelector('.section-title');
                  if (!window.initialPageLoad && title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
              }
              isCategoryLoading = false;
              // Re-enable category buttons
              mountCategoryBar();
            }).catch(error => {
              console.error('Error loading anime content:', error);
              // Show error message
              moviesContainer.innerHTML = '';
              const errorMsg = document.createElement('div');
              errorMsg.style.textAlign = 'center';
              errorMsg.style.padding = '2rem';
              errorMsg.innerHTML = `
                <h2 class="section-title">Anime</h2>
                <p>Unable to load anime content. Please try again later.</p>
              `;
              moviesContainer.appendChild(errorMsg);
              isCategoryLoading = false;
              // Re-enable category buttons
              mountCategoryBar();
            });
          } else {
            console.error('loadAllTMDBMovies function not available for anime');
            isCategoryLoading = false;
            mountCategoryBar();
          }
          return;
        }

        // Movies: all/bollywood/tollywood
        if (typeof setTMDBMode === 'function') setTMDBMode('movie');
        const label = cat === 'all' ? 'All Movies' : (cat.charAt(0).toUpperCase() + cat.slice(1));
        if (cat === 'all' && typeof loadAllTMDBMovies === 'function') {
          loadAllTMDBMovies(10).then(movies => {
            // Check if this is still the current load
            if (loadId !== currentCategoryLoadId) return;
            displayMovies(movies, false, label);
            // Scroll to movies section (skip during initial page load)
            if (!window.initialPageLoad) {
              setTimeout(() => {
                const title = document.querySelector('.section-title');
                if (!window.initialPageLoad && title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }, 100);
            }
            isCategoryLoading = false;
            // Re-enable category buttons
            mountCategoryBar();
          }).catch(error => {
            console.error('Error loading movies:', error);
            isCategoryLoading = false;
            // Re-enable category buttons
            mountCategoryBar();
          });
        } else if (typeof loadTMDBByLanguage === 'function') {
          loadTMDBByLanguage(cat, 10).then(movies => {
            // Check if this is still the current load
            if (loadId !== currentCategoryLoadId) return;
            displayMovies(movies, false, label);
            // Scroll to movies section (skip during initial page load)
            if (!window.initialPageLoad) {
              setTimeout(() => {
                const title = document.querySelector('.section-title');
                if (!window.initialPageLoad && title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }, 100);
            }
            isCategoryLoading = false;
            // Re-enable category buttons
            mountCategoryBar();
          }).catch(error => {
            console.error('Error loading category movies:', error);
            isCategoryLoading = false;
            // Re-enable category buttons
            mountCategoryBar();
          });
        } else if (typeof loadAllTMDBMovies === 'function') {
          loadAllTMDBMovies().then(movies => {
            // Check if this is still the current load
            if (loadId !== currentCategoryLoadId) return;
            let filtered = typeof filterTMDBByCategory === 'function' ? filterTMDBByCategory(movies, cat) : movies;

            // Sort by release date (newest first) for specific categories
            if (['bollywood', 'tollywood'].includes(cat)) {
              filtered = filtered.sort((a, b) => {
                const dateA = new Date(a.release_date || a.releaseDate || '1900-01-01');
                const dateB = new Date(b.release_date || b.releaseDate || '1900-01-01');
                return dateB - dateA; // Newest first
              });
            }

            displayMovies(filtered, false, label);
            // Scroll to movies section
            setTimeout(() => {
              const title = document.querySelector('.section-title');
              if (!window.initialPageLoad) { if (title) title.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
            }, 100);
            isCategoryLoading = false;
            // Re-enable category buttons
            mountCategoryBar();
          }).catch(error => {
            console.error('Error loading filtered movies:', error);
            isCategoryLoading = false;
            // Re-enable category buttons
            mountCategoryBar();
          });
        } else {
          isCategoryLoading = false;
          // Re-enable category buttons
          mountCategoryBar();
        }
        return;
      }

      // Local curated catalog fallback
      if (cat === 'all') {
        displayMovies(curatedMovies, false, 'All Movies');
      } else if (cat === 'anime') {
        // Filter anime from curated movies
        let animeContent = filterAnimeContent(curatedMovies);
        // Sort by release date (newest first)
        animeContent = animeContent.sort((a, b) => {
          const dateA = new Date(a.release_date || a.releaseDate || '1900-01-01');
          const dateB = new Date(b.release_date || b.releaseDate || '1900-01-01');
          return dateB - dateA; // Newest first
        });
        if (animeContent.length === 0) {
          // Show message when no anime found
          moviesContainer.innerHTML = '';
          const noResults = document.createElement('div');
          noResults.style.textAlign = 'center';
          noResults.style.padding = '2rem';
          noResults.innerHTML = `
            <h2 class="section-title">Anime</h2>
            <p>No anime content found in local catalog. Loading from TMDB...</p>
          `;
          moviesContainer.appendChild(noResults);
        } else {
          displayMovies(animeContent, false, 'Anime');
        }
      } else {
        // Use language-based filtering for bollywood/tollywood
        let filtered = filterTMDBByCategory(curatedMovies, cat);
        // Sort by release date (newest first) for specific categories
        if (['bollywood', 'tollywood'].includes(cat)) {
          filtered = filtered.sort((a, b) => {
            const dateA = new Date(a.release_date || a.releaseDate || '1900-01-01');
            const dateB = new Date(b.release_date || b.releaseDate || '1900-01-01');
            return dateB - dateA; // Newest first
          });
        }
        const label = cat.charAt(0).toUpperCase() + cat.slice(1);
        displayMovies(filtered, false, label);
      }
      const cwSection = document.getElementById('continueWatchingSection');
      if (cwSection) {
        // Only show if not searching and at least one continue watching card exists.
        const hasCards = !!cwSection.querySelector('.continue-watching-card');
        cwSection.style.display = (isSearching || !hasCards) ? 'none' : '';
      }
      // Scroll to movies section (skip during initial page load)
      if (!window.initialPageLoad) {
        setTimeout(() => {
          const title = document.querySelector('.section-title');
          if (!window.initialPageLoad && title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);
      }
      isCategoryLoading = false;
      // Re-enable category buttons
      mountCategoryBar();
    }

    function buildCategoryBar(activeCat) {
      const bar = document.createElement('div');
      bar.className = 'category-bar';
      const selectedCount = selectedGenreFilters.size;
      const filterOptions = GENRE_FILTER_OPTIONS.map((genre) => {
        const checked = selectedGenreFilters.has(genre.toLowerCase()) ? 'checked' : '';
        return `
          <label class="filter-option">
            <input type="checkbox" class="genre-filter-checkbox" data-genre="${genre}" ${checked} />
            <span class="filter-check" aria-hidden="true"></span>
            <span>${genre}</span>
          </label>
        `;
      }).join('');
      bar.innerHTML = `
        <button class="cat-btn" data-cat="all">All</button>
        <button class="cat-btn" data-cat="bollywood">Bollywood</button>
        <button class="cat-btn" data-cat="tollywood">Tollywood</button>
        <button class="cat-btn" data-cat="anime">Anime</button>
        <button class="cat-btn" data-cat="series">Series</button>
        <div class="filter-group">
          <button class="filter-toggle-btn ${selectedCount > 0 ? 'active' : ''}" id="genreFilterToggle" type="button" aria-expanded="false">
            <i class="fas fa-sliders-h"></i>
            <span>Filters</span>
            <span class="filter-count ${selectedCount > 0 ? '' : 'hidden'}" id="genreFilterCount">${selectedCount}</span>
          </button>
          <div class="genre-filter-panel" id="genreFilterPanel">
            <div class="filter-panel-head">
              <span class="filter-panel-title">Filter by genre</span>
              <button type="button" class="filter-clear-btn ${selectedCount > 0 ? '' : 'hidden'}" id="clearGenreFilters">Clear Filters</button>
            </div>
            <div class="filter-options-grid">
              ${filterOptions}
            </div>
          </div>
        </div>
      `;
      const setActive = (cat) => {
        bar.querySelectorAll('.cat-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.cat === cat);
        });
      };
      setActive(activeCat || 'all');
      // Event listener is attached in mountCategoryBar using event delegation
      // to avoid duplicate listeners when the bar is rebuilt
      return bar;
    }

    function normalizeGenreName(genre) {
      return String(genre || '').trim().toLowerCase();
    }

    function getMovieGenreNames(movie) {
      const names = [];
      if (Array.isArray(movie && movie.genres)) {
        movie.genres.forEach((g) => {
          if (typeof g === 'string') {
            names.push(g);
          } else if (g && typeof g.name === 'string') {
            names.push(g.name);
          }
        });
      }
      if (Array.isArray(movie && movie.genre_ids)) {
        movie.genre_ids.forEach((id) => {
          const mapped = TMDB_GENRE_ID_TO_NAME[id];
          if (mapped) names.push(mapped);
        });
      }
      return names.map(normalizeGenreName).filter(Boolean);
    }

    function applyGenreFiltersToMovies(movies) {
      if (!selectedGenreFilters.size) return movies;
      return movies.filter((movie) => {
        const genres = getMovieGenreNames(movie);
        if (!genres.length) return false;
        for (const selected of selectedGenreFilters) {
          if (genres.some((g) => g.includes(selected) || selected.includes(g))) {
            return true;
          }
        }
        return false;
      });
    }

    function refreshFilterUI() {
      const countEl = document.getElementById('genreFilterCount');
      const toggleBtn = document.getElementById('genreFilterToggle');
      const clearBtn = document.getElementById('clearGenreFilters');
      const count = selectedGenreFilters.size;
      if (countEl) {
        countEl.textContent = String(count);
        countEl.classList.toggle('hidden', count === 0);
      }
      if (toggleBtn) {
        toggleBtn.classList.toggle('active', count > 0);
      }
      if (clearBtn) {
        clearBtn.classList.toggle('hidden', count === 0);
      }
      syncPopularSectionsVisibility();
    }

    function syncPopularSectionsVisibility() {
      const popularSection = document.getElementById('popularMoviesSection');
      const popularTVSection = document.getElementById('popularTVSection');
      const shouldHideForSearch = !!isSearching;
      const shouldHideForFilters = selectedGenreFilters.size > 0;
      const shouldShow = !shouldHideForSearch && !shouldHideForFilters && currentCategory === 'all';

      if (popularSection) popularSection.style.display = shouldShow ? '' : 'none';
      if (popularTVSection) popularTVSection.style.display = shouldShow ? '' : 'none';
    }

    function closeGenreFilterPanel() {
      const panel = document.getElementById('genreFilterPanel');
      const toggle = document.getElementById('genreFilterToggle');
      if (panel) panel.classList.remove('open');
      if (toggle) toggle.setAttribute('aria-expanded', 'false');
      keepGenreFilterPanelOpen = false;
    }

    function reapplyCurrentViewForFilters() {
      if (isSearching) {
        performSearch();
      } else {
        applyCategory(currentCategory || 'all');
      }
    }

    // Mount the category bar into the persistent mount point
    function mountCategoryBar() {
      const mount = document.getElementById('categoryBarMount');
      if (!mount) return;
      mount.innerHTML = '';
      const bar = buildCategoryBar(currentCategory);
      mount.appendChild(bar);

      // Disable buttons during loading
      if (isCategoryLoading) {
        bar.querySelectorAll('.cat-btn').forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.6';
        });
      }

      // Attach event listener only once using event delegation
      // to avoid duplicate listeners when the bar is rebuilt
      if (!categoryBarListenerAttached) {
        mount.addEventListener('click', (e) => {
          const filterToggle = e.target.closest('#genreFilterToggle');
          if (filterToggle) {
            e.stopPropagation();
            const panel = document.getElementById('genreFilterPanel');
            const isOpen = panel && panel.classList.contains('open');
            closeGenreFilterPanel();
            if (panel && !isOpen) {
              panel.classList.add('open');
              filterToggle.setAttribute('aria-expanded', 'true');
              keepGenreFilterPanelOpen = true;
            }
            return;
          }

          const clearFiltersBtn = e.target.closest('#clearGenreFilters');
          if (clearFiltersBtn) {
            e.stopPropagation();
            selectedGenreFilters.clear();
            reopenFilterPanelAfterMount = true;
            keepGenreFilterPanelOpen = true;
            mountCategoryBar();
            reapplyCurrentViewForFilters();
            return;
          }

          const btn = e.target.closest('.cat-btn');
          if (!btn || btn.disabled) return;
          applyCategory(btn.dataset.cat);
        });
        categoryBarListenerAttached = true;
      }

      if (!categoryBarChangeListenerAttached) {
        mount.addEventListener('change', (e) => {
          const checkbox = e.target.closest('.genre-filter-checkbox');
          if (!checkbox) return;
          const genre = normalizeGenreName(checkbox.dataset.genre || checkbox.value);
          if (!genre) return;
          if (checkbox.checked) {
            selectedGenreFilters.add(genre);
          } else {
            selectedGenreFilters.delete(genre);
          }
          refreshFilterUI();
          reopenFilterPanelAfterMount = true;
          keepGenreFilterPanelOpen = true;
          reapplyCurrentViewForFilters();
        });
        categoryBarChangeListenerAttached = true;
      }

      if (!filterOutsideClickAttached) {
        document.addEventListener('click', (e) => {
          if (e.target.closest('#genreFilterToggle') || e.target.closest('#genreFilterPanel')) {
            return;
          }
          const mountEl = document.getElementById('categoryBarMount');
          if (!mountEl || !mountEl.contains(e.target)) {
            closeGenreFilterPanel();
          }
        });
        filterOutsideClickAttached = true;
      }

      refreshFilterUI();
      if (reopenFilterPanelAfterMount || keepGenreFilterPanelOpen) {
        const panel = document.getElementById('genreFilterPanel');
        const toggle = document.getElementById('genreFilterToggle');
        if (panel && toggle) {
          panel.classList.add('open');
          toggle.setAttribute('aria-expanded', 'true');
          keepGenreFilterPanelOpen = true;
        }
        reopenFilterPanelAfterMount = false;
      }
    }

    function getPosterFallback(title) {
      const safeTitle = String(title || 'Movie').replace(/[<>]/g, '');
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="500" height="750" viewBox="0 0 500 750"><rect width="500" height="750" fill="#1a1a1a"/><text x="50%" y="50%" font-family="Arial" font-size="26" fill="#9a9a9a" text-anchor="middle" dominant-baseline="middle">${safeTitle}</text></svg>`;
      return `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svg)}`;
    }

    function displayMovies(movies, isSearchResults = false, titleOverride = null) {
      const genreFilteredMovies = applyGenreFiltersToMovies(Array.isArray(movies) ? movies : []);
      // Filter out movies/series without ratings
      const ratedMovies = genreFilteredMovies.filter(movie => {
        return movie.rating !== null && movie.rating !== undefined && movie.rating > 0;
      });

      // Clear the movies container completely
      moviesContainer.innerHTML = '';

      // The persistent mount renders the category bar; avoid duplicating it here
      // Keep legacy fallback only if mount is missing and using curated catalog
      if (!useTMDBCatalog && !document.getElementById('categoryBarMount')) {
        const catBar = buildCategoryBar(currentCategory);
        moviesContainer.appendChild(catBar);
      }

      // Hide section title when genre filters are active (show only filtered content)
      const hasActiveGenreFilters = selectedGenreFilters.size > 0;
      if (!hasActiveGenreFilters) {
        const sectionHeader = document.createElement('div');
        sectionHeader.className = 'section-header';
        const sectionTitle = document.createElement('h2');
        sectionTitle.className = 'section-title';
        sectionTitle.textContent = titleOverride || (movies === curatedMovies ? 'All Movies' : 'Search Results');
        sectionHeader.appendChild(sectionTitle);
        moviesContainer.appendChild(sectionHeader);
      }

      // Check if we have any rated movies to display
      if (ratedMovies.length === 0) {
        const noRatedMovies = document.createElement('div');
        noRatedMovies.style.textAlign = 'center';
        noRatedMovies.style.padding = '2rem';
        noRatedMovies.innerHTML = `
          <p>${selectedGenreFilters.size ? 'No matches for selected filters.' : 'No rated movies found in this category.'}</p>
        `;
        moviesContainer.appendChild(noRatedMovies);
        return;
      }

      // Add all movies
      const moviesGrid = document.createElement('div');
      moviesGrid.className = 'movies-grid';

      ratedMovies.forEach(movie => {
        const title = movie.title || 'Untitled';
        const posterPath = movie.posterUrl || getPosterFallback(title);

        const movieCard = document.createElement('div');
        movieCard.className = 'movie-card movie-' + movie.id;
        movieCard.innerHTML = `
          <div class="poster">
            <img src="${posterPath}" alt="${title}" loading="lazy" />
            <div class="rating-badge"><span class="star">â˜…</span><span class="value">${movie.rating ? movie.rating.toFixed(1) : 'N/A'}</span></div>
            <div class="play-icon"></div>
            <div class="movie-title-overlay">${title}</div>
          </div>
          <div class="movie-info">
            <h3 class="movie-title">${title} (${movie.year || ''})</h3>
          </div>
        `;

        // Add error handler for broken images
        const img = movieCard.querySelector('img');
        if (img) {
          img.addEventListener('error', () => {
            // Replace with placeholder if image fails to load
            img.src = getPosterFallback(title);
          });
        }

        movieCard.addEventListener('click', () => openMovieModal(movie));
        moviesGrid.appendChild(movieCard);
      });

      moviesContainer.appendChild(moviesGrid);

      // If this is the initial page load, delay clearing the flag until after movies render
      if (window.initialPageLoad) {
        // Do NOT clear the flag here; it will be cleared after the category refresh completes to avoid race conditions.
      }
    }




    /**
     * Apply theme to the page
     * @param {string} theme - Theme name (must match a key in themePresets)
     */
    // Return a profile-scoped theme key using selected profile local state
    function getScopedThemeKey() {
      try {
        const getUser = window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function' ? window.FirebaseAuth.getUser : null;
        const user = getUser ? getUser() : null;
        const uid = user && user.uid;
        if (!uid) return 'app_theme_guest';
        const sel = localStorage.getItem(`fb_selected_profile_${uid}`);
        return sel ? `app_theme_${uid}_${sel}` : `app_theme_${uid}`;
      } catch (e) {
        return 'app_theme_guest';
      }
    }

    function applyTheme(theme) {
      const presets = themePresets[theme] || themePresets.glossy;
      const root = document.documentElement.style;

      // Update CSS variables
      root.setProperty('--theme-bg1', presets.bgs[0]);
      root.setProperty('--theme-bg2', presets.bgs[1]);
      root.setProperty('--theme-bg3', presets.bgs[2]);
      root.setProperty('--accent', presets.accent);
      root.setProperty('--particle-color-1', presets.particles[0]);
      root.setProperty('--particle-color-2', presets.particles[1]);

      // Save to localStorage (scoped per profile when available)
      const key = getScopedThemeKey();
      if (localStorage.getItem(key) !== theme) {
        localStorage.setItem(key, theme);
      }

      // Recreate particles with new colors
      // Guard: if particles script hasn't loaded yet, skip silently
      if (typeof createParticles === 'function') {
        createParticles();
      }
    }

    /**
     * Set up event listeners for theme changes
     */
    function setupThemeListener() {
      // Listen for theme changes from other tabs/windows
      window.addEventListener('storage', (e) => {
        const key = getScopedThemeKey();
        if (e.key === key) {
          applyTheme(e.newValue);
        }
      });

      // Listen for theme changes via BroadcastChannel (for same-origin tabs)
      if (typeof BroadcastChannel !== 'undefined') {
        const channel = new BroadcastChannel('theme_channel');
        channel.onmessage = (e) => {
          if (e.data && e.data.type === 'THEME_CHANGED') {
            try {
              const getUser = window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function' ? window.FirebaseAuth.getUser : null;
              const user = getUser ? getUser() : null;
              const uid = user && user.uid;
              const sel = uid ? localStorage.getItem(`fb_selected_profile_${uid}`) : null;
              if (!uid || !sel) return;
              if (e.data.uid === uid && e.data.profileId === sel) {
                applyTheme(e.data.theme);
              }
            } catch (_) { }
          }
        };
      }
    }

    // Open Modal (lazy-load trailer iframe on demand)
    function openMovieModal(movie) {
      // Ensure top-level variables are declared so later code (outside inner try) can reference them without throwing
      let isSeries = false;
      let streamBtn = document.getElementById('streamBtn');
      let streamBtn2 = document.getElementById('streamBtn2');
      let seasonTrigger = document.getElementById('seasonTrigger');
      let episodeTrigger = document.getElementById('episodeTrigger');
      let seasonDropdown = document.getElementById('seasonDropdown');
      let episodeDropdown = document.getElementById('episodeDropdown');
      let seasonWrapper = document.getElementById('seasonSelectWrapper');
      let episodeWrapper = document.getElementById('episodeSelectWrapper');

      // Reset poster and overlay state
      const initialPoster = document.getElementById('modalPoster');
      if (initialPoster) {
        initialPoster.style.opacity = '1';
        initialPoster.style.pointerEvents = 'auto';
        initialPoster.style.clipPath = 'inset(0% 0 0 0)';
      }
      const initialOverlay = document.querySelector('.modal-hero .play-overlay');
      if (initialOverlay) initialOverlay.style.display = 'flex';

      const initialHeroMeta = document.querySelector('.hero-meta');
      if (initialHeroMeta) {
        initialHeroMeta.style.opacity = '1';
        initialHeroMeta.style.pointerEvents = 'auto';
      }

      try {
        // Save current scroll position before opening modal
        savedScrollPosition = window.scrollY || window.pageYOffset;

        // Store current movie and category in sessionStorage so player can restore on back
        sessionStorage.setItem('currentModalMovie', JSON.stringify(movie));
        sessionStorage.setItem('currentModalCategory', currentCategory);

        console.log('Opening modal for movie:', movie.title);
        isSeries = (movie && (movie.mediaType === 'tv' || movie.type === 'series' || movie.isSeries));
        // Set up Stream 2 button to open player-stream.html with the same logic as Stream (movies only)
        streamBtn2 = document.getElementById('streamBtn2');
        if (!isSeries && streamBtn2) {
          // Get watch data for Stream 2 button too
          let watchData2 = null;
          if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.getMovieProgress === 'function') {
            watchData2 = window.ContinueWatchingManager.getMovieProgress(movie.id);
          }
          if (!watchData2) {
            const legacyCW = JSON.parse(localStorage.getItem('continueWatching') || '{}');
            watchData2 = legacyCW[movie.id];
          }

          // streamBtn2 onclick initialized below; legacy logic removed
          streamBtn2.onclick = null;
          streamBtn2.onclick = async (e) => {
            e.preventDefault();
            const isAvailable = streamBtn2.dataset.available === '1';
            if (!isAvailable) {
              // Fallback: resolve via 8Stream API for player-2
              streamBtn2.textContent = 'Resolvingâ€¦';
              streamBtn2.disabled = true;
              (async () => {
                try {
                  const result = await window.resolveStreamUrlForMovie(movie, ['English', 'Hindi', 'Tamil', 'Telugu', 'Bengali']);
                  if (result && result.success && result.src) {
                    const params = new URLSearchParams();
                    params.append('id', movie.id);
                    params.append('movieId', movie.id);
                    params.append('title', movie.title);
                    if (movie.posterUrl) params.append('poster', movie.posterUrl);
                    const isHls2 = /\.m3u8(\?.*)?$/.test(result.src) || result.type === 'hls';
                    params.append('type', isHls2 ? 'hls' : (result.type || 'mp4'));
                    params.append('src', result.src);
                    if (result.imdbId) params.append('imdbId', result.imdbId);
                    if (result.key) params.append('streamKey', result.key);
                    if (result.language) params.append('currentLang', result.language);
                    if (result.availableLanguages) params.append('availableLangs', JSON.stringify(result.availableLanguages));
                    const finalUrl = `player-stream.html?${params.toString()}`;
                    localStorage.setItem('lastPlayerUsed', 'player-stream');
                    window.location.href = finalUrl;
                  } else {
                    showToast('error', 'Stream Unavailable', 'Could not resolve a stream for this title.');
                  }
                } catch (e) {
                  console.error('Stream resolve failed:', e);
                  showToast('error', 'Stream Error', 'Failed to resolve stream.');
                } finally {
                  streamBtn2.textContent = 'Stream 2';
                  streamBtn2.disabled = false;
                }
              })();
              return;
            }
            // Build the player-2.html URL with the current movie's details
            const params = new URLSearchParams();
            params.append('id', movie.id);
            params.append('movieId', movie.id);
            params.append('title', movie.title);
            if (movie.posterUrl) params.append('poster', movie.posterUrl);
            const normTitle = String(movie.title || '').trim().toLowerCase();
            let player2Url = null;
            const mp4Url = mp4Overrides[normTitle];
            if (mp4Url) {
              const isHls = /\.m3u8(\?.*)?$/.test(mp4Url);
              params.append('type', isHls ? 'hls' : 'mp4');
              params.append('src', mp4Url);
              player2Url = `player-stream.html?${params.toString()}`;
            } else if (driveMovieMappings[String(movie.id)]) {
              params.append('type', 'drive');
              params.append('id', driveMovieMappings[String(movie.id)]);
              player2Url = `player-stream.html?${params.toString()}`;
            } else if (movie.streamUrl) {
              const isHls = /\.m3u8(\?.*)?$/.test(movie.streamUrl);
              params.append('type', isHls ? 'hls' : 'mp4');
              params.append('src', movie.streamUrl);
              player2Url = `player-stream.html?${params.toString()}`;
            } else {
              // Resolve via 8Stream API for player-2
              streamBtn2.textContent = 'Resolvingâ€¦';
              streamBtn2.disabled = true;
              (async () => {
                try {
                  const result = await window.resolveStreamUrlForMovie(movie, ['English', 'Hindi', 'Tamil', 'Telugu', 'Bengali']);
                  if (result && result.success && result.src) {
                    const isHls2 = /\.m3u8(\?.*)?$/.test(result.src) || result.type === 'hls';
                    params.append('type', isHls2 ? 'hls' : (result.type || 'mp4'));
                    params.append('src', result.src);
                    if (result.imdbId) params.append('imdbId', result.imdbId);
                    if (result.key) params.append('streamKey', result.key);
                    if (result.language) params.append('currentLang', result.language);
                    if (result.availableLanguages) params.append('availableLangs', JSON.stringify(result.availableLanguages));
                    player2Url = `player-stream.html?${params.toString()}`;
                    localStorage.setItem('lastPlayerUsed', 'player-stream');
                    window.location.href = player2Url;
                  } else {
                    showToast('error', 'Stream Unavailable', 'Could not resolve a stream for this title.');
                  }
                } catch (e) {
                  console.error('Stream resolve failed:', e);
                  showToast('error', 'Stream Error', 'Failed to resolve stream.');
                } finally {
                  streamBtn2.textContent = 'Stream 2';
                  streamBtn2.disabled = false;
                }
              })();
            }
            if (player2Url) {
              // Check if we have saved progress and ask whether to resume
              const choice = await askResumeChoice(watchData2);
              localStorage.setItem('lastPlayerUsed', 'player-stream');
              const finalUrl = choice.wantsResume && choice.resumeSeconds > 0
                ? `${player2Url}&t=${choice.resumeSeconds}`
                : player2Url;
              window.location.href = finalUrl;
            } else {
              // If resolution flow navigates, we don't reach here; else show error
            }
          };
        }
        currentMovie = movie;
      } catch (err) { console.error('openMovieModal error', err); if (typeof showToast === 'function') showToast('error', 'UI Error', 'See console for details'); }

      // Override/ensure Stream 2 uses NontonGo-only flow and add defensive error handling
      try {
        if (streamBtn2) {
          streamBtn2.onclick = async (e) => {
            try {
              e.preventDefault();
              const tmdbId = movie && (movie.id || movie.tmdbId || movie.movieId);
              const imdbId = movie && (movie.imdb_id || movie.imdbId);
              if (!tmdbId) {
                console.error('Stream2: missing TMDB id for movie', movie);
                if (typeof showToast === 'function') showToast('error', 'Missing data', 'TMDB id not available');
                return;
              }
              const params = new URLSearchParams();
              params.append('id', tmdbId);
              params.append('movieId', tmdbId);
              params.append('tmdbId', tmdbId);
              if (imdbId) params.append('imdbId', imdbId);
              params.append('mediaType', (movie && (movie.mediaType === 'tv' || movie.type === 'series' || movie.isSeries)) ? 'tv' : 'movie');
              if (movie && movie.title) params.append('title', movie.title);
              if (movie && movie.posterUrl) params.append('poster', movie.posterUrl);

              // Resume prompt for Stream 2 (same behavior as other players)
              let watchData2 = null;
              if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.getMovieProgress === 'function') {
                watchData2 = window.ContinueWatchingManager.getMovieProgress(tmdbId);
              }
              if (!watchData2) {
                const legacyCW = JSON.parse(localStorage.getItem('continueWatching') || '{}');
                watchData2 = legacyCW[tmdbId];
              }

              localStorage.setItem('lastPlayerUsed', 'player2');
              console.log('Stream2: Opening player-2 with params:', params.toString());
              const choice = await askResumeChoice(watchData2);
              const targetUrl = choice.wantsResume && choice.resumeSeconds > 0
                ? `player-2.html?${params.toString()}&t=${choice.resumeSeconds}`
                : `player-2.html?${params.toString()}`;
              window.location.href = targetUrl;
            } catch (err) {
              console.error('Stream2 click handler error', err);
              if (typeof showToast === 'function') showToast('error', 'Player Error', 'See console for details');
            }
          };
        }
      } catch (err) {
        console.error('Failed to install Stream2 override', err);
      }

      // Stream 3 button handler - redirects to nontongoplayer.html for 8Stream
      try {
        const streamBtn3 = document.getElementById('streamBtn3');
        console.log('ðŸ” Stream 3 button found:', !!streamBtn3, 'isSeries:', isSeries);
        if (streamBtn3 && !isSeries) {
          streamBtn3.onclick = (e) => {
            try {
              console.log('ðŸŽ¯ Stream 3 button clicked!');
              e.preventDefault();
              e.stopPropagation();
              const params = new URLSearchParams();

              // Add movie ID (TMDB or IMDb)
              const movieId = movie && (movie.id || movie.movieId || movie.tmdbId);
              const imdbId = movie && (movie.imdb_id || movie.imdbId);

              console.log('ðŸ“Š Movie data:', { movieId, imdbId, title: movie?.title });

              if (movieId) params.append('id', movieId);
              if (movieId) params.append('movieId', movieId);
              if (imdbId) params.append('imdbId', imdbId);

              params.append('type', 'movie');
              if (movie && movie.title) params.append('title', movie.title);
              if (movie && movie.posterUrl) params.append('poster', movie.posterUrl);

              const targetUrl = `nontongoplayer.html?${params.toString()}`;
              console.log('ðŸš€ Redirecting to:', targetUrl);

              localStorage.setItem('lastPlayerUsed', 'player-8stream');
              window.location.href = targetUrl;
            } catch (err) {
              console.error('Stream3 click handler error', err);
              if (typeof showToast === 'function') showToast('error', 'Player Error', 'See console for details');
            }
          };
          console.log('âœ… Stream 3 handler installed');
        }
      } catch (err) {
        console.error('Failed to install Stream3 handler', err);
      }

      // Series handling: hide stream buttons, show season/episode selectors
      // isSeries already computed above
      const seriesPicker = document.getElementById('seriesPicker');
      const seasonSelect = document.getElementById('seasonSelect');
      const episodeSelect = document.getElementById('episodeSelect');
      const seriesMeta = document.getElementById('seriesMeta');

      // Custom dropdown elements
      let dropdownsInitialized = false;
      function initCustomDropdowns() {
        // Always re-initialize dropdowns when series picker is shown
        dropdownsInitialized = false;
        // Always get fresh references to dropdown elements (do NOT shadow outer scope variables)
        let _seasonTrigger = document.getElementById('seasonTrigger');
        let seasonDropdown = document.getElementById('seasonDropdown');
        const seasonWrapper = document.getElementById('seasonSelectWrapper');
        let _episodeTrigger = document.getElementById('episodeTrigger');
        let episodeDropdown = document.getElementById('episodeDropdown');
        const episodeWrapper = document.getElementById('episodeSelectWrapper');
        if (dropdownsInitialized) return;
        dropdownsInitialized = true;

        // Remove previous event listeners by replacing elements with clones
        if (_seasonTrigger && _seasonTrigger.parentNode) {
          const newSeasonTrigger = _seasonTrigger.cloneNode(true);
          _seasonTrigger.parentNode.replaceChild(newSeasonTrigger, _seasonTrigger);
        }
        if (_episodeTrigger && _episodeTrigger.parentNode) {
          const newEpisodeTrigger = _episodeTrigger.cloneNode(true);
          _episodeTrigger.parentNode.replaceChild(newEpisodeTrigger, _episodeTrigger);
        }

        // Update outer scoped references so other code sees the fresh elements
        seasonTrigger = document.getElementById('seasonTrigger');
        episodeTrigger = document.getElementById('episodeTrigger');
        seasonDropdown = document.getElementById('seasonDropdown');
        episodeDropdown = document.getElementById('episodeDropdown');

        // Get fresh references after cloning
        const freshSeasonTrigger = seasonTrigger;
        const freshEpisodeTrigger = episodeTrigger;

        // Season dropdown toggle - use mousedown for instant response
        if (freshSeasonTrigger && seasonWrapper) {
          freshSeasonTrigger.addEventListener('mousedown', function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (episodeWrapper) episodeWrapper.classList.remove('active');
            if (seasonWrapper.classList.contains('active')) {
              seasonWrapper.classList.remove('active');
            } else {
              seasonWrapper.classList.add('active');
            }
          }, { passive: false });
        }

        // Episode dropdown toggle - use mousedown for instant response
        if (freshEpisodeTrigger && episodeWrapper) {
          freshEpisodeTrigger.addEventListener('mousedown', function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (seasonWrapper) seasonWrapper.classList.remove('active');
            if (episodeWrapper.classList.contains('active')) {
              episodeWrapper.classList.remove('active');
            } else {
              episodeWrapper.classList.add('active');
            }
          }, { passive: false });
        }

        // Close dropdowns when clicking outside
        document.addEventListener('mousedown', function (e) {
          if (seasonWrapper && !seasonWrapper.contains(e.target)) {
            seasonWrapper.classList.remove('active');
          }
          if (episodeWrapper && !episodeWrapper.contains(e.target)) {
            episodeWrapper.classList.remove('active');
          }
        });
      }

      function updateSeasonDropdown(seasons) {
        const currentSeasonTrigger = document.getElementById('seasonTrigger');
        if (!seasonDropdown || !currentSeasonTrigger) return;

        seasonDropdown.innerHTML = '';
        const seasonValue = currentSeasonTrigger.querySelector('.select-value');

        if (!seasons || seasons.length === 0) {
          if (seasonValue) seasonValue.textContent = 'No seasons available';
          return;
        }

        seasons.forEach((season, index) => {
          const option = document.createElement('div');
          option.className = 'select-option';
          option.textContent = season.name || `Season ${season.season_number}`;
          option.dataset.value = season.season_number;

          if (index === 0) {
            option.classList.add('selected');
            if (seasonValue) seasonValue.textContent = option.textContent;
          }

          option.addEventListener('mousedown', function (e) {
            e.preventDefault();
            e.stopPropagation();

            // Update visual selection
            seasonDropdown.querySelectorAll('.select-option').forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            if (seasonValue) seasonValue.textContent = option.textContent;

            // Update hidden select and trigger change - get fresh reference
            const currentSeasonSelect = document.getElementById('seasonSelect');
            if (currentSeasonSelect) {
              const num = season.season_number;
              currentSeasonSelect.value = String(num);
              currentSeasonSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // Close dropdown
            if (seasonWrapper) seasonWrapper.classList.remove('active');
          }, { passive: false });

          seasonDropdown.appendChild(option);
        });
      }

      function updateEpisodeDropdown(episodes, seasonNumber) {
        const currentEpisodeTrigger = document.getElementById('episodeTrigger');
        if (!episodeDropdown || !currentEpisodeTrigger) return;

        episodeDropdown.innerHTML = '';
        const episodeValue = currentEpisodeTrigger.querySelector('.select-value');

        if (!episodes || episodes.length === 0) {
          if (episodeValue) episodeValue.textContent = 'No episodes available';
          return;
        }

        episodes.forEach((ep, index) => {
          const option = document.createElement('div');
          option.className = 'select-option';
          const epNum = ep.episode_number;
          option.textContent = `E${epNum} â€¢ ${ep.name || 'Episode ' + epNum}`;
          option.dataset.value = epNum;

          if (index === 0) {
            option.classList.add('selected');
            if (episodeValue) episodeValue.textContent = option.textContent;
          }

          option.addEventListener('mousedown', function (e) {
            e.preventDefault();
            e.stopPropagation();

            // Update visual selection
            episodeDropdown.querySelectorAll('.select-option').forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            if (episodeValue) episodeValue.textContent = option.textContent;

            // Update hidden select and trigger change - get fresh reference
            const currentEpisodeSelect = document.getElementById('episodeSelect');
            if (currentEpisodeSelect) {
              currentEpisodeSelect.value = String(epNum);
              currentEpisodeSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // Close dropdown
            if (episodeWrapper) episodeWrapper.classList.remove('active');
          }, { passive: false });

          episodeDropdown.appendChild(option);
        });
      }

      initCustomDropdowns();

      const heroActions = document.querySelector('#movieModal .hero-actions');
      const streamBtnMainEl = document.getElementById('streamBtn');
      const streamBtn2ElForSeries = document.getElementById('streamBtn2');
      const streamBtn3ElForSeries = document.getElementById('streamBtn3');
      if (streamBtnMainEl) streamBtnMainEl.style.display = '';
      if (streamBtn2ElForSeries) streamBtn2ElForSeries.style.display = '';
      if (streamBtn3ElForSeries) streamBtn3ElForSeries.style.display = '';
      if (heroActions) heroActions.classList.toggle('series-mode', !!isSeries);
      if (seriesPicker) {
        seriesPicker.style.display = isSeries ? 'flex' : 'none';
      }

      // If series, load seasons and wire up dropdowns
      if (isSeries && seriesPicker && seasonSelect && episodeSelect) {
        setTimeout(() => { initCustomDropdowns(); }, 0);
        const seasonValue = seasonTrigger?.querySelector('.select-value');
        const episodeValue = episodeTrigger?.querySelector('.select-value');
        const setSeriesMeta = (text = '') => {
          if (!seriesMeta) return;
          const clean = String(text || '').trim();
          if (!clean) {
            seriesMeta.textContent = '';
            seriesMeta.style.display = 'none';
            return;
          }
          seriesMeta.textContent = clean;
          seriesMeta.style.display = '';
        };
        if (seasonValue) seasonValue.textContent = 'Loading seasons...';
        if (episodeValue) episodeValue.textContent = 'Select a season first';
        seasonSelect.innerHTML = '<option>Loading seasons...</option>';
        episodeSelect.innerHTML = '<option>Select a season first</option>';
        setSeriesMeta('');

        // Fetch seasons and populate dropdown
        (async () => {
          try {
            if (!movieDb || typeof movieDb.getTVDetails !== 'function') return;
            const tvDetails = await movieDb.getTVDetails(movie.id);
            const seasons = tvDetails && tvDetails.seasons ? tvDetails.seasons : [];
            if (!seasons.length) {
              if (seasonValue) seasonValue.textContent = 'No seasons found';
              seasonSelect.innerHTML = '<option>No seasons found</option>';
              setSeriesMeta('');
              return;
            }
            setSeriesMeta(`${seasons.length} season${seasons.length === 1 ? '' : 's'} available`);
            seasonSelect.innerHTML = '';
            seasons.forEach(season => {
              const opt = document.createElement('option');
              opt.value = String(season.season_number);
              opt.textContent = season.name || `Season ${season.season_number}`;
              seasonSelect.appendChild(opt);
            });
            if (typeof updateSeasonDropdown === 'function') updateSeasonDropdown(seasons);
            // Auto-load episodes for selected season or first season
            const selectedSeasonNum = movie.selectedSeason || seasons[0].season_number;
            if (selectedSeasonNum) {
              seasonSelect.value = selectedSeasonNum;
              if (seasonTrigger) seasonTrigger.querySelector('.select-value').textContent = seasonSelect.options[seasonSelect.selectedIndex]?.text || `Season ${selectedSeasonNum}`;
              loadEpisodesForSeason(selectedSeasonNum).then(() => {
                if (movie.selectedEpisode) {
                  episodeSelect.value = movie.selectedEpisode;
                  if (episodeTrigger) episodeTrigger.querySelector('.select-value').textContent = episodeSelect.options[episodeSelect.selectedIndex]?.text || `Episode ${movie.selectedEpisode}`;
                }
              });
            }
          } catch (err) {
            console.error('Failed to load seasons for series', err);
            seasonSelect.innerHTML = '<option>Error loading seasons</option>';
            if (seasonValue) seasonValue.textContent = 'Error loading seasons';
            setSeriesMeta('');
          }
        })();

        // Loader for episodes of a season
        async function loadEpisodesForSeason(seasonNumber) {
          if (!movieDb || typeof movieDb.getTVSeason !== 'function') return;
          if (episodeValue) episodeValue.textContent = 'Loading episodes...';
          episodeSelect.innerHTML = '<option>Loading episodes...</option>';
          try {
            const seasonData = await movieDb.getTVSeason(movie.id, seasonNumber);
            const episodes = (seasonData && seasonData.episodes) ? seasonData.episodes : [];
            if (!episodes.length) {
              if (episodeValue) episodeValue.textContent = 'No episodes found';
              episodeSelect.innerHTML = '<option>No episodes found</option>';
              setSeriesMeta(`Season ${seasonNumber}`);
              return;
            }
            setSeriesMeta(`Season ${seasonNumber} â€¢ ${episodes.length} episode${episodes.length === 1 ? '' : 's'}`);
            episodeSelect.innerHTML = '';
            episodes.forEach(ep => {
              const opt = document.createElement('option');
              const epNum = ep.episode_number;
              opt.value = String(epNum);
              opt.textContent = `S${seasonNumber} Â· E${epNum} â€” ${ep.name || 'Episode'}`;
              episodeSelect.appendChild(opt);
            });
            if (typeof updateEpisodeDropdown === 'function') updateEpisodeDropdown(episodes, seasonNumber);
            try {
              const spBtn = document.getElementById('seriesPlayBtn');
              const spBtnPlayer = document.getElementById('seriesPlayBtnPlayer');
              const topWatchBtn = document.getElementById('streamBtn');
              const topStream2Btn = document.getElementById('streamBtn2');
              const topStream3Btn = document.getElementById('streamBtn3');
              if (spBtn) spBtn.disabled = false;
              if (spBtnPlayer) spBtnPlayer.disabled = false;
              if (topWatchBtn) topWatchBtn.disabled = false;
              if (topStream2Btn) topStream2Btn.disabled = false;
              if (topStream3Btn) topStream3Btn.disabled = false;
            } catch (e) { }
          } catch (err) {
            console.error('Failed to load episodes for season', seasonNumber, err);
            episodeSelect.innerHTML = '<option>Error loading episodes</option>';
            if (episodeValue) episodeValue.textContent = 'Error loading episodes';
            setSeriesMeta('');
          }
        }

        // Wire up season/episode controls
        try {
          seasonSelect.addEventListener('change', function (e) { const sn = Number(e.target.value); if (!isNaN(sn)) loadEpisodesForSeason(sn); });
          episodeSelect.addEventListener('change', function (e) {
            const ep = e.target.value;
            const hasEpisode = !!(ep && ep.length > 0);
            const spBtn = document.getElementById('seriesPlayBtn');
            const spBtnPlayer = document.getElementById('seriesPlayBtnPlayer');
            const topWatchBtn = document.getElementById('streamBtn');
            const topStream2Btn = document.getElementById('streamBtn2');
            const topStream3Btn = document.getElementById('streamBtn3');
            if (spBtn) spBtn.disabled = !hasEpisode;
            if (spBtnPlayer) spBtnPlayer.disabled = !hasEpisode;
            if (topWatchBtn) topWatchBtn.disabled = !hasEpisode;
            if (topStream2Btn) topStream2Btn.disabled = !hasEpisode;
            if (topStream3Btn) topStream3Btn.disabled = !hasEpisode;
          });
          const seriesPlayBtn = document.getElementById('seriesPlayBtn');
          const seriesPlayBtnPlayer = document.getElementById('seriesPlayBtnPlayer');
          if (seriesPlayBtn) {
            seriesPlayBtn.disabled = true;
            seriesPlayBtn.addEventListener('click', async function (e) {
              try {
                e.preventDefault();
                // Resolve IMDB id first; player-2.html requires an IMDB id for NontonGo embeds
                let imdbReal = currentMovie && (currentMovie.imdb_id || currentMovie.imdbId);
                const tmdbId = currentMovie && (currentMovie.id || currentMovie.movieId || currentMovie.tmdbId);

                const seasonNum = seasonSelect.value || document.getElementById('seasonSelect')?.value;
                const episodeNum = episodeSelect.value || document.getElementById('episodeSelect')?.value;
                if (!seasonNum || !episodeNum) {
                  if (typeof showToast === 'function') showToast('error', 'Select episode', 'Please select season and episode');
                  return;
                }

                if (!imdbReal && tmdbId && typeof movieDb !== 'undefined' && typeof movieDb.getTVDetails === 'function') {
                  try {
                    // Fetch TMDB details to extract IMDB id
                    const details = await movieDb.getTVDetails(tmdbId);
                    imdbReal = details && (details.imdb_id || (details.external_ids && details.external_ids.imdb_id) || details.imdbId);
                    if (imdbReal) console.log('Resolved imdb via TMDB:', imdbReal);
                  } catch (err) {
                    console.warn('Failed to resolve IMDB id from TMDB details', err);
                  }
                }

                if (!imdbReal) {
                  if (typeof showToast === 'function') showToast('error', 'Missing data', 'IMDB id not available for this series');
                  return;
                }

                const params = new URLSearchParams();
                params.append('imdb', imdbReal);
                params.append('imdbId', imdbReal);
                if (tmdbId) { params.append('movieId', tmdbId); params.append('tmdbId', tmdbId); }
                params.append('type', 'tv');
                params.append('season', seasonNum);
                params.append('episode', episodeNum);
                if (currentMovie && currentMovie.title) params.append('title', currentMovie.title);
                if (currentMovie && currentMovie.posterUrl) params.append('poster', currentMovie.posterUrl);

                // Debug: log final navigation URL and open
                try { console.log('Series â†’ player-2 URL (final):', `player-2.html?${params.toString()}`); } catch (_) { }
                try { if (typeof showToast === 'function') showToast('info', 'Opening player-2', 'Redirecting to NontonGo playerâ€¦'); } catch (_) { }
                localStorage.setItem('lastPlayerUsed', 'player2');
                // Store modal state for restoration on back
                const movieToStore = { ...currentMovie, selectedSeason: seasonNum, selectedEpisode: episodeNum };
                sessionStorage.setItem('restoreModal', JSON.stringify(movieToStore));
                window.location.href = `player-2.html?${params.toString()}`;
              } catch (err) { console.error('Series Play click handler error', err); }
            });
          }
          if (seriesPlayBtnPlayer) {
            seriesPlayBtnPlayer.disabled = true;
            seriesPlayBtnPlayer.addEventListener('click', function (e) {
              try {
                e.preventDefault();
                const tmdbId = currentMovie && (currentMovie.id || currentMovie.movieId || currentMovie.tmdbId);
                const imdbReal = currentMovie && (currentMovie.imdb_id || currentMovie.imdbId);
                if (!tmdbId && !imdbReal) {
                  if (typeof showToast === 'function') showToast('error', 'Missing data', 'No TMDB or IMDB id available for this series');
                  return;
                }
                const seasonNum = seasonSelect.value || document.getElementById('seasonSelect')?.value;
                const episodeNum = episodeSelect.value || document.getElementById('episodeSelect')?.value;
                if (!seasonNum || !episodeNum) {
                  if (typeof showToast === 'function') showToast('error', 'Select episode', 'Please select season and episode');
                  return;
                }
                const params = new URLSearchParams();
                if (imdbReal) { params.append('imdb', imdbReal); params.append('imdbId', imdbReal); }
                if (tmdbId) { params.append('movieId', tmdbId); params.append('tmdbId', tmdbId); try { console.log('Series â†’ tmdb id (player):', tmdbId); } catch (_) { } }
                params.append('preferTmdb', '1');
                params.append('type', 'tv');
                params.append('mediaType', 'tv');
                params.append('season', seasonNum);
                params.append('episode', episodeNum);
                if (currentMovie && currentMovie.title) params.append('title', currentMovie.title);
                if (currentMovie && currentMovie.posterUrl) params.append('poster', currentMovie.posterUrl);
                // Debug: log final navigation URL
                try { console.log('Series â†’ player URL:', `player.html?${params.toString()}`); } catch (_) { }
                try { if (typeof showToast === 'function') showToast('info', 'Opening player', 'Redirecting to playerâ€¦'); } catch (_) { }
                localStorage.setItem('lastPlayerUsed', 'player');
                // Store modal state for restoration on back
                const movieToStore = { ...currentMovie, selectedSeason: seasonNum, selectedEpisode: episodeNum };
                sessionStorage.setItem('restoreModal', JSON.stringify(movieToStore));
                window.location.href = `player.html?${params.toString()}`;
              } catch (err) { console.error('Series Play (Player) click handler error', err); }
            });
          }

          // Reuse top movie action buttons for series so placement matches movie modal.
          const topWatchBtn = document.getElementById('streamBtn');
          const topStream2Btn = document.getElementById('streamBtn2');
          const topStream3Btn = document.getElementById('streamBtn3');
          if (topWatchBtn) {
            topWatchBtn.disabled = true;
            topWatchBtn.onclick = function (e) {
              e.preventDefault();
              // Watch Now -> player.html for series
              if (seriesPlayBtnPlayer && !seriesPlayBtnPlayer.disabled) {
                seriesPlayBtnPlayer.click();
              } else if (typeof showToast === 'function') {
                showToast('error', 'Select episode', 'Please select season and episode');
              }
            };
          }
          if (topStream2Btn) {
            topStream2Btn.disabled = true;
            topStream2Btn.onclick = function (e) {
              e.preventDefault();
              // Stream 2 -> player-2.html for series
              if (seriesPlayBtn && !seriesPlayBtn.disabled) {
                seriesPlayBtn.click();
              } else if (typeof showToast === 'function') {
                showToast('error', 'Select episode', 'Please select season and episode');
              }
            };
          }
          if (topStream3Btn) {
            topStream3Btn.disabled = true;
            topStream3Btn.onclick = async function (e) {
              e.preventDefault();
              const seasonNum = seasonSelect.value || document.getElementById('seasonSelect')?.value;
              const episodeNum = episodeSelect.value || document.getElementById('episodeSelect')?.value;
              if (!seasonNum || !episodeNum) {
                if (typeof showToast === 'function') {
                  showToast('error', 'Select episode', 'Please select season and episode');
                }
                return;
              }

              let imdbReal = currentMovie && (currentMovie.imdb_id || currentMovie.imdbId);
              const tmdbId = currentMovie && (currentMovie.id || currentMovie.movieId || currentMovie.tmdbId);

              if (!imdbReal && tmdbId && typeof movieDb !== 'undefined' && typeof movieDb.getTVDetails === 'function') {
                try {
                  const details = await movieDb.getTVDetails(tmdbId);
                  imdbReal = details && (details.imdb_id || (details.external_ids && details.external_ids.imdb_id) || details.imdbId);
                } catch (_) { }
              }

              if (!imdbReal) {
                if (typeof showToast === 'function') {
                  showToast('error', 'Missing data', 'IMDB id not available for this series');
                }
                return;
              }

              const params = new URLSearchParams();
              params.append('imdb', imdbReal);
              params.append('type', 'tv');
              params.append('season', seasonNum);
              params.append('episode', episodeNum);
              if (tmdbId) { params.append('movieId', tmdbId); params.append('tmdbId', tmdbId); }
              if (currentMovie && currentMovie.title) params.append('title', currentMovie.title);
              if (currentMovie && currentMovie.posterUrl) params.append('poster', currentMovie.posterUrl);

              localStorage.setItem('lastPlayerUsed', 'player-8stream');
              const movieToStore = { ...currentMovie, selectedSeason: seasonNum, selectedEpisode: episodeNum };
              sessionStorage.setItem('restoreModal', JSON.stringify(movieToStore));
              window.location.href = `nontongoplayer.html?${params.toString()}`;
            };
          }

          // Debug helper: generate URLs for a given movie/season/episode
          try {
            window.debugSeriesPlayerUrl = function (movieObj, seasonNum, episodeNum) {
              try {
                const tmdbIdVal = movieObj && (movieObj.id || movieObj.movieId || movieObj.tmdbId);
                const imdbVal = movieObj && (movieObj.imdb_id || movieObj.imdbId);
                const p = new URLSearchParams();
                if (imdbVal) { p.append('imdb', imdbVal); p.append('imdbId', imdbVal); }
                if (tmdbIdVal) { p.append('movieId', tmdbIdVal); p.append('tmdbId', tmdbIdVal); }
                p.append('type', 'tv');
                p.append('season', seasonNum);
                p.append('episode', episodeNum);
                if (movieObj && movieObj.title) p.append('title', movieObj.title);
                if (movieObj && movieObj.posterUrl) p.append('poster', movieObj.posterUrl);
                return {
                  player2: `player-2.html?${p.toString()}`,
                  player: `player.html?${p.toString()}`
                };
              } catch (err) { console.error('debugSeriesPlayerUrl error', err); return null; }
            };
          } catch (_) { }
        } catch (e) { }
      }

      // ... existing code for setting up modal content ...
      const title = movie.title || 'Untitled';
      const year = movie.year || (movie.release_date ? movie.release_date.split('-')[0] : '');
      const modal = document.getElementById('movieModal');

      document.getElementById('modalTitle').innerText = title;
      document.getElementById('modalYear').innerText = year;
      document.getElementById('modalOverview').innerText = movie.overview || '';
      document.getElementById('modalRating').innerText = movie.rating ? movie.rating.toFixed(1) : 'N/A';
      document.getElementById('modalReleaseDate').innerText = movie.release_date || movie.first_air_date || 'Unknown';

      const directorEl = document.getElementById('modalDirector');
      const directorInfo = document.getElementById('directorInfo');
      const statusEl = document.getElementById('modalStatus');

      if (statusEl) statusEl.innerText = movie.status || 'Released';

      // Fetch more details (like director, status, and TRAILER)
      if (movie.id && window.movieDb) {
        (async () => {
          try {
            const details = isSeries
              ? await window.movieDb.getTVDetails(movie.id)
              : await window.movieDb.getMovieDetails(movie.id);

            const videos = isSeries
              ? await window.movieDb.getTVVideos(movie.id)
              : await window.movieDb.getMovieVideos(movie.id);

            // Improved trailer selection: Official Trailer > Trailer > Teaser
            const youtubeVideos = videos.filter(v => v.site === 'YouTube');
            let trailer = youtubeVideos.find(v => v.type === 'Trailer' && (v.name.toLowerCase().includes('official') || v.official === true));
            if (!trailer) trailer = youtubeVideos.find(v => v.type === 'Trailer');
            if (!trailer) trailer = youtubeVideos.find(v => v.type === 'Teaser');

            const trailerKey = trailer ? trailer.key : null;
            if (trailer) console.log('Selected trailer:', trailer.name, 'Type:', trailer.type);

            if (details) {
              if (statusEl) statusEl.innerText = details.status || (isSeries ? 'Returning Series' : 'Released');

              if (directorEl && !isSeries) {
                if (details.director) {
                  directorEl.innerText = details.director;
                  if (directorInfo) directorInfo.style.display = 'flex';
                } else {
                  if (directorInfo) directorInfo.style.display = 'none';
                }
              } else if (isSeries && directorInfo) {
                directorInfo.style.display = 'none';
              }
            }

            // Set up trailer playback
            const trailerContainer = document.getElementById('trailerContainer');
            const trailerPlayer = document.getElementById('trailerPlayer');
            const modalHero = document.getElementById('modalHero');
            const modalPoster = document.getElementById('modalPoster');
            const heroMeta = document.querySelector('.hero-meta');
            const closeTrailer = document.getElementById('closeTrailer');

            const resetModalUI = () => {
              trailerContainer.style.display = 'none';
              trailerContainer.style.zIndex = '2';
              trailerPlayer.innerHTML = '';
              const overlay = modalHero.querySelector('.play-overlay');
              if (overlay) overlay.style.display = 'flex';

              if (modalPoster) {
                modalPoster.style.opacity = '1';
                modalPoster.style.pointerEvents = 'auto';
                modalPoster.style.clipPath = 'inset(0% 0 0 0)';
              }

              if (heroMeta) {
                heroMeta.style.opacity = '1';
                heroMeta.style.pointerEvents = 'auto';
              }
            };

            const playTrailerAction = () => {
              if (trailerKey) {
                const isMobileDevice = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
                const overlay = modalHero.querySelector('.play-overlay');
                if (overlay) overlay.style.display = 'none';

                if (modalPoster) {
                  modalPoster.style.clipPath = 'inset(45% 0 0 0)';
                  modalPoster.style.transition = 'clip-path 0.5s ease, opacity 0.5s ease';
                  modalPoster.style.opacity = '0.9';
                }

                if (heroMeta) {
                  heroMeta.style.opacity = '0.2';
                  heroMeta.style.transition = 'opacity 0.6s ease';
                  heroMeta.style.pointerEvents = 'none';
                }

                trailerContainer.style.display = 'block';
                trailerContainer.style.zIndex = '20';

                const frameId = 'ytPlayer_' + Math.floor(Math.random() * 1000000);
                const currentOrigin = window.location.origin;
                const muteValue = isMobileDevice ? 1 : 0;
                trailerPlayer.innerHTML = `<iframe id="${frameId}" src="https://www.youtube.com/embed/${trailerKey}?autoplay=1&mute=${muteValue}&playsinline=1&rel=0&controls=1&enablejsapi=1&origin=${currentOrigin}&modestbranding=1&iv_load_policy=3&fs=1" allow="autoplay; encrypted-media; picture-in-picture; fullscreen" allowfullscreen playsinline referrerpolicy="origin"></iframe>`;

                const ytFrame = document.getElementById(frameId);
                if (ytFrame) {
                  ytFrame.addEventListener('load', () => {
                    try {
                      ytFrame.contentWindow.postMessage(
                        JSON.stringify({ event: 'command', func: 'playVideo', args: [] }),
                        '*'
                      );
                    } catch (_) { }
                  });
                }

                // More robust message receiver
                const endHandler = (event) => {
                  try {
                    if (!event.origin.includes('youtube')) return;
                    const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

                    if (data.event === 'onReady' || data.event === 'initialDelivery') {
                      ytFrame.contentWindow.postMessage(JSON.stringify({ event: 'listening', id: frameId }), '*');
                    }

                    // Check for ENDED state (State 0)
                    const isEnded = (data.event === 'onStateChange' && (data.info === 0 || data.args?.[0] === 0)) ||
                      (data.info && data.info.playerState === 0);

                    if (isEnded) {
                      resetModalUI();
                      window.removeEventListener('message', endHandler);
                    }
                  } catch (e) { }
                };
                if (activeTrailerMessageHandler) {
                  window.removeEventListener('message', activeTrailerMessageHandler);
                }
                activeTrailerMessageHandler = endHandler;
                window.addEventListener('message', endHandler);

              } else {
                showToast('info', 'No Trailer', 'Sorry, no YouTube trailer found for this title.');
              }
            };

            if (modalHero) modalHero.onclick = playTrailerAction;
            if (modalPoster) modalPoster.onclick = playTrailerAction;
            if (closeTrailer) {
              closeTrailer.onclick = (e) => {
                e.stopPropagation();
                resetModalUI();
                if (activeTrailerMessageHandler) {
                  window.removeEventListener('message', activeTrailerMessageHandler);
                  activeTrailerMessageHandler = null;
                }
              };
            }

          } catch (e) { console.error('Error fetching extra details:', e); }
        })();
      }

      const genresEl = document.getElementById('modalGenres');
      if (genresEl) {
        const list = Array.isArray(movie.genres) ? movie.genres : [];
        genresEl.innerHTML = list.map(g => `<span>${g}</span>`).join('');
      }

      // Populate hero background and poster thumbnail for the new modal-hero layout
      try {
        const heroBg = document.getElementById('modalHeroBg');
        const posterImgEl = document.getElementById('modalPosterImg');

        // Prefer backdrop if available, fall back to poster
        const backdrop = movie.backdropUrl || movie.backdrop_path || movie.backdrop || '';
        const posterSafe = (movie.posterUrl && !movie.posterUrl.includes('archive.org')) ? movie.posterUrl : (movie.poster_path ? movie.poster_path : (movie.poster || ''));

        if (heroBg) {
          heroBg.style.backgroundImage = backdrop ? `url(${backdrop})` : (posterSafe ? `url(${posterSafe})` : '');
        }
        if (posterImgEl) {
          posterImgEl.src = posterSafe || backdrop || '';
        }

        // Bookmark button text update
        const bookmarkText = document.querySelector('.bookmark-text');
        if (bookmarkText) {
          bookmarkText.innerText = 'Add to List';
        }

      } catch (_) { }

      // Show modal
      if (modal) {
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
      }

      // Stream availability: drive mapping OR MP4 OR streamUrl OR API resolver
      if (!isSeries && streamBtn) {
        const canResolve = typeof window.resolveStreamUrlForMovie === 'function';
        const hasStream = !!(driveMovieMappings[String(movie.id)] || getMp4Override(title) || movie.streamUrl || canResolve);
        streamBtn.dataset.movieId = movie.id;
        streamBtn.dataset.available = hasStream ? '1' : '0';
        streamBtn.querySelector('span').textContent = 'Watch Now';
        streamBtn.classList.toggle('unavailable', !hasStream);
        streamBtn.disabled = false;
      }

      // Keep movie-style action buttons visible for both movies and series.
      const streamBtn2El = document.getElementById('streamBtn2');
      const streamBtn3El = document.getElementById('streamBtn3');
      if (streamBtn2El) streamBtn2El.style.display = '';
      if (streamBtn3El) streamBtn3El.style.display = '';

      // Update bookmark button state - now async
      const bookmarkBtn = document.getElementById('bookmarkBtn');
      if (bookmarkBtn) {
        isBookmarked(movie.id).then(bookmarked => {
          bookmarkBtn.classList.toggle('bookmarked', bookmarked);
          bookmarkBtn.title = bookmarked ? 'Remove from My List' : 'Add to My List';

          const icon = bookmarkBtn.querySelector('i');
          if (icon) icon.className = bookmarked ? 'fas fa-bookmark' : 'far fa-bookmark';

          const textSpan = bookmarkBtn.querySelector('.bookmark-text');
          if (textSpan) textSpan.textContent = bookmarked ? 'In My List' : 'Add to List';
        });
      }
    }


    // Video player controls and touch gestures
    let hideControlsTimeout;
    const HIDE_CONTROLS_DELAY = 3000; // 3 seconds

    // Save video progress to localStorage
    function saveVideoProgress(video, movieId, title, posterUrl) {
      if (!video || !movieId) return;

      const progress = (video.currentTime / video.duration) * 100;

      // Only save if video has been watched for at least 5 seconds and less than 95%
      if (video.currentTime > 5 && progress < 95) {
        const continueWatching = JSON.parse(localStorage.getItem('continueWatching') || '{}');

        continueWatching[movieId] = {
          id: movieId,
          title: title || 'Untitled',
          poster: posterUrl || '',
          progress: progress,
          currentTime: video.currentTime,
          duration: video.duration,
          timestamp: Date.now()
        };

        // Clean up old entries (keep only the 20 most recent)
        const entries = Object.entries(continueWatching)
          .sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0))
          .slice(0, 20);

        const cleanedContinueWatching = {};
        entries.forEach(([id, data]) => {
          cleanedContinueWatching[id] = data;
        });

        localStorage.setItem('continueWatching', JSON.stringify(cleanedContinueWatching));
      }
    }

    // Load saved progress for a video
    function loadVideoProgress(video, movieId) {
      if (!video || !movieId) return;

      const continueWatching = JSON.parse(localStorage.getItem('continueWatching') || '{}');
      const savedProgress = continueWatching[movieId];

      if (savedProgress && savedProgress.currentTime && savedProgress.duration) {
        // Only resume if there's significant progress (at least 5 seconds)
        if (savedProgress.currentTime > 5 && savedProgress.progress < 95) {
          // Set a flag to prevent multiple timeupdate events during initial seek
          video.dataset.seeking = 'true';

          // Set the video time to the saved position
          video.currentTime = savedProgress.currentTime;

          // Update the progress bar
          updateProgressBar(video);

          // Show a 'resuming from...' notification
          showNotification(`Resuming from ${Math.round(savedProgress.progress)}%`);

          // Remove the seeking flag after a short delay
          setTimeout(() => {
            delete video.dataset.seeking;
          }, 1000);
        }
      }
    }

    // Update progress bar
    function updateProgressBar(video) {
      const progressBar = document.querySelector('.video-progress-bar');
      if (progressBar) {
        const progress = (video.currentTime / video.duration) * 100;
        progressBar.style.width = `${progress}%`;
      }
    }

    function setupVideoPlayer(video) {
      if (!video) return;

      // Get movie ID from the video element or its parent
      const movieCard = video.closest('.movie-card');
      const movieId = movieCard ? movieCard.dataset.movieId : null;
      const movieTitle = movieCard ? movieCard.dataset.title : 'Untitled';
      const posterUrl = movieCard ? movieCard.dataset.poster : '';

      // Load saved progress
      if (movieId) {
        loadVideoProgress(video, movieId);
      }

      // Auto-hide controls in fullscreen
      const controls = video.parentElement.querySelector('.video-controls');

      function showControls() {
        if (controls) controls.style.opacity = '1';
        resetHideControlsTimeout();
      }

      function hideControls() {
        if (document.fullscreenElement && controls) {
          controls.style.opacity = '0';
        }
      }

      function resetHideControlsTimeout() {
        clearTimeout(hideControlsTimeout);
        if (document.fullscreenElement) {
          hideControlsTimeout = setTimeout(hideControls, HIDE_CONTROLS_DELAY);
        }
      }

      // Touch event handlers for double tap
      let lastTap = 0;
      let tapTimeout;

      video.addEventListener('touchend', function (e) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;

        clearTimeout(tapTimeout);

        if (tapLength < 300 && tapLength > 0) {
          // Double tap detected
          const rect = video.getBoundingClientRect();
          const tapX = e.changedTouches[0].clientX - rect.left;
          const tapPosition = tapX / rect.width;

          if (tapPosition > 0.7) {
            // Right side - skip forward 10s
            video.currentTime = Math.min(video.duration, video.currentTime + 10);
          } else if (tapPosition < 0.3) {
            // Left side - rewind 10s
            video.currentTime = Math.max(0, video.currentTime - 10);
          }

          // Show feedback
          showControls();
        } else {
          tapTimeout = setTimeout(() => {
            clearTimeout(tapTimeout);
          }, 300);
        }

        lastTap = currentTime;
      });

      // Show controls on interaction
      ['mousemove', 'touchmove', 'click'].forEach(event => {
        video.addEventListener(event, showControls);
      });

      // Fullscreen change handler
      document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement) {
          showControls();
        } else if (controls) {
          controls.style.opacity = '1';
        }
      });

      // Update progress bar and save progress as video plays
      video.addEventListener('timeupdate', () => {
        // Only update if not currently seeking
        if (!video.dataset.seeking) {
          updateProgressBar(video);

          // Save progress every 5 seconds
          if (movieId && Math.floor(video.currentTime) % 5 === 0) {
            saveVideoProgress(video, movieId, movieTitle, posterUrl);
          }
        }
      });

      // Save final progress when video ends
      video.addEventListener('ended', () => {
        if (movieId) {
          saveVideoProgress(video, movieId, movieTitle, posterUrl);
        }
      });

      // Handle seeking
      video.addEventListener('seeking', () => {
        video.dataset.seeking = 'true';
      });

      video.addEventListener('seeked', () => {
        delete video.dataset.seeking;
        if (movieId) {
          saveVideoProgress(video, movieId, movieTitle, posterUrl);
        }
      });
    }

    // Check if device is in portrait mode
    function isPortraitMode() {
      return window.matchMedia("(orientation: portrait)").matches;
    }

    // Request landscape orientation
    async function requestLandscape() {
      try {
        if (screen.orientation && screen.orientation.lock) {
          await screen.orientation.lock('landscape');
        } else if (screen.lockOrientation) {
          screen.lockOrientation('landscape');
        } else if (screen.mozLockOrientation) {
          screen.mozLockOrientation('landscape');
        } else if (screen.msLockOrientation) {
          screen.msLockOrientation('landscape');
        }
      } catch (err) {
        console.warn('Failed to lock orientation:', err);
      }
    }

    // Stream behavior - open player in the same tab
    streamBtn.addEventListener('click', (e) => {
      e.preventDefault();
      if (!currentMovie) return showToast('error', 'No Movie', 'No movie selected.');
      if (currentMovie && (currentMovie.mediaType === 'tv' || currentMovie.type === 'series' || currentMovie.isSeries)) {
        // Series uses dedicated handlers wired in openMovieModal.
        return;
      }

      const isAvailable = streamBtn.dataset.available === '1';
      if (!isAvailable) {
        showToast('error', 'Stream Unavailable', 'This stream is not available currently!');
        return;
      }
      // ...existing code for opening the player...
      // Pause any playing YouTube trailer
      if (ytPlayer) {
        try {
          ytPlayer.pauseVideo();
        } catch (e) { }
      }
      // Pause any playing HTML5 video trailer
      const trailerHost = document.getElementById('trailerHost');
      if (trailerHost) {
        const video = trailerHost.querySelector('video');
        if (video && !video.paused) {
          video.pause();
        }
      }
      // Check if in portrait mode and request landscape
      if (isPortraitMode()) {
        requestLandscape().catch(console.error);
      }

      // Get movie details
      const movieId = String(currentMovie.id);
      const title = encodeURIComponent(currentMovie.title || '');
      const poster = encodeURIComponent(currentMovie.posterUrl || '');
      // Check for watch progress (prefer manager, then legacy storage)
      let resumeSeconds = 0;
      try {
        const mgr = window.ContinueWatchingManager;
        const mgrProgress = mgr && typeof mgr.getMovieProgress === 'function' ? mgr.getMovieProgress(movieId) : null;
        if (mgrProgress && Number(mgrProgress.currentTime) > 0) {
          resumeSeconds = Number(mgrProgress.currentTime);
        }
      } catch (_) { }

      if (resumeSeconds <= 0) {
        const watchData = JSON.parse(localStorage.getItem('watchProgress') || '{}');
        const hasProgress = watchData[movieId] && watchData[movieId].progress > 0;
        if (hasProgress) {
          resumeSeconds = Math.floor((watchData[movieId].duration * watchData[movieId].progress) / 100);
        }
      }
      // Build the player URL with the current movie's details
      const params = new URLSearchParams();
      params.append('id', movieId);
      params.append('movieId', movieId);
      params.append('title', currentMovie.title);
      if (currentMovie.posterUrl) params.append('poster', currentMovie.posterUrl);

      // Check for available sources in order of preference
      const normTitle = String(currentMovie.title || '').trim().toLowerCase();
      let playerUrl = null;

      // 1) Check for direct MP4 override
      const mp4Url = getMp4Override(currentMovie.title);
      if (mp4Url) {
        const isHls = /\.m3u8(\?.*)?$/.test(mp4Url);
        params.append('type', isHls ? 'hls' : 'mp4');
        params.append('src', mp4Url);
        playerUrl = `player.html?${params.toString()}`;
      }
      // 2) Check for Google Drive mapping
      else if (driveMovieMappings[movieId]) {
        params.append('type', 'drive');
        params.append('id', driveMovieMappings[movieId]);
        playerUrl = `player.html?${params.toString()}`;
      }
      // 3) Check for direct stream URL
      else if (currentMovie.streamUrl) {
        const isHls = /\.m3u8(\?.*)?$/.test(currentMovie.streamUrl);
        params.append('type', isHls ? 'hls' : 'mp4');
        params.append('src', currentMovie.streamUrl);
        playerUrl = `player.html?${params.toString()}`;
      } else {
        // Resolve on-demand from hero section
        const heroStreamBtn = document.getElementById('heroStreamBtn') || document.querySelector('[data-hero-stream-btn]');
        if (heroStreamBtn) {
          heroStreamBtn.textContent = 'Resolvingâ€¦';
          heroStreamBtn.disabled = true;
        }
        (async () => {
          try {
            const result = await window.resolveStreamUrlForMovie(currentMovie, ['English', 'Hindi', 'Tamil', 'Telugu', 'Bengali']);
            if (result && result.success && result.src) {
              const isHls2 = /\.m3u8(\?.*)?$/.test(result.src) || result.type === 'hls';
              params.append('type', isHls2 ? 'hls' : (result.type || 'mp4'));
              params.append('src', result.src);
              if (result.imdbId) params.append('imdbId', result.imdbId);
              if (result.key) params.append('streamKey', result.key);
              if (result.language) params.append('currentLang', result.language);
              if (result.availableLanguages) params.append('availableLangs', JSON.stringify(result.availableLanguages));
              if (result.languageInfo) params.append('languageInfo', JSON.stringify(result.languageInfo));
              playerUrl = `player.html?${params.toString()}`;
              const finalUrl = resumeSeconds > 0 ? `${playerUrl}&t=${Math.floor(resumeSeconds)}` : playerUrl;
              // Store modal state for restoration on back
              sessionStorage.setItem('restoreModal', JSON.stringify(currentMovie));
              window.location.href = finalUrl;
            } else {
              const errorMsg = result?.message || 'Could not resolve a stream for this title.';
              console.warn('Hero stream resolution failed:', errorMsg);
              showToast('error', 'Stream Resolution Failed', errorMsg);
            }
          } catch (e) {
            console.error('Hero stream resolve failed:', e);
            showToast('error', 'Stream Error', 'Failed to resolve stream: ' + (e?.message || 'Unknown error'));
          } finally {
            const heroStreamBtn = document.getElementById('heroStreamBtn') || document.querySelector('[data-hero-stream-btn]');
            if (heroStreamBtn) {
              heroStreamBtn.textContent = 'Stream';
              heroStreamBtn.disabled = false;
            }
          }
        })();
        return; // Don't fall through to the playerUrl check below
      }

      if (playerUrl) {
        // Append resume time only if we have it to trigger prompt/resume
        const finalUrl = resumeSeconds > 0 ? `${playerUrl}&t=${Math.floor(resumeSeconds)}` : playerUrl;
        // Store modal state for restoration on back
        sessionStorage.setItem('restoreModal', JSON.stringify(currentMovie));
        window.location.href = finalUrl;
      } else {
        showToast('error', 'No Stream', 'Stream is not available for this movie yet.');
      }
    });

    // Prefetch player pages so first playback starts faster
    function warmupPlayerPages() {
      const head = document.head || document.getElementsByTagName('head')[0];
      const targets = [
        { href: 'player.html', as: 'document' },
        { href: 'nontongoplayer.html', as: 'document' },
        { href: 'js/player-continue-watching.js', as: 'script' },
        { href: 'js/continue-watching-display.js', as: 'script' }
      ];

      targets.forEach(({ href, as }) => {
        if (document.querySelector(`link[rel="prefetch"][href="${href}"]`)) return;
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = href;
        if (as) link.as = as;
        head.appendChild(link);
      });
    }

    function schedulePlayerWarmup() {
      const run = () => warmupPlayerPages();
      if ('requestIdleCallback' in window) {
        requestIdleCallback(run, { timeout: 2000 });
      } else {
        setTimeout(run, 1000);
      }
    }

    // Toast helper
    function showToast(type, title, message, timeout = 4000) {
      const container = document.getElementById('toastContainer');
      if (!container) return;
      const toast = document.createElement('div');
      const t = type || 'info';
      toast.className = `toast ${t}`;
      toast.setAttribute('role', 'status');
      const icons = {
        info: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#60a5fa"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm0 5.5a1.25 1.25 0 1 1 0 2.5 1.25 1.25 0 0 1 0-2.5Zm1.5 11h-3v-1.5h1v-5h-1V10h2v7.5h1V18.5Z"/></svg>',
        success: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#34d399"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm-1.1 13.6-3.9-3.9 1.4-1.4 2.5 2.5 5.2-5.2 1.4 1.4-6.6 6.6Z"/></svg>',
        warning: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#fbbf24"><path d="M12.87 3.5a1.5 1.5 0 0 0-2.74 0L2.3 18.2A1.5 1.5 0 0 0 3.63 20.4h16.74a1.5 1.5 0 0 0 1.33-2.2L12.87 3.5ZM11 9h2v5h-2V9Zm0 6h2v2h-2v-2Z"/></svg>',
        error: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#f87171"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm3.5 12.09-1.41 1.41L12 13.41l-2.09 2.09-1.41-1.41L10.59 12 8.5 9.91l1.41-1.41L12 10.59l2.09-2.09 1.41 1.41L13.41 12l2.09 2.09Z"/></svg>'
      };
      const iconSvg = icons[t] || icons.info;
      toast.innerHTML = `
        <div class="icon" aria-hidden="true">${iconSvg}</div>
        <div style="display:flex; flex-direction:column; gap:2px;">
          <div class="title">${title || ''}</div>
          <div class="msg">${message || ''}</div>
        </div>
        <button class="close" aria-label="Close" title="Close">Ã—</button>
      `;
      const closeBtn = toast.querySelector('.close');
      closeBtn.addEventListener('click', () => toast.remove());
      container.appendChild(toast);
      if (timeout > 0) {
        setTimeout(() => { try { toast.remove(); } catch (e) { } }, timeout);
      }
    }

    // Set scroll restoration to manual to prevent browser interference
    if (history.scrollRestoration) {
      history.scrollRestoration = 'manual';
    }
    window.scrollTo(0, 0);

    // Load continue watching when the page loads
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize theme first (fallback until auth/profile resolves)
      const key = getScopedThemeKey();
      const savedTheme = localStorage.getItem(key) || 'glossy';
      applyTheme(savedTheme);
      schedulePlayerWarmup();

      // Load continue watching after a short delay to ensure DOM is ready
      // Use Firebase-backed loader only.
      /*
      setTimeout(() => {
        console.log('DOM fully loaded, loading continue watching...');
        loadContinueWatching();

        // Wire up Clear All button
        const clearBtn = document.getElementById('cwClearAll');
        if (clearBtn) {
          clearBtn.addEventListener('click', async () => {
            try {
              clearBtn.disabled = true;
              clearBtn.style.opacity = '0.7';
              if (!window.FirebaseSync || typeof window.FirebaseSync.clearContinueWatching !== 'function') {
                console.warn('FirebaseSync.clearContinueWatching not available');
                return;
              }
              const ok = await window.FirebaseSync.clearContinueWatching();
              if (ok) {
                await loadContinueWatching(true);
              }
            } finally {
              clearBtn.disabled = false;
              clearBtn.style.opacity = '1';
            }
          });
        }

        // Also listen for continue watching updates from other tabs/windows
        window.addEventListener('storage', (e) => {
          if (e.key === 'continueWatching') {
            loadContinueWatching();
          }
        });

        // Dispatch a custom event to notify that continue watching is loaded
        document.dispatchEvent(new CustomEvent('continueWatchingLoaded'));
      }, 100);
      */
    });

    // (Removed duplicate unconditional streamBtn click handler that always showed the error message)

    // Lazy-load trailer iframe when placeholder is clicked
    document.addEventListener('click', (e) => {
      const host = e.target.closest && e.target.closest('#trailerHost');
      if (!host) return;
      // If a player is already present and visible, do nothing
      if (host.querySelector('iframe') || host.querySelector('div[id^="yt-player-"]')) return;

      const mp4Url = host.dataset.mp4Url;
      const key = host.dataset.youtubeKey;

      if (mp4Url) {
        // Create video player directly (don't preload)
        host.innerHTML = `
          <video id="trailerVideo" class="video-player" controls style="width:100%;height:100%;background:#000;" crossorigin="anonymous">
            <source src="${mp4Url}" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        `;

        let video = host.querySelector('#trailerVideo');
        let retryCount = 0;
        const maxRetries = 3;

        function createRetryButton() {
          const retryBtn = document.createElement('button');
          retryBtn.style = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:15px 30px;background:#ff6b6b;border:none;border-radius:8px;color:#fff;font-size:1rem;cursor:pointer;z-index:100;';
          retryBtn.textContent = `Retry Loading (${retryCount + 1}/${maxRetries})`;
          retryBtn.onclick = (e) => {
            e.stopPropagation();
            retryCount++;
            if (retryCount <= maxRetries) {
              retryBtn.remove();
              video.load();
              showSpinner();
            } else {
              retryBtn.textContent = 'Failed to load trailer';
              retryBtn.disabled = true;
            }
          };
          return retryBtn;
        }
        // Add spinner for trailer buffering
        let spinner = host.querySelector('.trailer-loading-spinner');
        if (!spinner) {
          spinner = document.createElement('div');
          spinner.className = 'trailer-loading-spinner';
          spinner.style = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:1000;width:48px;height:48px;border:6px solid #fff;border-top:6px solid #888;border-radius:50%;animation:spin 1s linear infinite;display:none;';
          host.appendChild(spinner);
        }
        function showSpinner() {
          spinner.style.display = 'block';
          console.log('Trailer loading...');
        }
        function hideSpinner() {
          spinner.style.display = 'none';
          console.log('Trailer loaded');
        }

        // Add timeout for stuck loading
        let loadingTimeout;
        let hasStartedLoading = false;

        // Attach spinner events
        setTimeout(() => {
          let v = host.querySelector('video');
          if (v) {
            // Track if video has started loading data
            v.addEventListener('loadstart', () => {
              hasStartedLoading = true;
              clearTimeout(loadingTimeout);
              showSpinner();
              console.log('Trailer: Video data started loading');
            });

            v.addEventListener('waiting', () => {
              showSpinner();
              // Set timeout to show warning if loading takes too long
              clearTimeout(loadingTimeout);
              loadingTimeout = setTimeout(() => {
                if (spinner.style.display === 'block' && hasStartedLoading) {
                  // Show retry button on timeout
                  hideSpinner();
                  if (retryCount < maxRetries) {
                    const retryBtn = createRetryButton();
                    host.appendChild(retryBtn);
                  } else {
                    const errorMsg = document.createElement('div');
                    errorMsg.style = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,0.8);padding:20px;border-radius:8px;text-align:center;max-width:80%;z-index:100;';
                    errorMsg.innerHTML = `<p>Trailer is loading very slowly.</p><p style="font-size:0.85em;opacity:0.7;margin-top:8px;">Maximum retry attempts reached. Please try again later.</p>`;
                    host.appendChild(errorMsg);
                    setTimeout(() => errorMsg.remove(), 5000);
                  }
                }
              }, 15000); // 15 second timeout for slow connections
            });
            v.addEventListener('seeking', showSpinner);
            v.addEventListener('stalled', showSpinner);
            v.addEventListener('playing', () => {
              clearTimeout(loadingTimeout);
              hideSpinner();
              console.log('Trailer: Video playing');
            });
            v.addEventListener('canplay', () => {
              clearTimeout(loadingTimeout);
              hideSpinner();
              console.log('Trailer: Video ready to play');
            });
            v.addEventListener('canplaythrough', () => {
              clearTimeout(loadingTimeout);
              hideSpinner();
              console.log('Trailer: Video can play through');
            });
            v.addEventListener('ended', hideSpinner);

            // Handle video errors
            v.addEventListener('error', function (e) {
              console.error('Trailer video error:', e, v.error);
              clearTimeout(loadingTimeout);
              hideSpinner();

              // Show retry button if retries available
              if (retryCount < maxRetries) {
                const retryBtn = createRetryButton();
                host.appendChild(retryBtn);
              } else {
                // Show error message after max retries
                const errorMsg = document.createElement('div');
                errorMsg.style = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,0.8);padding:20px;border-radius:8px;text-align:center;max-width:80%;z-index:100;';
                let errorDetails = 'The video file may not be available or there was a network error.';
                if (v.error) {
                  switch (v.error.code) {
                    case 1: errorDetails = 'Video loading was aborted.'; break;
                    case 2: errorDetails = 'Network error occurred while loading the video.'; break;
                    case 3: errorDetails = 'Video decoding failed.'; break;
                    case 4: errorDetails = 'Video format is not supported.'; break;
                  }
                }
                errorMsg.innerHTML = `<p>Unable to load trailer video.</p><p style="font-size:0.85em;opacity:0.7;margin-top:8px;">${errorDetails}</p>`;
                host.appendChild(errorMsg);
              }
            });

            // On mobile/landscape, reload and play after seek
            v.addEventListener('seeked', function () {
              if ((window.innerWidth <= 900 && window.matchMedia('(orientation: landscape)').matches) || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                // Only reload if not already loading
                if (v.readyState < 2) v.load();
                if (v.paused) {
                  const playPromise = v.play();
                  if (playPromise !== undefined) { playPromise.catch(() => { }); }
                }
              }
            });
          }

        }, 100);
      } else if (key) {
        createYTPlayerFor(host, key);
      } else {
        alert('Trailer not available.');
      }
    });

    // Click outside modal to close (backdrop)
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeModalBtn.click();
      }
    });

    // ESC to close
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && modal.style.display === 'flex') {
        closeModalBtn.click();
      }
    });

    // Search
    function searchLocalMovies(query) {
      const q = query.trim().toLowerCase();
      if (!q) return curatedMovies.slice();
      return curatedMovies.filter(m => {
        return (m.title || '').toLowerCase().includes(q) || (m.genres || []).some(g => g.toLowerCase().includes(q)) || String(m.year).includes(q);
      });
    }

    function syncSearchHomeButtonVisibility() {
      if (!searchComponentEl || !searchInput) return;
      const hasQuery = Boolean(searchInput.value && searchInput.value.trim());
      if (hasQuery && document.body.classList.contains('searching')) {
        searchComponentEl.classList.add('has-results');
      } else {
        searchComponentEl.classList.remove('has-results');
      }
    }

    function performSearch() {
      const query = searchInput.value.trim();
      const popularSection = document.getElementById('popularMoviesSection');
      const popularTVSection = document.getElementById('popularTVSection');
      const featuredHero = document.getElementById('featuredHero');
      const categoryBarMount = document.getElementById('categoryBarMount');
      const cwSection = document.getElementById('continueWatchingSection');

      // Update URL with search parameter
      updateURLState({ category: null, search: query || null });

      if (!query) {
        // If search is empty, show all movies with continue watching
        document.body.classList.remove('searching');
        isSearching = false;

        if (popularSection) popularSection.style.display = '';
        if (popularTVSection) popularTVSection.style.display = '';
        if (featuredHero) featuredHero.style.display = 'flex';
        if (categoryBarMount) categoryBarMount.style.display = '';
        if (cwSection) {
          const hasCards = !!cwSection.querySelector('.continue-watching-card');
          cwSection.style.display = hasCards ? '' : 'none';
        }
        if (typeof window.loadContinueWatching === 'function') {
          setTimeout(() => window.loadContinueWatching(true), 0);
        }

        // Delegate to TMDB if enabled
        if (useTMDBCatalog && typeof loadAllTMDBMovies === 'function') {
          loadAllTMDBMovies().then(movies => displayMovies(movies, false, 'All Movies'));
        } else {
          displayMovies(curatedMovies, false);
        }

        if (featuredHeroRotationList.length > 0) {
          const currentIdx = Math.max(0, featuredHeroRotationIndex - 1);
          const currentMovie = featuredHeroRotationList[currentIdx] || featuredHeroRotationList[0];
          if (currentMovie) populateFeaturedHero(currentMovie);
          if (featuredHeroRotationList.length > 1 && !featuredHeroRotationTimer) {
            scheduleNextFeaturedHeroTick();
          }
        }
        syncSearchHomeButtonVisibility();
        return;
      }

      // Add searching class to body
      document.body.classList.add('searching');
      isSearching = true;
      stopFeaturedHeroRotation();

      // Hide all non-search sections
      if (popularSection) popularSection.style.display = 'none';
      if (popularTVSection) popularTVSection.style.display = 'none';
      if (featuredHero) featuredHero.style.display = 'none';
      if (categoryBarMount) categoryBarMount.style.display = 'none';
      if (cwSection) cwSection.style.display = 'none';

      // Delegate search to TMDB when enabled
      if (useTMDBCatalog && typeof searchTMDB === 'function') {
        searchTMDB(query);
        syncSearchHomeButtonVisibility();
        return;
      }

      // Perform local search
      const results = searchLocalMovies(query);

      if (results.length === 0) {
        showToast('info', 'No Results', 'No matching movies found in the curated list.', 3000);
        displayMovies([], true, `No results for "${query}"`);
        syncSearchHomeButtonVisibility();
        return;
      }

      // Display only search results
      displayMovies(results, true, `Search Results for "${query}"`);
      syncSearchHomeButtonVisibility();
    }

    searchBtn.addEventListener('click', (e) => {
      const searchComponent = document.getElementById('searchComponent');
      if (searchComponent && !searchComponent.classList.contains('expanded')) {
        e.preventDefault();
        return;
      }
      performSearch();
    });
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        performSearch();
      }
    });

    // Live search with debounce
    let searchTimeout;
    searchInput.addEventListener('input', () => {
      syncSearchHomeButtonVisibility();
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        performSearch();
      }, 300);
    });

    // Close modal: stop playback and remove iframe to free resources
    closeModalBtn.addEventListener('click', () => {
      modal.classList.remove('playing');
      modal.style.display = 'none';
      // Restore scroll position to where user was (skip on initial page load)
      if (!window.initialPageLoad) window.scrollTo(0, savedScrollPosition);
      // Restore background scrolling when modal closes
      document.body.style.overflow = '';
      // Re-enable theme switch
      (function () {
        const ts = document.getElementById('themeSwitch');
        if (ts) {
          ts.style.pointerEvents = '';
          ts.style.opacity = '';
          ts.removeAttribute('aria-disabled');
          const prev = ts.getAttribute('data-prev-tabindex');
          if (prev !== null) {
            if (prev === '') ts.removeAttribute('tabindex');
            else ts.setAttribute('tabindex', prev);
          } else {
            ts.removeAttribute('tabindex');
          }
        }
      })();
      const trailerHost = document.getElementById('trailerHost');
      if (trailerHost) {
        // Stop and remove video element if present
        const video = trailerHost.querySelector('video');
        if (video) {
          video.pause();
          video.src = '';
        }
        // destroy YT player if present
        try {
          if (ytPlayer) { ytPlayer.stopVideo(); ytPlayer.destroy(); }
        } catch (e) { }
        ytPlayer = null;
        // restore placeholder structure
        trailerHost.innerHTML = '<img id="trailerPlaceholderImg" src="" alt="Trailer preview" /><div class="video-play-btn" title="Play trailer"></div>';
        trailerHost.style.willChange = '';
        trailerHost.style.transform = '';
      }

      // Stop and hide our new YouTube trailer
      const trailerContainer = document.getElementById('trailerContainer');
      const trailerPlayer = document.getElementById('trailerPlayer');
      if (trailerContainer) trailerContainer.style.display = 'none';
      if (trailerPlayer) trailerPlayer.innerHTML = '';
    });

    // Bookmark button handler
    const bookmarkBtnEl = document.getElementById('bookmarkBtn');
    if (bookmarkBtnEl) {
      bookmarkBtnEl.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (!currentMovie) return;

        const bookmarked = await isBookmarked(currentMovie.id);
        console.log('Bookmark button clicked. Current state:', bookmarked, 'Movie:', currentMovie.id);

        if (bookmarked) {
          // Remove from bookmarks
          if (await removeBookmark(currentMovie.id)) {
            bookmarkBtnEl.classList.remove('bookmarked');
            bookmarkBtnEl.title = 'Add to My List';
            bookmarkBtnEl.setAttribute('aria-label', 'Add to My List');
            const icon = bookmarkBtnEl.querySelector('i');
            if (icon) icon.className = 'far fa-bookmark';
            const textSpan = bookmarkBtnEl.querySelector('.bookmark-text');
            if (textSpan) textSpan.textContent = 'Add to My List';
            showToast('info', 'Removed', `${currentMovie.title} removed from My List`, 2000);
          }
        } else {
          // Add to bookmarks
          if (await addBookmark(currentMovie)) {
            bookmarkBtnEl.classList.add('bookmarked');
            bookmarkBtnEl.title = 'Remove from My List';
            bookmarkBtnEl.setAttribute('aria-label', 'Remove from My List');
            const icon = bookmarkBtnEl.querySelector('i');
            if (icon) icon.className = 'fas fa-bookmark';
            const textSpan = bookmarkBtnEl.querySelector('.bookmark-text');
            if (textSpan) textSpan.textContent = 'In My List';
            showToast('success', 'Added', `${currentMovie.title} added to My List`, 2000);
          }
        }
      });
    }

    // Save watch progress
    function saveWatchProgress(movieId, progress, duration) {
      if (!movieId) return;

      const key = getContinueWatchingKey();
      const continueWatching = JSON.parse(localStorage.getItem(key) || '{}');

      // Only save if progress is between 1% and 95%
      if (progress > 1 && progress < 95) {
        const movie = continueWatching[movieId] || {};
        continueWatching[movieId] = {
          ...movie,
          movieId: movieId,
          progress: progress,
          timestamp: Date.now(),
          duration: duration
        };
        localStorage.setItem(key, JSON.stringify(continueWatching));

        // Update the UI if we're on the main page
        if (typeof loadContinueWatching === 'function') {
          loadContinueWatching();
        }
      } else if (progress >= 95) {
        // Remove if video is almost finished
        delete continueWatching[movieId];
        localStorage.setItem(key, JSON.stringify(continueWatching));
      }
    }

    // Initial load
    window.onload = async function () {
      applyPerMovieUrls();
      // Ensure the category bar is visible immediately
      mountCategoryBar();
      displayMovies(curatedMovies, false);
      // loadContinueWatching is now called after auth/profile is confirmed to avoid flicker
      setTimeout(async () => {
        console.log('SETTIMEOUT EXECUTING');
        console.log('Calling loadContinueWatching');
        await loadContinueWatching(true);
        console.log('Continue watching load completed');
      }, 0);

      // Check if there's a movie ID in the URL to open modal
      const urlParams = new URLSearchParams(window.location.search);
      const movieId = urlParams.get('movie');
      if (movieId) {
        // Find the movie in the curatedMovies array
        const movie = curatedMovies.find(m => m.id === movieId);
        if (movie) {
          // Open modal after a short delay to ensure everything is loaded
          setTimeout(() => {
            openMovieModal(movie);
          }, 500);
        }
      }

      // Initialize TMDB
      if (!movieDb) {
        initMovieDb();
      }
      if (typeof initializeTMDBIntegration === 'function') {
        await initializeTMDBIntegration();
      }

      // Restore category and search state from URL
      const categoryParam = urlParams.get('category');
      const searchParam = urlParams.get('search');
      const navEntries = performance.getEntriesByType && performance.getEntriesByType('navigation');
      const navType = navEntries && navEntries[0] ? navEntries[0].type : '';
      const isHardReload = navType === 'reload';

      // Set current category from URL
      currentCategory = categoryParam || 'all';

      // Ensure we start at the top after initial setup and allow normal scrolling afterwards
      // (forces page top even if browser tries to restore previous scroll)
      window.scrollTo({ top: 0, behavior: 'auto' });
      setTimeout(() => {
        // Allow the page to finish layout, then ensure we're at the top
        // Do NOT clear the initial-page flag here; it will be cleared after category refresh completes.
        window.scrollTo({ top: 0, behavior: 'auto' });
      }, 300);

      // Mount category bar with correct active state
      mountCategoryBar();

      // Also force scroll-to-top after full load (images/fonts may cause layout shifts)
      window.addEventListener('load', () => {
        window.scrollTo({ top: 0, behavior: 'auto' });
      });

      // Display initial content only if no category or search to restore
      if (!categoryParam && !searchParam) {
        displayMovies(curatedMovies, false);
      }

      // Restore modal state if returning from player
      try {
        const restoreModal = sessionStorage.getItem('restoreModal');
        if (restoreModal) {
          sessionStorage.removeItem('restoreModal');
          const movie = JSON.parse(restoreModal);
          if (window.openMovieModal) window.openMovieModal(movie);
        }
      } catch (e) { console.error('Failed to restore modal:', e); }

      if (searchParam && !isHardReload) {
        // Restore search state
        searchInput.value = searchParam;
        performSearch();
      } else if (isHardReload) {
        // On refresh, clear search state so the page starts fresh
        searchInput.value = '';
        document.body.classList.remove('searching');
        isSearching = false;
        updateURLState({ category: categoryParam || 'all', search: null });
        syncSearchHomeButtonVisibility();
      } else if (categoryParam && categoryParam !== 'all') {
        // Restore category state
        applyCategory(categoryParam);
      }
    };

    // Home button: reset to full curated list
    (function wireHomeButton() {
      const homeBtn = document.getElementById('homeBtn');
      if (!homeBtn) return;

      homeBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        // Clear search input and any active search state
        searchInput.value = '';
        document.body.classList.remove('searching');
        isSearching = false;
        syncSearchHomeButtonVisibility();

        const searchTop = document.getElementById('searchTop');
        if (searchTop) {
          searchTop.classList.remove('active');
        }

        // Clear URL state
        updateURLState({ category: 'all', search: null });

        // Show popular movies section
        const popularSection = document.getElementById('popularMoviesSection');
        const popularTVSection = document.getElementById('popularTVSection');
        if (popularSection) popularSection.style.display = '';
        if (popularTVSection) popularTVSection.style.display = '';

        // Reset category filter and show TMDB movies
        try { currentCategory = 'all'; } catch (_) { }
        mountCategoryBar();

        // Load and display TMDB movies if available
        if (typeof loadAllTMDBMovies === 'function' && typeof displayMovies === 'function') {
          const tmdbMovies = await loadAllTMDBMovies(3);
          if (tmdbMovies.length > 0) {
            displayMovies(tmdbMovies, false, 'All Movies');
          } else {
            displayMovies([], false, 'All Movies');
          }
        } else {
          displayMovies([], false, 'All Movies');
        }

        // Re-evaluate continue watching visibility based on actual stored data.
        if (typeof loadContinueWatching === 'function') {
          loadContinueWatching(true);
        }
      });

      homeBtn.addEventListener('click', () => {
        // close modal if open
        if (modal && modal.style.display === 'flex') {
          closeModalBtn.click();
        }
        // clear search
        if (searchInput) {
          searchInput.value = '';
          searchInput.dispatchEvent(new Event('input'));
        }
        syncSearchHomeButtonVisibility();
        // Clear URL state
        updateURLState({ category: 'all', search: null });
        // Show popular movies section
        const popularSection = document.getElementById('popularMoviesSection');
        const popularTVSection = document.getElementById('popularTVSection');
        if (popularSection) popularSection.style.display = '';
        if (popularTVSection) popularTVSection.style.display = '';

        // reset movies and category filter
        try { currentCategory = 'all'; } catch (_) { }
        mountCategoryBar();
        displayMovies(curatedMovies);
        // smooth scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    })();

    // Keep search-top visually 'active' when input is focused or contains text
    (function wireSearchActiveState() {
      const searchTop = document.getElementById('searchTop');
      const searchInputEl = document.getElementById('searchInput');

      function updateActive() {
        if (!searchTop || !searchInputEl) return;
        if (document.activeElement === searchInputEl || (searchInputEl.value && searchInputEl.value.trim() !== '')) {
          searchTop.classList.add('active');
        } else {
          searchTop.classList.remove('active');
        }
      }

      // focus/blur/value events
      searchInputEl.addEventListener('focus', updateActive);
      searchInputEl.addEventListener('blur', () => { setTimeout(updateActive, 0); });
      searchInputEl.addEventListener('input', updateActive);

      // If user clicks the search button while the input is empty, focus it instead
      const searchButton = document.getElementById('searchBtn');
      if (searchButton && searchInputEl) {
        searchButton.addEventListener('click', (e) => {
          // allow existing click handler above to run; but if input is empty, focus first
          if (!searchInputEl.value || searchInputEl.value.trim() === '') {
            e.preventDefault();
            searchInputEl.focus();
          }
        }, { capture: true });
      }

      // initialize state
      updateActive();
    })();

    // Search expand/collapse behavior: icon-only on left, expands on click
    (function wireSearchExpandBehavior() {
      const searchComponent = document.getElementById('searchComponent');
      const searchBtnEl = document.getElementById('searchBtn');
      const searchInputEl = document.getElementById('searchInput');
      if (!searchComponent || !searchBtnEl || !searchInputEl) return;

      function isExpanded() {
        return searchComponent.classList.contains('expanded');
      }

      function expandSearch() {
        if (isExpanded()) return;
        searchComponent.classList.add('expanded');
        setTimeout(() => {
          try { searchInputEl.focus({ preventScroll: true }); } catch (_) { searchInputEl.focus(); }
        }, 40);
      }

      function collapseSearch(force = false) {
        const hasText = (searchInputEl.value || '').trim().length > 0;
        if (!force && hasText) return;
        searchComponent.classList.remove('expanded');
      }

      // First click on icon opens search, second click performs search via existing handler
      searchBtnEl.addEventListener('click', (e) => {
        if (!isExpanded()) {
          e.preventDefault();
          e.stopPropagation();
          expandSearch();
        }
      }, { capture: true });

      // Focus should always open the input shell
      searchInputEl.addEventListener('focus', () => {
        searchComponent.classList.add('expanded');
      });

      // Click outside closes when no text
      document.addEventListener('click', (e) => {
        if (!searchComponent.contains(e.target)) {
          collapseSearch(false);
        }
      });

      // Escape collapses and clears focus
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isExpanded()) {
          collapseSearch(true);
          searchInputEl.blur();
        }
      });

      // Always start collapsed on load
      searchComponent.classList.remove('expanded');

      // Browser autofill may apply after initial paint; force collapsed once more
      requestAnimationFrame(() => {
        searchComponent.classList.remove('expanded');
      });
      setTimeout(() => {
        searchComponent.classList.remove('expanded');
      }, 120);
    })();

    (function setupHomepageFullscreenMode() {
      const isMobileLike = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.matchMedia('(pointer: coarse)').matches;
      if (!isMobileLike) return;

      let pseudoFullscreen = false;

      const isRealFullscreen = () => !!(
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement
      );

      const requestFullscreen = async () => {
        const el = document.documentElement;
        if (el.requestFullscreen) return el.requestFullscreen();
        if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
        if (el.mozRequestFullScreen) return el.mozRequestFullScreen();
        if (el.msRequestFullscreen) return el.msRequestFullscreen();
        throw new Error('Fullscreen API unavailable');
      };

      const exitFullscreen = async () => {
        if (document.exitFullscreen) return document.exitFullscreen();
        if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
        if (document.mozCancelFullScreen) return document.mozCancelFullScreen();
        if (document.msExitFullscreen) return document.msExitFullscreen();
      };

      const tryLockLandscape = async () => {
        try {
          if (screen.orientation && screen.orientation.lock) {
            await screen.orientation.lock('landscape');
          }
        } catch (_) { }
      };

      const tryUnlockOrientation = async () => {
        try {
          if (screen.orientation && screen.orientation.unlock) {
            screen.orientation.unlock();
          }
        } catch (_) { }
      };

      const isLandscape = () => window.matchMedia('(orientation: landscape)').matches;

      const enterPseudoFullscreen = () => {
        pseudoFullscreen = true;
        document.documentElement.classList.add('home-pseudo-fullscreen');
        document.body.classList.add('home-pseudo-fullscreen');
      };

      const exitPseudoFullscreen = () => {
        pseudoFullscreen = false;
        document.documentElement.classList.remove('home-pseudo-fullscreen');
        document.body.classList.remove('home-pseudo-fullscreen');
      };

      const enterLandscapeMode = async () => {
        enterPseudoFullscreen();
        await tryLockLandscape();
      };

      const exitLandscapeMode = async () => {
        exitPseudoFullscreen();
        if (isRealFullscreen()) {
          try { await exitFullscreen(); } catch (_) { }
        }
        await tryUnlockOrientation();
      };

      const syncAutomaticFullscreen = async () => {
        if (isLandscape()) {
          await enterLandscapeMode();
        } else {
          await exitLandscapeMode();
        }
      };

      const tryRealFullscreenFromGesture = async () => {
        if (!isLandscape() || isRealFullscreen()) return;
        try {
          await requestFullscreen();
          await tryLockLandscape();
        } catch (_) { }
      };

      document.addEventListener('pointerdown', tryRealFullscreenFromGesture, true);
      document.addEventListener('touchstart', tryRealFullscreenFromGesture, { passive: true, capture: true });
      document.addEventListener('click', tryRealFullscreenFromGesture, true);
      window.addEventListener('orientationchange', syncAutomaticFullscreen);
      window.addEventListener('resize', syncAutomaticFullscreen);

      syncAutomaticFullscreen();
    })();

    syncSearchHomeButtonVisibility();

    // Refresh continue watching when page becomes visible (after returning from player)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        console.log('Page became visible, refreshing continue watching...');
        // Clear FirebaseSync cache for continue watching to force fresh load from Firestore
        if (window.FirebaseSync && window.FirebaseSync.cache) {
          delete window.FirebaseSync.cache['continueWatching'];
        }
        if (typeof loadContinueWatching === 'function') {
          loadContinueWatching();
        }
      }
    });

    // Dark/Light mode removed â€“ site now uses saved Settings theme only
  </script>
  <!-- Firebase compat SDKs + App auth helpers -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="public/firebaseConfig.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
  <script src="public/emailConfig.js"></script>
  <script>
    if (window.emailjs && window.EMAILJS && window.EMAILJS.publicKey) {
      window.emailjs.init(window.EMAILJS.publicKey);
    }
  </script>
  <script src="auth-firebase.js?v=3"></script>
  <script src="firebase-sync.js"></script>
  <script src="storage-adapter.js"></script>
  <script src="ui.js"></script>
  <script>
    // Particle background functionality
    function createParticles() {
      const container = document.getElementById('particles');
      if (!container) return;

      // Clear existing particles
      container.innerHTML = '';

      // Get current theme colors
      const style = getComputedStyle(document.documentElement);
      const color1 = style.getPropertyValue('--particle-color-1').trim() || '#ff6b6b';
      const color2 = style.getPropertyValue('--particle-color-2').trim() || '#6b66ff';

      // Create 50-70 particles for a denser effect
      const particleCount = Math.floor(Math.random() * 21) + 50; // 50-70 particles

      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';

        // Slightly smaller size range for more particles (4-10px)
        const size = Math.random() * 6 + 4;

        // Random position
        const posX = Math.random() * 100;
        const posY = Math.random() * 100;

        // Random animation duration
        const duration = Math.random() * 20 + 10; // 10-30s
        const delay = Math.random() * -20; // Start at random times

        // Increased opacity for brighter particles
        const opacity = Math.random() * 0.4 + 0.4; // 0.4-0.8 (brighter range)

        // Randomly choose between the two theme colors with higher brightness
        const color = Math.random() > 0.5 ?
          color1.replace('rgb', 'rgba').replace(')', ', 0.8)') :
          color2.replace('rgb', 'rgba').replace(')', ', 0.8)');

        // Apply enhanced styles for brightness and glow
        Object.assign(particle.style, {
          width: `${size}px`,
          height: `${size}px`,
          left: `${posX}%`,
          top: `${posY}%`,
          animationDuration: `${duration}s`,
          animationDelay: `${delay}s`,
          opacity: opacity,
          background: `radial-gradient(circle at center, white 0%, ${color1} 50%, ${color2} 100%)`,
          boxShadow: `0 0 ${size * 4}px ${size}px ${color}`,
          filter: 'saturate(1.5) brightness(1.3)'
        });
        particle.style.animation = `float ${duration}s ${delay}s infinite ease-in-out`;

        container.appendChild(particle);
      }
    }

    // Stream Button Functionality
    document.addEventListener('click', function (e) {
      const streamButton = e.target.closest('.stream-button');
      if (!streamButton) return;

      // Create ripple effect
      const rect = streamButton.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const ripple = document.createElement('span');
      ripple.classList.add('ripple');
      ripple.style.left = x + 'px';
      ripple.style.top = y + 'px';

      // Remove any existing ripples
      const existingRipples = streamButton.querySelectorAll('.ripple');
      existingRipples.forEach(r => r.remove());

      streamButton.appendChild(ripple);

      // Remove ripple after animation completes
      setTimeout(() => {
        ripple.remove();
      }, 600);

      // Add temporary click effect
      streamButton.classList.add('clicked');
      setTimeout(() => {
        streamButton.classList.remove('clicked');
      }, 200);

      // Get the current movie from the modal
      const modal = document.getElementById('movieModal');
      if (modal && modal.style.display === 'flex') {
        var modalTitleElem = document.getElementById('modalTitle');
        if (modalTitleElem && modalTitleElem.textContent) {
          var movieTitle = modalTitleElem.textContent;
          // Request landscape orientation if in portrait mode
          function proceedToStream() {
            // Here you can add your streaming logic
            console.log('Streaming:', movieTitle);
            // Example: window.open('streaming-url-here', '_blank');
          }
          if (window.matchMedia('(orientation: portrait)').matches && screen.orientation && screen.orientation.lock) {
            var requestFs = document.documentElement.requestFullscreen ? document.documentElement.requestFullscreen() : Promise.resolve();
            requestFs.then(function () {
              return screen.orientation.lock('landscape');
            }).then(function () {
              proceedToStream();
            }).catch(function () {
              proceedToStream();
            });
          } else {
            proceedToStream();
          }
        }
      }
    });

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize theme
      const key = getScopedThemeKey();
      const savedTheme = localStorage.getItem(key) || 'glossy';
      applyTheme(savedTheme);

      // Set up theme change listeners
      setupThemeListener();

      // Initialize particles and handle window resize with debounce
      let resizeTimer;
      const handleResize = () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(createParticles, 250);
      };

      // Initial particle creation with theme colors
      createParticles();

      // Set up event listeners
      window.addEventListener('resize', handleResize);

      // Watch for theme changes via style attribute
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'style') {
            createParticles();
          }
        });
      });

      // Start observing the document for style changes
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['style']
      });
    });

    // Auth gate + profile + theme load
    FirebaseAuth.onAuthChanged(async (user) => {
      const menu = document.getElementById('appUserMenu');
      if (!user) { window.location.assign('/login.html'); return; }
      // Load selected profile or redirect to profiles page
      const prof = await FirebaseAuth.getSelectedProfile(user.uid);
      if (!prof) { window.location.assign('/profiles.html'); return; }

      // Initialize FirebaseSync with the confirmed profile
      if (window.FirebaseSync && typeof window.FirebaseSync.initializeForProfile === 'function') {
        await window.FirebaseSync.initializeForProfile();
      }

      // Populate mini user menu
      if (menu) menu.style.display = 'block';

      // Get all necessary elements
      const userNameElement = document.querySelector('.user-name');
      const userAvatar = document.getElementById('userAvatar');

      // Update username
      if (userNameElement) {
        userNameElement.textContent = prof.name || 'User';
      }

      // Update avatar
      if (userAvatar) {
        // Clear existing content
        userAvatar.innerHTML = '';

        // Apply background color if specified
        if (prof.color) {
          userAvatar.style.backgroundColor = prof.color;
          userAvatar.style.backgroundImage = 'none';
        }

        if (prof.avatarUrl) {
          // Show avatar image if available
          const img = document.createElement('img');
          img.id = 'userAvatarImg';
          img.src = prof.avatarUrl;
          img.alt = 'Profile';
          img.style.cssText = 'width:100%;height:100%;object-fit:cover;border-radius:inherit;';
          userAvatar.appendChild(img);
        } else {
          // Show initial if no avatar
          const initial = document.createElement('span');
          initial.id = 'userInitial';
          initial.textContent = (prof.name || '?').charAt(0).toUpperCase();
          initial.style.cssText = 'position:absolute;font-weight:600;font-size:14px;color:white;display:flex;align-items:center;justify-content:center;width:100%;height:100%;';
          userAvatar.appendChild(initial);
        }
      }

      // Log the profile data for debugging
      console.log('Profile data:', {
        name: prof.name,
        color: prof.color,
        hasAvatar: !!prof.avatarUrl,
        timestamp: new Date().toISOString()
      });

      // Log the applied styles for verification
      if (userAvatar) {
        setTimeout(() => {
          console.log('Avatar element after update:', {
            id: userAvatar.id,
            outerHTML: userAvatar.outerHTML,
            computedStyles: window.getComputedStyle(userAvatar)
          });
        }, 100);
      }

      // Resolve and apply profile-scoped theme
      try {
        const key = getScopedThemeKey();
        const local = localStorage.getItem(key);
        let theme = local;
        if (!theme) {
          // Try profile document field first, then user settings per-profile, then global
          theme = (prof && prof.theme) || null;
          if (!theme) {
            const s = await FirebaseAuth.getUserSettings(user.uid).catch(() => null);
            theme = (s && s.profiles && prof && s.profiles[prof.id] && s.profiles[prof.id].theme) || (s && s.theme) || null;
          }
        }
        applyTheme(theme || 'glossy');
      } catch (e) { }

      // Now that auth/profile are ready, render Continue Watching without flicker
      if (typeof loadContinueWatching === 'function') {
        loadContinueWatching(true);
      }

      // Wire dropdown with smooth animations
      const btn = document.getElementById('userMenuBtn');
      const dd = document.querySelector('.user-dropdown');
      let isAnimating = false;

      const closeDD = () => {
        if (!dd || isAnimating) return;
        isAnimating = true;

        // Start closing animation
        dd.classList.remove('visible');

        // Wait for animation to complete before hiding
        setTimeout(() => {
          dd.classList.remove('show');
          if (btn) btn.setAttribute('aria-expanded', 'false');
          isAnimating = false;
        }, 200);
      };

      const openDD = () => {
        if (!dd || isAnimating) return;
        isAnimating = true;

        // Show the dropdown first
        dd.classList.add('show');

        // Force reflow to ensure the element is in the render tree
        void dd.offsetHeight;

        // Position the dropdown
        const rect = btn.getBoundingClientRect();
        const screenWidth = window.innerWidth;

        // Responsive positioning based on screen size
        if (screenWidth <= 480) {
          // Mobile: align right edge with button
          dd.style.top = `${rect.bottom + 4}px`;
          dd.style.left = 'auto';
          dd.style.right = `${screenWidth - rect.right - 10}px`;
        } else if (screenWidth <= 768) {
          // Tablet: align right edge with button
          dd.style.top = `${rect.bottom + 4}px`;
          dd.style.left = 'auto';
          dd.style.right = `${screenWidth - rect.right - 20}px`;
        } else {
          // Desktop: align right edge with button, positioned below
          dd.style.top = `${rect.bottom + 4}px`;
          dd.style.left = 'auto';
          dd.style.right = `${screenWidth - rect.right - 20}px`;
        }

        // Show the dropdown
        dd.classList.add('show');
        btn.setAttribute('aria-expanded', 'true');

        // Force reflow to ensure the initial state is applied
        void dd.offsetHeight;

        // Start opening animation
        setTimeout(() => {
          dd.classList.add('visible');
          isAnimating = false;
        }, 10);
      };

      // Click handler with animation support
      if (btn && dd) {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (dd.classList.contains('show')) {
            closeDD();
          } else {
            openDD();
          }
        });

        // Close when clicking outside
        document.addEventListener('click', (e) => {
          if (!btn.contains(e.target) && !dd.contains(e.target)) {
            closeDD();
          }
        });

        // Close with Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && dd.classList.contains('show')) {
            closeDD();
          }
        });
      } else {
        if (!btn) console.warn('Dropdown button element not found');
        if (!dd) console.warn('Dropdown menu element not found');
      }

      // Keyboard support
      if (btn) {
        btn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            if (dd && dd.classList) {
              if (dd.classList.contains('show')) {
                closeDD();
              } else {
                openDD();
              }
            }
          } else if (e.key === 'Escape' && dd && dd.classList && dd.classList.contains('show')) {
            e.preventDefault();
            closeDD();
          }
        });
      }

      // Close when clicking outside
      document.addEventListener('click', (e) => {
        if (btn && dd && !btn.contains(e.target) && !dd.contains(e.target)) {
          closeDD();
        }
      });

      // Updates modal (auto-show on unseen update notes + manual open from menu)
      const updatesModal = document.getElementById('updatesModal');
      const updatesCloseBtn = document.getElementById('updatesCloseBtn');
      const updatesCloseActionBtn = document.getElementById('updatesCloseActionBtn');
      const updatesVersionTag = document.getElementById('updatesVersionTag');
      const updatesSummaryText = document.getElementById('updatesSummaryText');
      const updatesSections = document.getElementById('updatesSections');
      const updatesLink = document.getElementById('updatesLink');
      const UPDATE_NOTES_STORAGE_KEY = `cinematichub_updates_notes_seen_v2_${user?.uid || 'guest'}_${prof?.id || 'default'}`;
      const UPDATE_NOTES = {
        version: '2026.02.15',
        headline: 'Major reliability update with playback, sync, and UI quality fixes.',
        sections: [
          {
            title: 'Added',
            items: [
              'New Updates entry in the profile menu to reopen release notes any time.',
              'Automatic update modal display for each user/profile when new update notes are published.',
              'Versioned update tracking so you only see each release note once unless content changes.'
            ]
          },
          {
            title: 'Fixed',
            items: [
              'Continue Watching clear-all and single-item remove actions now persist and sync more reliably.',
              'Legacy/old Continue Watching entries are prevented from reappearing after clear operations.',
              'Continue Watching section now stays hidden when no valid in-progress items exist.'
            ]
          },
          {
            title: 'Improved',
            items: [
              'Player 2 startup and buffering behavior tuned for slower mobile networks.',
              'Progress persistence now updates much more frequently for better resume accuracy.',
              'Dropdown and modal interactions were hardened for more reliable behavior on localhost and production.'
            ]
          }
        ]
      };

      const hashUpdateNotes = (value) => {
        const text = JSON.stringify(value || '');
        let hash = 0;
        for (let i = 0; i < text.length; i += 1) {
          hash = ((hash << 5) - hash) + text.charCodeAt(i);
          hash |= 0;
        }
        return String(hash);
      };

      const updateNotesSignature = `${UPDATE_NOTES.version}:${hashUpdateNotes(UPDATE_NOTES)}`;

      const renderUpdateNotes = () => {
        if (!updatesVersionTag || !updatesSummaryText || !updatesSections) return;
        updatesVersionTag.textContent = `Build ${UPDATE_NOTES.version}`;
        updatesSummaryText.textContent = UPDATE_NOTES.headline;

        updatesSections.innerHTML = '';
        const sections = Array.isArray(UPDATE_NOTES.sections) ? UPDATE_NOTES.sections : [];
        sections.forEach((section) => {
          const wrapper = document.createElement('section');
          wrapper.className = 'updates-section';

          const title = document.createElement('h4');
          title.className = 'updates-section-title';
          title.textContent = section?.title || 'Update';

          const list = document.createElement('ul');
          list.className = 'updates-list';
          const items = Array.isArray(section?.items) ? section.items : [];
          items.forEach((itemText) => {
            const li = document.createElement('li');
            li.textContent = itemText;
            list.appendChild(li);
          });

          wrapper.appendChild(title);
          wrapper.appendChild(list);
          updatesSections.appendChild(wrapper);
        });
      };

      const openUpdatesModal = () => {
        if (!updatesModal) return;
        renderUpdateNotes();
        updatesModal.classList.add('show');
        updatesModal.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';
      };

      const closeUpdatesModal = (markSeen = true) => {
        if (!updatesModal) return;
        updatesModal.classList.remove('show');
        updatesModal.setAttribute('aria-hidden', 'true');
        document.body.style.overflow = '';
        if (markSeen) {
          localStorage.setItem(UPDATE_NOTES_STORAGE_KEY, updateNotesSignature);
        }
      };

      if (updatesModal && !updatesModal.dataset.bound) {
        updatesModal.dataset.bound = '1';
        updatesCloseBtn?.addEventListener('click', () => closeUpdatesModal(true));
        updatesCloseActionBtn?.addEventListener('click', () => closeUpdatesModal(true));
        updatesModal.addEventListener('click', (e) => {
          if (e.target === updatesModal) closeUpdatesModal(true);
        });
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && updatesModal.classList.contains('show')) {
            closeUpdatesModal(true);
          }
        });
      }

      if (updatesLink && !updatesLink.dataset.bound) {
        updatesLink.dataset.bound = '1';
        updatesLink.addEventListener('click', (e) => {
          e.preventDefault();
          closeDD();
          openUpdatesModal();
        });
      }

      const seenUpdateSignature = localStorage.getItem(UPDATE_NOTES_STORAGE_KEY) || '';
      if (seenUpdateSignature !== updateNotesSignature) {
        setTimeout(() => openUpdatesModal(), 280);
      }

      // Expose global handlers so other scripts/fallback listeners can open updates reliably.
      window.showAppUpdatesModal = openUpdatesModal;
      window.hideAppUpdatesModal = closeUpdatesModal;

      // Menu item click handlers with proper element IDs
      const settingsLink = document.getElementById('settingsLink');
      const switchProfileLink = document.querySelector('a[href="profiles.html"]');
      const signOutLink = document.getElementById('signOutLink');

      if (settingsLink) {
        settingsLink.addEventListener('click', (e) => {
          e.preventDefault();
          closeDD();
          window.location.href = 'settings.html';
        });
      } else {
        console.warn('Settings link element not found');
      }

      if (switchProfileLink) {
        switchProfileLink.addEventListener('click', (e) => {
          e.preventDefault();
          closeDD();
          window.location.href = 'profiles.html';
        });
      } else {
        console.warn('Switch profile link not found');
      }

      if (signOutLink) {
        signOutLink.addEventListener('click', async (e) => {
          e.preventDefault();
          closeDD();
          try {
            if (typeof FirebaseAuth !== 'undefined' && FirebaseAuth.signOut) {
              await FirebaseAuth.signOut();
            }
            window.location.href = 'login.html';
          } catch (error) {
            console.error('Error during sign out:', error);
            window.location.href = 'login.html';
          }
        });
      } else {
        console.warn('Sign out link not found');
      }
    });
  </script>

  <!-- Movie Database Integration -->
  <script src="js/movie-db.js"></script>
  <script src="js/tmdb-integration.js"></script>
  <script src="public/streamApiConfig.js?v=20260112"></script>
  <script src="js/consumet-api.js"></script>
  <script src="js/stream-api.js"></script>

  <!-- Enhanced Multi-Provider Streaming API with Multi-Language Support -->
  <script src="js/enhanced-stream-api.js?v=20260113-fixed"></script>
  <script src="js/audio-language-selector.js"></script>
  <script src="js/stream-player-handler.js"></script>

  <!-- Streaming Compatibility Layer - bridges old & new APIs -->
  <script src="js/stream-compatibility.js?v=20260113-fixed"></script>

  <!-- Stream Debug Helper -->
  <script src="js/stream-debug.js"></script>

  <!-- Ad-Blocker Proxy Integration removed per request -->
  <!-- script src="js/ad-blocker-proxy-integration.js"></script -->

  <script src="js/player-integration.js"></script>
  <script>
    // Runtime API keys are injected through public/streamApiConfig.js (generated from env vars).
    const TMDB_API_KEY = window.TMDB_API_KEY || '';
    const YT_API_KEY = window.YT_API_KEY || '';
    let movieDb = null;

    // Check if there's a movie modal to restore from player back button
    (function restoreModalOnPageLoad() {
      try {
        const storedMovie = sessionStorage.getItem('currentModalMovie');
        const storedCategory = sessionStorage.getItem('currentModalCategory');
        const shouldRestore = sessionStorage.getItem('restoreModalOnLoad');

        if (storedMovie && shouldRestore === 'true') {
          const movie = JSON.parse(storedMovie);
          const categoryToRestore = storedCategory || 'all';
          sessionStorage.removeItem('restoreModalOnLoad');

          // Delay slightly to ensure DOM is ready
          setTimeout(() => {
            // Restore the category first, then open the modal
            if (categoryToRestore !== currentCategory) {
              applyCategory(categoryToRestore);
            }
            openMovieModal(movie);
          }, 100);
        }
      } catch (e) {
        console.warn('Failed to restore modal:', e);
      }
    })();

    // Initialize movie database
    function initMovieDb() {
      if (!TMDB_API_KEY || TMDB_API_KEY === 'YOUR_API_KEY_HERE') {
        console.warn('TMDB API key not configured. Movie database features will be limited.');
        return;
      }
      movieDb = new MovieDatabase(TMDB_API_KEY);
      // Expose to window for stream-api.js
      window.movieDb = movieDb;
      // Load trending movies and TV shows
      loadTrendingMovies();
      loadTrendingTV();
      // Start trending refresh with auto-updates every 5-15 minutes
      if (typeof startTrendingRefresh === 'function') {
        console.log('Starting trending refresh on page load...');
        startTrendingRefresh();
      }

      // Start category auto-refresh every 7 minutes (420,000 ms)
      startCategoryAutoRefresh();
    }

    // Auto-refresh categories every 7 minutes to get fresh TMDB data
    function startCategoryAutoRefresh() {
      console.log('Starting category auto-refresh every 7 minutes...');

      // Refresh immediately, then every 7 minutes
      setTimeout(refreshAllCategories, 1000); // Initial refresh after 1 second
      setInterval(refreshAllCategories, 420000); // 7 minutes = 420,000 milliseconds
    }

    // Refresh all category data from TMDB
    async function refreshAllCategories() {
      if (!movieDb || !useTMDBCatalog) {
        console.log('Skipping category refresh - TMDB not initialized or not in use');
        return;
      }

      try {
        console.log('Refreshing category data from TMDB...');

        // Clear existing cached data
        if (movieDb && typeof movieDb.clearCache === 'function') {
          movieDb.clearCache();
          console.log('Cleared TMDB cache');
        }

        // Reload all movie and TV data
        const [movies, tvShows] = await Promise.all([
          loadAllTMDBMovies ? loadAllTMDBMovies(10) : Promise.resolve([]),
          loadAllTMDBTV ? loadAllTMDBTV(5) : Promise.resolve([])
        ]);

        // Update the global catalogs
        if (movies && movies.length > 0) {
          allMovies = movies;
          console.log(`Refreshed ${movies.length} movies`);
        }

        if (tvShows && tvShows.length > 0) {
          allTV = tvShows;
          console.log(`Refreshed ${tvShows.length} TV shows`);
        }

        // If we're currently viewing a category, refresh the display
        if (currentCategory && currentCategory !== 'search') {
          console.log(`Refreshing display for current category: ${currentCategory}`);
          applyCategory(currentCategory);
        }

        // Refresh trending sections
        loadTrendingMovies();
        loadTrendingTV();

        console.log('Category refresh completed successfully');

        // End initial page load guard after refresh + small delay to allow images/layout to settle
        setTimeout(() => {
          try {
            window.initialPageLoad = false;
            console.log('initialPageLoad disabled (post refresh)');
          } catch (e) { /* ignore */ }
        }, 1500);

      } catch (error) {
        console.error('Error during category refresh:', error);
      }
    }

    // Load and display trending movies from TMDB trending endpoint with rank badges
    async function loadTrendingMovies() {
      if (!movieDb) return;
      try {
        // Use getTrendingMovies if available (new method), fallback to getPopularMovies
        const getTrending = typeof movieDb.getTrendingMovies === 'function' ? movieDb.getTrendingMovies : movieDb.getPopularMovies;
        const result = await getTrending.call(movieDb, 1);
        const container = document.getElementById('trendingMoviesContainer');
        if (!container) return;
        container.innerHTML = '';

        const movies = (result && result.movies) ? result.movies.slice(0, 20) : [];

        // Filter out movies without ratings
        const ratedMovies = movies.filter(m => {
          const rating = m.rating || (typeof m.vote_average === 'number' ? m.vote_average : null);
          return rating !== null && rating !== undefined && rating > 0;
        });

        if (ratedMovies.length === 0) {
          container.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">No rated trending movies available</p>';
          return;
        }

        // Rotate Featured Hero using top 3 trending entries
        if (!isSearching) {
          startFeaturedHeroRotation(ratedMovies);
        }

        ratedMovies.forEach((m, index) => {
          const title = m.title || 'Untitled';
          const posterPath = m.poster || (m.posterUrl || (m.poster_path ? `${movieDb.imageUrl}${m.poster_path}` : null)) || getPosterFallback(title);
          const year = m.releaseDate ? (m.releaseDate.split('-')[0]) : (m.year || '');
          const rating = m.rating || (typeof m.vote_average === 'number' ? m.vote_average : null);
          const rank = index + 1; // Trending rank badge

          const card = document.createElement('div');
          card.className = 'movie-card movie-' + (m.id || 'trending-' + index);
          card.innerHTML = `
            <div class="poster">
              <img src="${posterPath}" alt="${title}" loading="lazy" />
              <div class="rating-badge"><span class="star">â˜…</span><span class="value">${rating ? Number(rating).toFixed(1) : 'N/A'}</span></div>
              <div class="trending-rank-badge">#${rank}</div>
              <div class="play-icon"></div>
              <div class="movie-title-overlay">${title}</div>
            </div>
            <div class="movie-info">
              <h3 class="movie-title">${title} (${year || ''})</h3>
            </div>
          `;

          const img = card.querySelector('img');
          if (img) {
            img.addEventListener('error', () => {
              img.src = getPosterFallback(title);
            });
          }

          card.addEventListener('click', async () => {
            const details = await getMovieDetailsDb(m.id);
            const mappedMovie = details ? {
              id: details.id,
              title: details.title,
              year: details.releaseDate ? details.releaseDate.split('-')[0] : '',
              genres: details.genres || [],
              rating: details.rating || 0,
              overview: details.overview || '',
              release_date: details.releaseDate || '',
              posterUrl: details.poster || null,
              backdropUrl: details.backdrop || null,
              trailerUrl: '',
              streamUrl: ''
            } : {
              id: m.id,
              title: title,
              year: year,
              genres: [],
              rating: rating || 0,
              overview: m.overview || '',
              release_date: m.releaseDate || '',
              posterUrl: posterPath,
              backdropUrl: m.backdrop || null,
              trailerUrl: '',
              streamUrl: ''
            };
            if (typeof openMovieModal === 'function') openMovieModal(mappedMovie);
          });

          container.appendChild(card);
        });
      } catch (error) {
        console.error('Failed to load trending movies:', error);
        const container = document.getElementById('trendingMoviesContainer');
        if (container) {
          container.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">Failed to load trending movies</p>';
        }
      }
    }

    // Load and display trending TV shows from TMDB trending endpoint with rank badges
    async function loadTrendingTV() {
      if (!movieDb) return;
      try {
        // Use getTrendingTV if available (new method), fallback to popular TV
        const getTrending = typeof movieDb.getTrendingTV === 'function' ? movieDb.getTrendingTV : movieDb.getPopularTV;
        const result = await getTrending.call(movieDb, 1);
        const container = document.getElementById('trendingTVContainer');
        if (!container) return;
        container.innerHTML = '';

        const shows = (result && result.movies) ? result.movies.slice(0, 20) : [];

        // Filter out shows without ratings
        const ratedShows = shows.filter(m => {
          const rating = m.rating || (typeof m.vote_average === 'number' ? m.vote_average : null);
          return rating !== null && rating !== undefined && rating > 0;
        });

        if (ratedShows.length === 0) {
          container.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">No rated trending series available</p>';
          return;
        }

        ratedShows.forEach((m, index) => {
          const title = m.title || 'Untitled';
          const posterPath = m.poster || (m.posterUrl || (m.poster_path ? `${movieDb.imageUrl}${m.poster_path}` : null)) || getPosterFallback(title);
          const year = m.releaseDate ? (m.releaseDate.split('-')[0]) : (m.year || '');
          const rating = m.rating || (typeof m.vote_average === 'number' ? m.vote_average : null);
          const rank = index + 1; // Trending rank badge

          const card = document.createElement('div');
          card.className = 'movie-card movie-' + (m.id || 'trending-tv-' + index);
          card.innerHTML = `
            <div class="poster">
              <img src="${posterPath}" alt="${title}" loading="lazy" />
              <div class="rating-badge"><span class="star">â˜…</span><span class="value">${rating ? Number(rating).toFixed(1) : 'N/A'}</span></div>
              <div class="trending-rank-badge">#${rank}</div>
              <div class="play-icon"></div>
              <div class="movie-title-overlay">${title}</div>
            </div>
            <div class="movie-info">
              <h3 class="movie-title">${title} (${year || ''})</h3>
            </div>
          `;

          const img = card.querySelector('img');
          if (img) {
            img.addEventListener('error', () => {
              img.src = getPosterFallback(title);
            });
          }

          card.addEventListener('click', async () => {
            const details = await movieDb.getTVDetails(m.id);
            const mappedShow = details ? {
              id: details.id,
              title: details.title,
              year: details.releaseDate ? details.releaseDate.split('-')[0] : '',
              genres: details.genres || [],
              rating: details.rating || 0,
              overview: details.overview || '',
              release_date: details.releaseDate || '',
              posterUrl: details.poster || null,
              backdropUrl: details.backdrop || null,
              trailerUrl: '',
              streamUrl: '',
              mediaType: 'tv'
            } : {
              id: m.id,
              title: title,
              year: year,
              genres: [],
              rating: rating || 0,
              overview: m.overview || '',
              release_date: m.releaseDate || '',
              posterUrl: posterPath,
              backdropUrl: m.backdrop || null,
              trailerUrl: '',
              streamUrl: '',
              mediaType: 'tv'
            };
            if (typeof openMovieModal === 'function') openMovieModal(mappedShow);
          });

          container.appendChild(card);
        });
      } catch (error) {
        console.error('Failed to load trending TV shows:', error);
        const container = document.getElementById('trendingTVContainer');
        if (container) {
          container.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">Failed to load trending series</p>';
        }
      }
    }

    // Show movie details in modal
    function showMovieModal(movie) {
      const modal = document.getElementById('movieModal');
      const title = document.getElementById('modalTitle');
      const overview = document.getElementById('modalOverview');
      const genres = document.getElementById('modalGenres');
      const rating = document.getElementById('modalRating');
      const releaseDate = document.getElementById('modalReleaseDate');
      const trailerImg = document.getElementById('trailerPlaceholderImg');

      if (title) title.textContent = movie.title;
      if (overview) overview.textContent = movie.overview;
      if (genres) genres.textContent = movie.genres ? movie.genres.join(', ') : 'N/A';
      if (rating) rating.textContent = `${movie.rating.toFixed(1)}/10`;
      if (releaseDate) releaseDate.textContent = movie.releaseDate || 'N/A';
      if (trailerImg) trailerImg.src = movie.backdrop || movie.poster || '';

      if (modal) {
        modal.style.display = 'flex';
      }
    }

    // Search movies
    async function searchMoviesDb(query) {
      if (!movieDb || !query) return [];
      try {
        const results = await movieDb.searchMovies(query);
        return results.movies;
      } catch (error) {
        console.error('Search failed:', error);
        return [];
      }
    }

    // Get movie details
    async function getMovieDetailsDb(movieId) {
      if (!movieDb) return null;
      try {
        return await movieDb.getMovieDetails(movieId);
      } catch (error) {
        console.error('Failed to get movie details:', error);
        return null;
      }
    }

  </script>

  <!-- Migration Helper - Disabled for now -->
  <!-- Can be enabled later when needed -->

  <!-- Initialize Continue Watching (removed duplicate inline UI; unified on loadContinueWatching) -->
  
  <!-- Image Quality Enhancement Script -->
  <script src="js/image-enhancement.js"></script>
  <script src="js/continue-watching-display.js"></script>
</body>

</html>

