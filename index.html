<!DOCTYPE html>
<html lang="en">

<head>
  <!-- CRITICAL: Block all redirects IMMEDIATELY -->
  <script>
    // Block window.open completely
    const originalOpen = window.open;
    window.open = function(url) {
      console.log('ðŸš« BLOCKED: window.open(' + url + ')');
      return null;
    };
    
    // Block eval
    window.eval = function() { 
      console.log('ðŸš« BLOCKED: eval()');
      return undefined;
    };
    
    console.log('âœ… Security barrier loaded');
  </script>

  <style>
    @media (orientation: portrait) {
      .user-name.hide-mobile {
        display: none !important;
      }
    } 
  </style>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="screen-orientation" content="portrait">
  <meta name="theme-color" content="#000000">
  <title>Cinematic Hub</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://www.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="preconnect" href="https://firestore.googleapis.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <link rel="preconnect" href="https://www.youtube.com">
  <link rel="stylesheet" href="css/continue-watching.css" />
  <link rel="stylesheet" href="css/subtitles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  
  <style>
    @keyframes ripple {
      to {
        transform: scale(2.5);
        opacity: 0;
      }
    }

    /* Pulse Animation */
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(166, 108, 255, 0.7);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(166, 108, 255, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(166, 108, 255, 0);
      }
    }

    .stream-button.pulse {
      animation: pulse 2s infinite;
    }

    /* Responsive Adjustments */
    @media (max-width: 768px) {
      .stream-button {
        padding: 10px 24px;
        font-size: 0.95rem;
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    *::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    *::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
    }

    *::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(167, 139, 250, 0.6), rgba(251, 113, 133, 0.6));
      border-radius: 10px;
      transition: all 0.3s ease;
    }

    *::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(167, 139, 250, 0.8), rgba(251, 113, 133, 0.8));
    }

    /* Animated Background */
    .bg-particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.6;
      pointer-events: none;
      overflow: hidden;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      background: linear-gradient(45deg, var(--primary, #6b66ff), #ff6b6b);
      opacity: 0.3;
      animation: float 15s infinite ease-in-out;
      box-shadow: 0 0 15px 3px rgba(255, 255, 255, 0.4);
    }

    @keyframes float {

      0%,
      100% {
        transform: translateY(0) translateX(0);
      }

      25% {
        transform: translateY(-20px) translateX(10px);
      }

      50% {
        transform: translateY(0) translateX(20px);
      }

      75% {
        transform: translateY(20px) translateX(10px);
      }
    }

    :root {
      --scrollbar-thumb: #ffffff;
      --scrollbar-thumb-hover: #0a0a0f;
      --scrollbar-track: #0f0f15;
      --modal-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.65), 0 1.5px 8px rgba(0, 0, 0, 0.35);
      --primary-gradient: linear-gradient(90deg, #a78bfa, #fb7185);
      --bg-color: #030305;
      --bg-gradient: linear-gradient(180deg, #030305 0%, #0a0a0f 50%, #05050a 100%);
      --glass-bg: rgba(15, 15, 25, 0.7);
      --glass-border: rgba(255, 255, 255, 0.08);
      --card-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      --hover-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
      --text-color: #ffffff;
      --text-secondary: rgba(255, 255, 255, 0.65);
      --modal-bg: rgba(0, 0, 0, 0.98);
      --modal-content-bg: rgba(15, 15, 25, 0.95);
    }

    @media (max-width: 768px) {
      .poster {
        height: 260px;
      }
    }

    @media (max-width: 420px) {
      .poster {
        height: 220px;
      }
    }

    body {
      font-family: 'Poppins', sans-serif;
      background-color: #030305;
      background-image: linear-gradient(180deg, #030305 0%, #0a0a0f 45%, #05050a 100%);
      color: var(--text-color);
      min-height: 100vh;
      padding: 2rem;
      background-attachment: fixed;
      background-repeat: no-repeat;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      opacity: 0.03;
      pointer-events: none;
      z-index: 1;
    }

    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 30%, rgba(167, 139, 250, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(251, 113, 133, 0.04) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(99, 102, 241, 0.02) 0%, transparent 70%);
      pointer-events: none;
      z-index: 1;
      animation: gradientShift 20s ease-in-out infinite;
    }

    @keyframes gradientShift {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.1); }
    }

    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(50px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      position: relative;
      z-index: 2;
      animation: slideInUp 0.6s ease-out;
    }

    /* Mini user menu (profiles/settings/logout) */
      /* New Clear All button styles */
      .cw-clear-btn { display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border:none; border-radius:10px; background:linear-gradient(135deg,#ff7a7a,#ff3b3b); color:#fff; font-weight:600; box-shadow:0 6px 16px rgba(255,59,59,0.25); cursor:pointer; transition:transform .15s ease, box-shadow .15s ease, filter .15s ease; }
      .cw-clear-btn:hover { transform:translateY(-1px); box-shadow:0 8px 20px rgba(255,59,59,0.35); filter:saturate(1.1); }
      .cw-clear-btn:active { transform:translateY(0); box-shadow:0 4px 12px rgba(255,59,59,0.2); }
      .cw-clear-icon { font-size:18px; line-height:1; }
      .cw-clear-text { font-size:14px; }
    .app-usermenu {
      margin-left: auto;
      z-index: 1200;
      position: relative;
      display: flex;
      align-items: center;
    }

    .app-userbtn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      padding: 4px 12px 4px 4px;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(8px);
      color: white;
      font-weight: 500;
      font-size: 0.85rem;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      height: 36px;
      transform-origin: center;
      position: relative;
    }

    .app-userbtn:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px) scale(1.02);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }

    .app-userbtn:active {
      transform: translateY(0) scale(0.98);
      transition-duration: 0.1s;
    }

    .app-userbtn:focus {
      outline: 2px solid rgba(255, 255, 255, 0.35);
      outline-offset: 2px;
    }

    .app-avatar {
      width: 28px;
      height: 28px;
      border-radius: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--avatar-bg, #6b66ff) !important;
      /* Default color if not set */
      background-color: var(--avatar-bg, #6b66ff) !important;
      /* Fallback */
      color: white !important;
      font-weight: 500;
      overflow: hidden;
      font-size: 0.8rem;
      flex-shrink: 0;
      /* Remove any potential gradient */
      background-image: none !important;
    }

    .app-userbtn::after {
      content: 'â—€';
      font-size: 8px;
      margin-left: 4px;
      opacity: 0.7;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      transform: rotate(0deg);
      transform-origin: center;
    }

    .app-userbtn[aria-expanded="true"]::after {
      transform: rotate(-90deg);
    }

    .app-userbtn:hover::after {
      opacity: 1;
    }

    .app-userdropdown {
      position: absolute;
      top: 100%;
      right: 0;
      min-width: 220px;
      display: none;
      flex-direction: column;
      background: rgba(22, 22, 25, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      margin-top: 8px;
      overflow: hidden;
      z-index: 9999;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(16px);
      padding: 6px 0;
      opacity: 0;
      transform: translateY(-8px);
      transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      will-change: opacity, transform;
    }

    .app-userdropdown.visible {
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.2s ease-out, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .app-userdropdown.show {
      display: flex;
    }

    .app-userdropdown button {
      appearance: none;
      background: transparent;
      color: rgba(255, 255, 255, 0.9);
      border: none;
      padding: 10px 20px;
      text-align: left;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .app-userdropdown button::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 3px;
      background: var(--primary-gradient);
      transform: scaleY(0);
      transform-origin: top;
      transition: transform 0.2s ease;
    }

    .app-userdropdown button:hover {
      background: rgba(255, 255, 255, 0.05);
      color: white;
      padding-left: 20px;
    }

    .app-userdropdown button:hover::before {
      transform: scaleY(1);
    }

    .app-userdropdown button i {
      width: 20px;
      text-align: center;
      opacity: 0.8;
      font-size: 1rem;
    }

    .app-userdropdown button .menu-item-text {
      flex: 1;
    }

    .app-userdropdown button .menu-item-badge {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 0.7rem;
      font-weight: 600;
    }

    .app-userdropdown button i {
      width: 20px;
      text-align: center;
      opacity: 0.8;
    }

    /* When modal is open, keep user menu visible and properly positioned */
    .modal-open .app-usermenu {
      filter: none;
      opacity: 1;
      pointer-events: auto;
      position: fixed;
      top: 20px;
      right: 20px;
    }

    /* Hide the username text on smaller screens */
    @media (max-width: 768px) {
      .app-username {
        display: none;
      }

      .app-userbtn {
        padding: 4px;
      }
    }

    /* Hide continue watching section during search */
    body.searching .continue-watching-section {
      display: none !important;
    }

    /* Push search results down when searching */
    body.searching #moviesContainer {
      margin-top: 140px;
    }

    @media (max-width: 768px) {
      body.searching #moviesContainer {
        margin-top: 70px;
      }
    }



    /* Modern User Menu Component */
    #userMenuComponent {
      position: fixed;
      right: 2rem;
      top: 1rem;
      z-index: 1001;
    }

    /* User Menu Button */
    .user-menu-btn {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      background: rgba(30, 30, 35, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 0.5rem 1rem 0.5rem 0.75rem;
      color: white;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .user-menu-btn:hover {
      background: rgba(40, 40, 45, 0.9);
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
    }

    .user-menu-btn:active {
      transform: translateY(0);
    }

    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 60%;
      /* Increased from 50% to 60% for a more rounded look */
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      flex-shrink: 0;
      font-weight: 600;
      font-size: 14px;
      color: white;
      transition: all 0.3s ease;
    }

    .user-menu-btn:hover .user-avatar {
      transform: scale(1.05);
    }

    .user-name {
      font-weight: 500;
      font-size: 0.95rem;
      white-space: nowrap;
    }

    .user-caret {
      transition: transform 0.3s ease;
      opacity: 0.7;
    }

    .user-menu-btn:hover .user-caret {
      opacity: 1;
    }

    /* Dropdown Menu */
    .user-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      background: rgba(30, 30, 35, 0.98);
      backdrop-filter: blur(20px);
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      min-width: 220px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1002;
    }

    .user-dropdown::before {
      content: '';
      position: absolute;
      top: -6px;
      right: 20px;
      width: 12px;
      height: 12px;
      background: inherit;
      transform: rotate(45deg);
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      border-left: 1px solid rgba(255, 255, 255, 0.08);
    }

    /* Dropdown Items */
    .dropdown-item {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.85rem 1.25rem;
      color: rgba(255, 255, 255, 0.9);
      text-decoration: none;
      font-size: 0.925rem;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .dropdown-item:hover {
      background: rgba(255, 255, 255, 0.05);
      color: #fff;
      padding-left: 1.5rem;
    }

    .dropdown-item i {
      width: 20px;
      text-align: center;
      color: #8b5cf6;
      font-size: 1.1em;
      transition: all 0.3s ease;
    }

    .dropdown-item:hover i {
      transform: scale(1.1);
      color: #a78bfa;
    }

    .dropdown-divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.08);
      margin: 0.25rem 0;
    }

    /* Active State */
    .user-menu-btn.active {
      background: rgba(40, 40, 45, 0.95);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    .user-menu-btn.active .user-caret {
      transform: rotate(180deg);
    }

    .user-menu-btn.active+.user-dropdown {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    /* Brand component */
    #brandComponent {
      position: fixed;
      left: 2rem;
      top: 1rem;
      z-index: 1001;
      backdrop-filter: blur(10px);
      padding: 0.5rem 1rem;
      border-radius: 12px;

    }

    .brand {
      display: flex;
      flex-direction: column;
      line-height: 1;
    }

    .brand-title {
      font-size: 8.5rem;
      font-weight: 1000px;
      background: linear-gradient(135deg, #a78bfa 0%, #fb7185 50%, #fbbf24 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0;
      letter-spacing: -1px;
      display: flex;
      align-items: center;
      gap: 0.3em;
    }

    .brand-sub {
      font-size: 4rem;
      opacity: 0.7;
      letter-spacing: 0.5px;
      margin-top: 2px;
    }

    /* Search component */
    #searchComponent {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      top: 1rem;
      z-index: 1001;
      background: none;
      border-radius: 150px;
    }

    .search-top {
      display: flex;
      align-items: center;
      background: linear-gradient(135deg, rgba(20, 20, 30, 0.8) 0%, rgba(15, 15, 25, 0.9) 100%);
      border: 1.5px solid rgba(255, 255, 255, 0.1);
      border-radius: 24px;
      padding: 0.6rem 1.25rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      width: 100%;
      max-width: 600px;
      margin: 0 auto;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.03) inset;
    }

    .search-top:hover {
      border-color: rgba(167, 139, 250, 0.3);
      box-shadow: 0 6px 20px rgba(167, 139, 250, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.06) inset;
    }

    .search-top:focus-within {
      transform: translateY(-2px);
      box-shadow: 0 8px 28px rgba(167, 139, 250, 0.25), 0 0 0 2px rgba(167, 139, 250, 0.3);
      border-color: rgba(167, 139, 250, 0.5);
      background: linear-gradient(135deg, rgba(25, 25, 40, 0.9) 0%, rgba(20, 20, 30, 0.95) 100%);
    }

    .search-top input {
      background: transparent;
      border: none;
      color: white;
      padding: 0.6rem 0.75rem;
      width: 100%;
      outline: none;
      font-size: 1rem;
      font-weight: 400;
      letter-spacing: 0.3px;
    }

    .search-top input::placeholder {
      color: rgba(255, 255, 255, 0.5);
      font-weight: 300;
    }

    /* Adjust topbar to account for fixed user menu */
    .topbar-wrapper {
      padding-right: 100px;
      /* Make space for the fixed user menu */
    }

    /* Menu divider */
    .menu-divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 4px 0;
    }

    .logout-btn {
      color: #ff6b6b !important;
    }

    /* Dropdown container - positioned outside the topbar */
    .dropdown-container {
      position: static;
      /* Changed from relative to prevent containment */
      display: inline-block;
      /* Make it only take necessary space */
      z-index: 1000;
      /* Higher than topbar */
    }

    /* User menu container */
    .user-menu-container {
      position: relative;
      height: 100%;
      display: flex;
      align-items: center;
      z-index: 1001;
      /* Higher than topbar */
      /* Ensure this creates a new stacking context */
      transform: translateZ(0);
    }

    /* Dropdown menu styles */
    .dropdown-menu {
      position: absolute;
      right: 0;
      top: 100%;
      /* Changed from calc(100% + 10px) */
      margin-top: 10px;
      /* Added margin instead of including in top */
      background: rgba(20, 20, 30, 0.98);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 0.5rem 0;
      min-width: 200px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
      z-index: 1002;
      /* Keep this higher than topbar */
      opacity: 0;
      visibility: hidden;
      transform: translateY(-5px);
      transition: all 0.2s ease-out;
      /* Ensure no background bleeds through */
      background-clip: padding-box;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-5px);
      transition: all 0.2s ease-out;
    }

    .user-menu-container:hover .dropdown-menu,
    .dropdown-menu.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
    }

    .topbar-content {
      display: flex;
      align-items: center;
      position: relative;
      width: 100%;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: nowrap;
      z-index: 10;
    }

    .topbar-search {
      flex: 1;
      max-width: 600px;
      margin: 0 auto;
      display: flex;
      justify-content: center;
    }

    /* Responsive adjustments */
    @media (min-width: 1025px) {
      .topbar-content {
        gap: 1.5rem;
      }

      .search-top {
        max-width: 600px;
        width: 100%;
      }

      .brand {
        flex-shrink: 0;
      }

      .app-usermenu {
        flex-shrink: 0;
      }
    }

    @media (max-width: 1024px) {
      .topbar {
        padding: 1rem;
        gap: 0.75rem;
      }

      .topbar-content {
        gap: 0.75rem;
      }

      .topbar-search {
        flex: 1;
        max-width: none;
      }

      .search-top {
        width: 100%;
        max-width: 450px;
      }

      .brand-title {
        font-size: 1.1rem;
      }

      .brand-sub {
        font-size: 0.7rem;
      }
    }

    @media (max-width: 768px) {
      .topbar {
        padding: 0.75rem 1rem;
        gap: 0.5rem;
      }

      .topbar-content {
        gap: 0.5rem;
      }

      .brand {
        display: none;
      }

      .topbar-search {
        flex: 1;
      }

      .search-top {
        max-width: none;
        width: 100%;
      }

      .search-top input {
        width: 100%;
        max-width: none;
        min-width: 120px;
      }
    }

    @media (max-width: 480px) {
      .topbar {
        padding: 0.5rem 0.75rem;
        top: 0.5rem;
        border-radius: 8px;
      }

      .search-top {
        padding: 4px 6px;
        gap: 4px;
      }

      .search-top input {
        padding: 6px 8px;
        font-size: 0.9rem;
        min-width: 100px;
      }

      .home-btn {
        width: 32px;
        height: 32px;
        margin: 0 2px;
      }

      .home-btn svg {
        width: 14px;
        height: 14px;
      }

      .app-userbtn {
        padding: 4px;
        gap: 4px;
      }

      .app-avatar {
        width: 28px;
        height: 28px;
        font-size: 0.75rem;
      }

      .app-username {
        display: none;
      }
    }

    @media (max-width: 360px) {
      .topbar {
        padding: 0.5rem;
      }

      .search-top input {
        font-size: 0.85rem;
        padding: 5px 6px;
      }

      .home-btn {
        width: 28px;
        height: 28px;
      }

      .app-avatar {
        width: 26px;
        height: 26px;
      }
    }

    .brand {
      display: flex;
      flex-direction: column;
    }

    .brand-title {
      font-size: 1.25rem;
      margin: 0;
      letter-spacing: 0.4px;
      color: white;
      font-weight: 600;
      background: linear-gradient(90deg, #a78bfa, #fb7185);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .brand-sub {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 3px;
    }

    /* Home and search buttons */
    .home-btn {
      background: rgba(20, 20, 25, 0.8);
      border: 1.5px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 0;
      margin: 0 4px;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(8px);
    }

    .home-btn::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border: 1.5px solid transparent;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.6), rgba(139, 92, 246, 0.8));
      background-origin: border-box;
      background-clip: border-box;
      -webkit-background-clip: border-box;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .home-btn:hover::before {
      opacity: 1;
    }

    .home-btn svg {
      width: 16px;
      height: 16px;
      fill: white;
    }

    .home-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.25);
    }

    .home-btn:active {
      transform: translateY(0);
    }

    /* Modern Dark Search Bar */
    .search-top {
      --search-bg: rgba(20, 20, 25, 0.8);
      --search-border: rgba(99, 102, 241, 0.2);
      --search-focus: rgba(99, 102, 241, 0.4);
      --search-text: rgba(255, 255, 255, 0.9);
      --search-placeholder: rgba(255, 255, 255, 0.5);
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--search-bg);
      border: 1.5px solid var(--search-border);
      border-radius: 14px;
      padding: 12px 18px;
      transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(12px) saturate(180%);
      will-change: transform, box-shadow, border-color;
      position: relative;
      overflow: hidden;
    }

    /* Enhanced gradient border effect */
    .search-top {
      position: relative;
      overflow: visible;
      border-radius: 14px;
      background-clip: padding-box;
    }

    .search-top::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border: 3px solid var(--search-border);
      border-radius: 16px;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
    }

    .search-top:focus-within::before {
      opacity: 1;
      transform: scale(1.01);
    }

    /* Search icon with subtle animation */
    .search-top .search-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--search-placeholder);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      z-index: 1;
      opacity: 0.7;
    }

    /* Search bar focus/hover states */
    .search-top:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.15);
      border-color: rgba(99, 102, 241, 0.3);
    }

    /* Hover and focus states */
    .search-top:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
      border-color: var(--search-focus);
    }

    .search-top:focus-within,
    .search-top.active {
      background: rgba(25, 25, 30, 0.9);
      border-color: transparent;
      box-shadow: 0 12px 40px rgba(99, 102, 241, 0.2);
      transform: translateY(-2px);
    }

    .search-top:focus-within::before,
    .search-top.active::before {
      opacity: 1;
    }

    .search-top:focus-within .search-icon {
      color: #8b5cf6;
      opacity: 1;
      transform: scale(1.1);
    }

    /* Modern input field with smooth animations */
    .search-top input {
      background: transparent;
      border: none;
      border-radius: 20px;
      padding: 8px 12px 8px 12px;
      color: var(--search-text);
      font-size: 0.95rem;
      width: 100%;
      min-width: 200px;
      outline: none;
      transition: all 0.4s cubic-bezier(0.2, 0.8, 0.4, 1);
      font-family: 'Poppins', sans-serif;
      font-weight: 400;
      caret-color: #8b5cf6;
      letter-spacing: 0.3px;
      transform-origin: left center;
      box-shadow: 0 0 0 1px transparent;
    }

    .search-top:focus-within input {
      transform: scale(1.02);
      padding-left: 16px;
      box-shadow: none;
    }

    /* Enhanced input wrapper with animated effects */
    .search-input-wrapper {
      position: relative;
      flex: 1;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.03);
      transition: all 0.3s ease;
      overflow: hidden;
      border: 1px solid rgba(139, 92, 246, 0.3);
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
    }

    .search-top:focus-within .search-input-wrapper {
      background: rgba(255, 255, 255, 0.06);
      transform: translateY(0);
      box-shadow: 0 2px 12px rgba(139, 92, 246, 0.15);
    }

    /* Search results container */
    .search-results-container {
      position: fixed;
      top: 100px;
      /* Position from top of viewport */
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      width: 90%;
      max-width: 800px;
      max-height: 70vh;
      background: rgba(15, 15, 20, 0.98);
      border-radius: 16px;
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
      overflow: hidden;
      z-index: 2000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 1.5rem;
      box-sizing: border-box;
      /* Subtle gradient border effect */
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
      /* Subtle top highlight */
      position: relative;
    }

    /* Add subtle highlight to the top edge */
    .search-results-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      z-index: 1;
    }

    .search-top:focus-within+.search-results-container {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    /* Add overlay when search is active */
    .search-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(5px);
      z-index: 1999;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .search-top:focus-within~.search-overlay {
      opacity: 1;
      visibility: visible;
    }

    /* Subtle gradient border effect */
    .search-input-wrapper::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 8px;
      padding: 1px;
      background: linear-gradient(135deg,
          rgba(139, 92, 246, 0.4) 0%,
          rgba(99, 102, 241, 0.4) 100%);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask-composite: exclude;
      opacity: 0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: none;
      transform: scale(0.98);
    }

    .search-top:focus-within .search-input-wrapper::before {
      opacity: 1;
      transform: scale(1);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        opacity: 0.8;
      }

      50% {
        opacity: 1;
      }

      100% {
        opacity: 0.8;
      }
    }

    /* Input placeholder animation */
    .search-top input::placeholder {
      color: rgba(255, 255, 255, 0.4);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      transform-origin: left center;
      font-weight: 300;
      letter-spacing: 0.2px;
    }

    .search-top:focus-within input::placeholder {
      transform: translateX(8px) scale(0.9);
      opacity: 0.7;
    }

    .search-top input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }


    /* Search button */
    /* Enhanced search button */
    .search-top button {
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      padding: 0.5rem;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
      z-index: 1;
    }

    /* Button hover effect */
    .search-top button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--btn-hover);
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: -1;
    }

    .search-top button::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.6s ease, height 0.6s ease, opacity 0.6s ease;
      opacity: 0;
      z-index: -1;
    }

    .search-top button:hover {
      color: white;
      transform: scale(1.1);
    }

    .search-top button:hover::before {
      opacity: 1;
    }

    .search-top button:active {
      transform: translateY(1px) scale(0.98);
      box-shadow: 0 2px 10px rgba(99, 102, 241, 0.2);
      background: var(--btn-active);
    }

    .search-top button:active::after {
      width: 200%;
      height: 200%;
      opacity: 0;
    }

    /* Ripple effect on click */
    @keyframes ripple {
      to {
        width: 200%;
        height: 200%;
        opacity: 0;
      }
    }

    .search-top button::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .search-top button:hover {
      transform: translateY(-1px) scale(1.05);
      box-shadow: 0 4px 20px rgba(99, 102, 241, 0.4);
    }

    .search-top button:active {
      transform: translateY(1px) scale(0.98);
    }

    .search-top button:hover::after {
      opacity: 1;
    }

    /* Animation for search icon */
    @keyframes pulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.1);
      }

      100% {
        transform: scale(1);
      }
    }

    .search-top:focus-within .search-icon {
      animation: pulse 1.5s infinite;
    }

    /* Clear All button â€“ clean glass UI with icon animations */
    .clear-button {
      display: inline-flex;
      align-items: center;
      top: 40px;
      gap: 12px;
      padding: 0.7rem 1.15rem;
      border-radius: 999px;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      color: var(--text-color);
      font-weight: 500;
      font-size: 0.95rem;
      letter-spacing: 0.2px;
      backdrop-filter: blur(8px) saturate(120%);
      -webkit-backdrop-filter: blur(8px) saturate(120%);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background 0.2s ease, opacity 0.2s ease;
      cursor: pointer;
    }

    .clear-button i {
      width: 20px;
      height: 20px;
      display: inline-grid;
      place-items: center;
      color: var(--text-color);
      transition: transform 0.25s ease, color 0.2s ease, filter 0.2s ease;
    }

    .clear-button:hover {
      transform: translateY(-1px);
      border-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 12px 36px rgba(99, 102, 241, 0.25);
    }

    .clear-button:hover i {
      color: var(--accent);
    }

    .clear-button:active {
      transform: translateY(0);
    }

    .clear-button:active i {
      transform: rotate(0deg) scale(0.98);
    }

    .clear-button.is-empty {
      opacity: 0.55;
      cursor: default;
    }

    /* Dustbin dump animation */
    @keyframes dumpAnim {
      0% {
        transform: rotate(0deg) translateY(0);
      }

      30% {
        transform: rotate(-18deg) translateY(-1px);
      }

      60% {
        transform: rotate(-10deg) translateY(-1px);
      }

      100% {
        transform: rotate(0deg) translateY(0);
      }
    }

    .clear-button i.dump-anim {
      animation: dumpAnim 0.6s ease;
    }

    /* Confirmation Modal Styles */
    .confirm-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(6px) saturate(110%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.2s ease-out;
    }

    .confirm-modal {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 1.75rem 1.5rem;
      max-width: 520px;
      width: min(92vw, 520px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      animation: modalIn 0.24s cubic-bezier(0.22, 1, 0.36, 1);
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(8px) saturate(120%);
    }

    .confirm-modal::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 16px;
      padding: 1px;
      /* border width */
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.02));
      -webkit-mask:
        linear-gradient(#000 0 0) content-box,
        linear-gradient(#000 0 0);
      -webkit-mask-composite: xor;
      mask:
        linear-gradient(#000 0 0) content-box,
        linear-gradient(#000 0 0);
      mask-composite: exclude;
      pointer-events: none;
    }

    .confirm-modal.closing {
      animation: modalOut 0.2s ease forwards;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    @keyframes modalIn {
      from {
        opacity: 0;
        transform: translateY(8px) scale(0.98);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes modalOut {
      from {
        opacity: 1;
        transform: translateY(0) scale(1);
      }

      to {
        opacity: 0;
        transform: translateY(8px) scale(0.98);
      }
    }

    .confirm-modal-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 1.5rem;
    }

    .confirm-modal-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent), #ff6b6b);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: white;
    }

    .confirm-modal-title {
      font-size: 1.35rem;
      font-weight: 600;
      color: var(--text-color);
      margin: 0;
    }

    .confirm-modal-message {
      color: var(--text-secondary);
      font-size: 1rem;
      line-height: 1.6;
      margin-bottom: 2rem;
    }

    .confirm-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 0.25rem;
    }

    .confirm-modal-btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'Poppins', sans-serif;
    }

    .confirm-modal-btn-cancel {
      background: var(--theme-bg3);
      color: var(--text-color);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .confirm-modal-btn-cancel:hover {
      background: var(--theme-bg1);
      transform: translateY(-2px);
    }

    .confirm-modal-btn-yes {
      background: linear-gradient(135deg, var(--accent), #ff6b6b);
      color: white;
      box-shadow: 0 4px 16px rgba(166, 108, 255, 0.25);
    }

    .confirm-modal-btn-yes:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(166, 108, 255, 0.4);
    }

    .confirm-modal-btn:active {
      transform: translateY(0);
    }

    body.modal-open {
      overflow: hidden;
    }

    /* Action buttons in search area (home and search) share styles */
    .home-btn {
      position: relative;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: white;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      margin: 0 6px;
      padding: 0;
      box-sizing: border-box;
      outline: none;
      flex-shrink: 0;
      backdrop-filter: blur(10px);
    }

    .home-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 12px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      opacity: 0;
      transition: 0.6s;
    }

    .home-btn:hover::before {
      opacity: 1;
    }

    .home-btn:hover {
      transform: translateY(-2px);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
      box-shadow: 0 6px 20px rgba(255, 255, 255, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.2) inset;
      border-color: rgba(255, 255, 255, 0.3);
    }

    .home-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .home-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.25);
    }

    .home-btn:active {
      transform: translateY(0);
    }

    /* Remove default focus outline and add custom focus styles */
    .search-top input:focus {
      outline: none;
    }

    /* Add subtle animation to search results */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .movies-grid {
      animation: fadeInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      margin-top: 8rem;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .movie-card {
      animation: cardFadeIn 0.5s ease-out backwards;
    }

    .movie-card:nth-child(1) { animation-delay: 0.05s; }
    .movie-card:nth-child(2) { animation-delay: 0.1s; }
    .movie-card:nth-child(3) { animation-delay: 0.15s; }
    .movie-card:nth-child(4) { animation-delay: 0.2s; }
    .movie-card:nth-child(5) { animation-delay: 0.25s; }
    .movie-card:nth-child(6) { animation-delay: 0.3s; }

    @keyframes cardFadeIn {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .movies {
      margin-top: 8rem;
      padding-top: 1rem;
    }

    /* Category bar styles */
    .category-bar {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 10rem 0 1rem 0;
    }

    .cat-btn {
      padding: 0.65rem 1.25rem;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: linear-gradient(135deg, rgba(35, 35, 50, 0.5) 0%, rgba(25, 25, 35, 0.6) 100%);
      color: rgba(255, 255, 255, 0.9);
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      font-size: 0.95rem;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      backdrop-filter: blur(16px) saturate(150%);
      -webkit-backdrop-filter: blur(16px) saturate(150%);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      position: relative;
      overflow: hidden;
      letter-spacing: 0.3px;
    }

    .cat-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(167, 139, 250, 0.4), rgba(251, 113, 133, 0.3));
      transform: translate(-50%, -50%);
      transition: width 0.5s ease, height 0.5s ease;
    }

    .cat-btn:hover {
      transform: translateY(-3px);
      border-color: rgba(167, 139, 250, 0.4);
      box-shadow: 0 8px 20px rgba(167, 139, 250, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      background: linear-gradient(135deg, rgba(45, 45, 65, 0.6) 0%, rgba(35, 35, 50, 0.7) 100%);
    }

    .cat-btn:hover::before {
      width: 250px;
      height: 250px;
    }

    .cat-btn:active {
      transform: translateY(-1px) scale(0.98);
      box-shadow: 0 4px 12px rgba(167, 139, 250, 0.2);
    }

    .cat-btn:focus-visible {
      outline: none;
      border-color: rgba(167, 139, 250, 0.6);
      box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.3), 0 8px 20px rgba(167, 139, 250, 0.25);
    }

    .cat-btn.active {
      background: linear-gradient(135deg, #a78bfa 0%, #fb7185 100%);
      color: white;
      border-color: rgba(255, 255, 255, 0.4);
      box-shadow: 0 8px 24px rgba(167, 139, 250, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.2) inset;
      transform: translateY(-3px);
      font-weight: 700;
    }

    .cat-btn.active::before {
      width: 250px;
      height: 250px;
      background: rgba(255, 255, 255, 0.2);
    }

    /* Report Problem Modal Styles */
    .report-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      backdrop-filter: blur(6px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
      animation: fadeIn 0.2s ease-out;
    }

    .report-modal {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 1.5rem;
      width: min(92vw, 640px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      animation: modalIn 0.24s cubic-bezier(0.22, 1, 0.36, 1);
    }

    .report-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 1rem;
    }

    .report-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .report-grid.full {
      grid-template-columns: 1fr;
    }

    .report-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .report-field label {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .report-input,
    .report-select,
    .report-textarea {
      background: var(--theme-bg3);
      border: 1px solid var(--glass-border);
      color: var(--text-color);
      border-radius: 10px;
      padding: 10px 12px;
      font-family: 'Poppins', sans-serif;
      font-size: 0.95rem;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .report-input:focus,
    .report-select:focus,
    .report-textarea:focus {
      border-color: rgba(166, 108, 255, 0.6);
      box-shadow: 0 0 0 2px rgba(166, 108, 255, 0.2);
    }

    /* Force darker, higher-contrast dropdown menu for the native <select> */
    .report-select {
      color-scheme: dark;
      background: rgba(8, 6, 12, 0.85);
    }

    .report-select option,
    .report-select optgroup {
      background-color: #0b0810;
      color: #fff;
    }

    /* Improve visibility of hovered/selected option in browsers that honor it */
    .report-select option:checked {
      background-color: #1a1220;
      color: #fff;
    }

    .report-textarea {
      min-height: 140px;
      resize: vertical;
    }

    .report-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 1rem;
    }

    .btn-ghost {
      padding: 0.65rem 1.1rem;
      border-radius: 10px;
      border: 1px solid var(--glass-border);
      background: var(--theme-bg3);
      color: var(--text-color);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .btn-ghost:hover {
      transform: translateY(-1px);
    }

    .btn-primary {
      padding: 0.65rem 1.1rem;
      border-radius: 10px;
      border: 1px solid transparent;
      background: linear-gradient(135deg, var(--accent), #ff6b6b);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(166, 108, 255, 0.35);
      transition: transform 0.2s ease;
    }

    .btn-primary:hover {
      transform: translateY(-1px);
    }

    /* Report modal: custom dropdown styled like settings.html */
    .report-modal .custom-select {
      position: relative;
      width: 100%;
      user-select: none;
    }

    .report-modal .select-selected {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid var(--glass-border);
      color: #fff;
      cursor: pointer;
      transition: border-color .2s ease, box-shadow .2s ease, transform .15s ease;
    }

    .report-modal .select-selected:hover {
      transform: translateY(-1px);
    }

    .report-modal .select-arrow {
      display: flex;
      align-items: center;
    }

    .report-modal .select-arrow svg {
      width: 16px;
      height: 16px;
      fill: #cfc9ff;
      opacity: .85;
      transition: transform .2s ease;
    }

    .report-modal .select-items {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      right: 0;
      background: rgba(10, 8, 16, 0.95);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.6);
      padding: 6px;
      display: none;
      max-height: 220px;
      overflow-y: auto;
      z-index: 10002;
    }

    .report-modal .select-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      border-radius: 10px;
      color: #e9e6ff;
      cursor: pointer;
      transition: background .15s ease, box-shadow .15s ease, transform .05s ease;
    }

    .report-modal .select-option:hover {
      background: rgba(120, 70, 255, 0.15);
      box-shadow: inset 0 0 0 1px rgba(166, 108, 255, 0.35);
    }

    .report-modal .select-option[data-selected="true"] {
      background: linear-gradient(135deg, var(--accent), #ff6b6b);
      color: #fff;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.12) inset;
    }

    .report-modal .select-active .select-items {
      display: block;
    }

    .report-modal .select-active .select-arrow svg {
      transform: rotate(180deg);
    }

    /* hide original select but keep it functional if shown by assistive tech */
    .report-modal select.report-select {
      position: absolute;
      inset: auto auto auto -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
    }

    @media (max-width: 768px) {
      .search-top {
        padding: 8px 12px;
        border-radius: 10px;
      }

      .search-top input {
        width: 100%;
        max-width: none;
        font-size: 0.9rem;
      }

      .search-top button {
        width: 34px;
        height: 34px;
      }

      .topbar {
        padding: 0.75rem 1rem;
        flex-wrap: wrap;
        gap: 12px;
      }

      .topbar-search {
        order: 3;
        width: 100%;
        margin-top: 8px;
      }
    }

    header {
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      background: linear-gradient(135deg, rgba(15, 15, 25, 0.8) 0%, rgba(10, 10, 15, 0.9) 100%);
      border-radius: 20px;
      padding: 3rem 2rem;
      margin-bottom: 2rem;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.03) inset;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    header:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.08) inset;
    }

    header::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle at 30% 50%, rgba(167, 139, 250, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 70% 50%, rgba(251, 113, 133, 0.08) 0%, transparent 50%);
      opacity: 0.6;
      pointer-events: none;
      animation: headerGlow 15s ease-in-out infinite;
    }

    @keyframes headerGlow {
      0%, 100% { transform: translate(0, 0) rotate(0deg); }
      50% { transform: translate(10px, 10px) rotate(5deg); }
    }

    h1 {
      font-weight: 700;
      font-size: 3.2rem;
      letter-spacing: -0.5px;
      text-align: center;
      margin-bottom: 0.75rem;
      background: linear-gradient(135deg, #a78bfa 0%, #fb7185 50%, #fbbf24 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 40px rgba(167, 139, 250, 0.3);
      position: relative;
      z-index: 1;
    }

    .subtitle {
      text-align: center;
      opacity: 0.85;
      font-weight: 400;
      margin-bottom: 1.5rem;
      font-size: 1.15rem;
      color: rgba(255, 255, 255, 0.8);
      letter-spacing: 0.3px;
      position: relative;
      z-index: 1;
    }

    /* legacy .search removed in favor of topbar search */
    .search {
      display: none !important;
    }

    #searchInput {
      flex: 1;
      padding: 15px 25px;
      font-size: 1rem;
      border: none;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(34, 34, 34, 0.2);
      color: var(--text-color);
      font-family: 'Poppins', sans-serif;
    }

    #searchInput::placeholder {
      color: var(--text-secondary);
    }

    /* Search button styles now handled by .home-btn class */

    @media (max-width: 1400px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
        gap: 1.25rem;
      }
    }

    @media (max-width: 1200px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        gap: 1.25rem;
      }
    }

    @media (max-width: 992px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 1.25rem;
        padding: 0 1rem;
      }
    }

    @media (max-width: 768px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 1rem;
        padding: 0 0.75rem;
      }
    }

    @media (max-width: 576px) {
      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        gap: 0.75rem;
        padding: 0 0.75rem;
      }

      .poster {
        width: 100% !important;
        max-width: 100% !important;
        min-width: 0 !important;
        margin-left: 0 !important;
        margin-right: 0 !important;
      }

      .movie-title {
        font-size: 0.85rem;
        -webkit-line-clamp: 1;
        line-clamp: 1;
        max-height: 1.4em;
      }
    }

    @media (max-width: 420px) {
      .movies {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.85rem;
      }
    }

    /* Movies Grid Container */
    .movies-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 1.5rem;
      width: 100%;
      max-width: 1500px;
      margin: 0 auto;
      padding: 0 1.5rem;
      box-sizing: border-box;
    }

    .movie-card {
      width: 100%;
      display: flex;
      flex-direction: column;
      background: linear-gradient(135deg, rgba(20, 20, 30, 0.7) 0%, rgba(15, 15, 25, 0.8) 100%);
      border-radius: 16px;
      overflow: hidden;
      transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.04) inset;
      cursor: pointer;
      position: relative;
      will-change: transform, box-shadow, border-color;
      transform: translateZ(0);
      transform-style: preserve-3d;
      aspect-ratio: 2/3;
    }

    .movie-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, transparent 55%, rgba(0, 0, 0, 0.95) 100%);
      z-index: 1;
      opacity: 0;
      transition: opacity 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .movie-card::after {
      content: '';
      position: absolute;
      inset: -1.5px;
      background: linear-gradient(135deg, rgba(167, 139, 250, 0.4), rgba(251, 113, 133, 0.3));
      border-radius: 16px;
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: -1;
      filter: blur(10px);
    }

    .movie-card:hover {
      transform: translateY(-12px) scale(1.025);
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(167, 139, 250, 0.25) inset;
      border-color: rgba(167, 139, 250, 0.5);
    }

    .movie-card:hover::before {
      opacity: 1;
    }

    .movie-card:hover::after {
      opacity: 0.8;
    }

    .poster {
      position: relative;
      width: 100%;
      padding-top: 150%; /* restore original poster height for desktop */
      overflow: hidden;
      background: #1a1a1a;
      max-width: none;
      margin-left: 0;
      margin-right: 0;
    }
    /* Responsive: 3 per row on all screens, smaller posters on mobile */
    @media (max-width: 900px) {
      .movies-grid {
        grid-template-columns: repeat(3, 1fr);
        max-width: 100vw;
      }
      .poster {
        max-width: 160px;
        padding-top: 140%;
      }
    }
    @media (max-width: 600px) {
      .movies-grid {
        grid-template-columns: repeat(3, 1fr);
        gap: 0.7rem;
      }
      .poster {
        max-width: 110px;
        padding-top: 150%;
      }
    }

    .movie-title-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
      padding: 40px 12px 12px;
      color: white;
      font-size: 0.95rem;
      font-weight: 500;
      text-align: center;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.3s ease;
      z-index: 2;
      pointer-events: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .movie-card:hover .movie-title-overlay {
      opacity: 1;
      transform: translateY(0);
    }

    .movie-card:hover .movie-title-overlay {
      opacity: 1;
      transform: translateY(0);
    }

    .poster img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.3s ease, opacity 0.3s ease;
      background: linear-gradient(45deg, #1a1a1a 0%, #2d2d2d 100%);
    }

    .poster img[src*="placeholder"] {
      opacity: 0.7;
    }

    /* Video placeholder inside modal: lightweight until user clicks Play */
    .video-placeholder {
      width: 100%;
      height: 100%;
      position: relative;
      cursor: pointer;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .video-placeholder img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: brightness(0.6);
      display: block;
    }

    .video-play-btn {
      position: absolute;
      width: 84px;
      height: 84px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    .video-play-btn::after {
      content: '';
      display: block;
      width: 0;
      height: 0;
      border-top: 14px solid transparent;
      border-bottom: 14px solid transparent;
      border-left: 20px solid rgb(250, 0, 0);
      margin-left: 6px;
    }

    /* When playing, reduce heavy visual effects to improve playback smoothness */
    .modal.playing {
      background: rgba(0, 0, 0, 0.98);
      backdrop-filter: none;
    }

    .modal.playing .modal-content {
      box-shadow: none;
      border: none;
      background: #0b0b0b;
    }

    /* When playing (dark content), force readable light text inside modal */
    .modal.playing .modal-content,
    .modal.playing .modal-content p,
    .modal.playing .overview,
    .modal.playing .modal-info p,
    .modal.playing .modal-info strong {
      color: rgba(255, 255, 255, 0.92) !important;
    }

    /* Keep rating yellow */
    .modal.playing .movie-rating {
      color: #ffd700 !important;
    }

    /* Badge that shows which MOVIE_* constant controls this card (edit the corresponding CSS blocks below)
       This helps you identify the movie code in VS Code and tweak styles per-movie. */
    .movie-code-badge {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 4px 8px;
      font-size: 0.75rem;
      border-radius: 6px;
      z-index: 5;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    /* Rating badge overlay on poster cards (modern pill style) */
    .poster .rating-badge {
      position: absolute;
      top: 10px;
      left: 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(20, 20, 20, 0.85);
      border: 1px solid rgba(255, 193, 7, 0.28);
      border-radius: 9999px; /* pill */
      color: #ffc107;
      font-weight: 700;
      font-size: 0.9rem;
      z-index: 6;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      pointer-events: none; /* keep clicks going to the card */
    }

    .poster .rating-badge .star {
      line-height: 1;
      font-size: 1rem;
      transform: translateY(-0.5px);
    }

    .poster .rating-badge .value {
      line-height: 1;
    }

    .poster .trending-rank-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      background: rgba(20, 20, 20, 0.85);
      border: 1px solid rgba(255, 61, 87, 0.3);
      border-radius: 8px;
      color: #ff3d57;
      font-weight: 700;
      font-size: 0.95rem;
      z-index: 6;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      pointer-events: none;
      letter-spacing: 0.5px;
    }

    .movie-card:hover .poster img {
      transform: scale(1.05);
      opacity: 0.9;
    }

    .movie-info {
      padding: 0.75rem;
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .movie-title {
      font-size: 1.1rem;
      margin-bottom: 8px;
      font-weight: 500;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      line-clamp: 2;
      overflow: hidden;
      text-overflow: ellipsis;
      max-height: 2.8em;
      line-height: 1.4;
    }

    .movie-rating {
      color: #ffd700;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .play-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      width: 50px;
      height: 50px;
      background: rgba(32, 32, 32, 0.9);
      /* Netflix red with transparency */
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease, background-color 0.2s ease;
      z-index: 2;
      pointer-events: none;
      opacity: 0;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .movie-card:hover .play-icon {
      background: rgb(27, 27, 27, 0.8);
      /* Solid Netflix red on hover */
      transform: translate(-50%, -50%) scale(1.1);
    }

    .movie-card:hover .play-icon {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }

    .play-icon::before {
      content: '';
      width: 0;
      height: 0;
      border-top: 12px solid transparent;
      border-bottom: 12px solid transparent;
      border-left: 18px solid rgb(255, 0, 0);
      margin-left: 4px;
      transition: all 0.2s ease;
    }

    .movie-card:hover .play-icon::before {
      border-top-width: 14px;
      border-bottom-width: 14px;
      border-left-width: 20px;
      margin-left: 6px;
    }

    .card-edit-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.06);
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      cursor: pointer;
      z-index: 4;
      color: white;
      font-size: 14px;
    }

    .movie-card:hover .play-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    /* Modal styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      padding: 1rem;
      z-index: 6000;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      backdrop-filter: blur(20px);
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .modal-content {
      width: 95%;
      max-width: 1000px;
      background: linear-gradient(135deg, rgba(20, 20, 28, 0.95) 0%, rgba(30, 30, 40, 0.98) 100%);
      padding: 0;
      border-radius: 24px;
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 25px 60px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(30px);
      max-height: 90vh;
      overflow-y: auto;
      scrollbar-gutter: stable;
      transition: all 0.3s ease;
      animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .modal-content::-webkit-scrollbar {
      width: 6px;
      background: transparent;
      border-radius: 8px;
      top: 50px;
      /* Hide scrollbar arrows/buttons in Webkit */
      scrollbar-width: none;
      scrollbar-color: #ffff var(--scrollbar-track);
    }

    .modal-content::-webkit-scrollbar-button {
      display: none;
      height: 0;
      width: 0;
    }

    /* Hide scrollbar arrows/buttons in Firefox */
    .modal-content {
      scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
    }

    .modal-content::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border-radius: 8px;
      min-height: 14px;
      border: 14px solid var(--modal-content-bg);
      transition: background 0.2s;
    }

    .modal-content::-webkit-scrollbar-thumb:hover {
      background: var(--scrollbar-thumb-hover);
    }

    .modal-content::-webkit-scrollbar-corner {
      background: var(--modal-content-bg);
    }

    @media (max-width: 768px) {
      .modal-content {
        width: 94vw;
        padding: 1.25rem;
        border-radius: 18px;
      }

      #modalTitle {
        font-size: 1.5rem;
      }
    }

    @media (max-width: 420px) {
      .modal-content {
        width: 96vw;
        padding: 1rem;
        border-radius: 14px;
      }

      .overview {
        font-size: 0.98rem;
      }
    }

    /* In light theme the modal uses a dark background, so force light text for readability */
    [data-theme="light"] .modal .modal-content,
    [data-theme="light"] .modal .modal-content p,
    [data-theme="light"] .modal .overview,
    [data-theme="light"] .modal .modal-info p,
    [data-theme="light"] .modal .modal-info strong {
      color: rgba(255, 255, 255, 0.92);
    }

    [data-theme="light"] .modal .movie-rating {
      color: #ffd700;
    }

    .close-btn {
      position: absolute;
      top: 1.25rem;
      right: 1.5rem;
      font-size: 1.75rem;
      cursor: pointer;
      z-index: 10;
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      color: #ffffff;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      will-change: transform, background-color;
      transform-origin: center;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      backdrop-filter: blur(10px);
    }

    .close-btn:hover {
      background: rgba(229, 9, 20, 0.9);
      border-color: rgba(229, 9, 20, 1);
      transform: rotate(90deg) scale(1.1);
      box-shadow: 0 4px 15px rgba(229, 9, 20, 0.4);
    }

    .close-btn:active {
      transform: rotate(90deg) scale(0.95);
      transition-duration: 0.15s;
    }

    /* Bookmark/Star Button - Inline version */
    .bookmark-btn-inline {
      display: inline-flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.85rem 1.5rem;
      font-size: 0.95rem;
      cursor: pointer;
      border-radius: 12px;
      color: #ffc107;
      background: rgba(255, 193, 7, 0.12);
      border: 1px solid rgba(255, 193, 7, 0.3);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      white-space: nowrap;
      letter-spacing: 0.3px;
    }

    .bookmark-btn-inline:hover {
      background: rgba(255, 193, 7, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
      border-color: rgba(255, 193, 7, 0.4);
    }

    .bookmark-btn-inline:active {
      transform: translateY(0);
    }

    .bookmark-btn-inline.bookmarked {
      background: rgba(255, 193, 7, 0.25);
      border-color: rgba(255, 193, 7, 0.5);
    }

    .bookmark-btn-inline i {
      transition: all 0.2s ease;
      font-size: 1.1rem;
    }

    .bookmark-btn-inline.bookmarked i {
      font-weight: 900;
    }

    @media (max-width: 768px) {
      .bookmark-btn-inline {
        width: 100%;
        justify-content: center;
      }

      .modal-content {
        width: 96%;
        max-height: 92vh;
        border-radius: 20px;
      }

      .modal-header {
        padding: 1.5rem 1.5rem 0.75rem;
      }

      #modalTitle {
        font-size: 1.6rem;
      }

      .modal-meta {
        font-size: 0.85rem;
      }

      .genres,
      .modal-info,
      .modal-actions {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
      }

      .overview {
        padding: 0.75rem 1.5rem;
      }
    }

    @media (max-width: 480px) {
      .modal-content {
        width: 98%;
        border-radius: 16px;
      }

      .modal-header {
        padding: 1.25rem 1.25rem 0.5rem;
      }

      #modalTitle {
        font-size: 1.4rem;
      }

      .overview {
        font-size: 0.92rem;
        padding: 0.75rem 1.25rem;
      }

      .genres,
      .modal-info,
      .modal-actions {
        padding-left: 1.25rem;
        padding-right: 1.25rem;
      }
    }

    .bookmark-text {
      white-space: nowrap;
    }

    /* Light theme adjustments */
    [data-theme="light"] .bookmark-btn-inline {
      background: rgba(255, 215, 0, 0.15);
      border-color: rgba(255, 215, 0, 0.4);
    }

    [data-theme="light"] .bookmark-btn-inline:hover {
      background: rgba(255, 215, 0, 0.3);
    }

    [data-theme="light"] .bookmark-btn-inline.bookmarked {
      background: rgba(255, 215, 0, 0.4);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .bookmark-btn-inline {
        width: 100%;
        justify-content: center;
      }
    }

    /* Light theme contrast improvements */
    [data-theme="light"] .close-btn {
      background: rgba(0, 0, 0, 0.08);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
    }

    [data-theme="light"] .close-btn:hover {
      background: rgba(0, 0, 0, 0.12);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.12);
    }

    [data-theme="light"] .close-btn:active {
      background: rgba(0, 0, 0, 0.18);
    }

    .modal-header {
      padding: 2rem 2.5rem 1rem;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.3) 0%, transparent 100%);
    }

    #modalTitle {
      font-size: 2.2rem;
      margin: 0 0 0.75rem 0;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #e0e0e0 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      line-height: 1.2;
      letter-spacing: -0.5px;
    }

    .modal-meta {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.7);
      font-weight: 500;
    }

    .meta-divider {
      color: rgba(255, 255, 255, 0.3);
    }

    .rating-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.75rem;
      background: rgba(255, 193, 7, 0.15);
      border: 1px solid rgba(255, 193, 7, 0.3);
      border-radius: 20px;
      color: #ffc107;
      font-weight: 600;
    }

    .rating-badge i {
      font-size: 0.85rem;
    }

    /* Modern Custom Dropdown Styles for Series Selector */
    .series-picker {
      display: flex;
      flex-direction: row;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
      padding: 0;
    }

    .series-meta {
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.95rem;
      font-weight: 500;
      flex: 0 0 auto;
    }

    .series-selectors {
      display: flex;
      flex-direction: row;
      gap: 16px;
      align-items: center;
      flex: 1;
    }

    @media (max-width: 600px) {
      .series-selectors {
        flex-direction: column;
        align-items: stretch;
      }
    }

    .custom-select-wrapper {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 10px;
    }

    .select-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.3px;
      white-space: nowrap;
    }

    .custom-select {
      position: relative;
      min-width: 180px;
    }

    .select-trigger {
      background: linear-gradient(135deg, rgba(30, 30, 30, 0.95) 0%, rgba(20, 20, 20, 0.95) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 14px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: all 0.3s ease;
      user-select: none;
    }

    .select-trigger:hover {
      border-color: rgba(167, 139, 250, 0.4);
      background: linear-gradient(135deg, rgba(35, 35, 35, 0.95) 0%, rgba(25, 25, 25, 0.95) 100%);
      box-shadow: 0 4px 12px rgba(167, 139, 250, 0.1);
    }

    .custom-select.active .select-trigger {
      border-color: rgba(167, 139, 250, 0.6);
      box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.1);
    }

    .select-value {
      color: #fff;
      font-size: 0.95rem;
      font-weight: 500;
    }

    .select-arrow {
      color: rgba(255, 255, 255, 0.6);
      transition: transform 0.3s ease;
    }

    .custom-select.active .select-arrow {
      transform: rotate(180deg);
    }

    .select-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      right: 0;
      background: linear-gradient(135deg, rgba(25, 25, 25, 0.98) 0%, rgba(15, 15, 15, 0.98) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      max-height: 280px;
      overflow-y: auto;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
    }

    .custom-select.active .select-dropdown {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .select-dropdown::-webkit-scrollbar {
      width: 6px;
    }

    .select-dropdown::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
    }

    .select-dropdown::-webkit-scrollbar-thumb {
      background: rgba(167, 139, 250, 0.5);
      border-radius: 10px;
    }

    .select-dropdown::-webkit-scrollbar-thumb:hover {
      background: rgba(167, 139, 250, 0.7);
    }

    .select-option {
      padding: 12px 16px;
      cursor: pointer;
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.93rem;
      transition: all 0.2s ease;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .select-option:last-child {
      border-bottom: none;
    }

    .select-option:hover {
      background: rgba(167, 139, 250, 0.15);
      color: #fff;
      padding-left: 20px;
    }

    .select-option.selected {
      background: rgba(167, 139, 250, 0.2);
      color: #fff;
      font-weight: 600;
    }

    .select-option.selected::before {
      content: 'âœ“ ';
      margin-right: 8px;
      color: rgba(167, 139, 250, 1);
    }

    .trailer-container {
      margin: 0;
      width: 100%;
      aspect-ratio: 16/9;
      border-radius: 0;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      position: relative;
      background: #000;
    }

    #trailerFrame {
      width: 100%;
      height: 100%;
      border: none;
    }

    .trailer-youtube-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 0, 0, 0.95);
      border: none;
      color: #fff;
      padding: 12px 18px;
      border-radius: 8px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      box-shadow: 0 4px 12px rgba(255, 0, 0, 0.4);
      transition: all 0.3s ease;
      z-index: 10;
    }

    .trailer-youtube-btn:hover {
      background: rgba(255, 0, 0, 1);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(255, 0, 0, 0.6);
    }

    .overview {
      margin: 0;
      padding: 1rem 2.5rem;
      line-height: 1.8;
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.8);
      font-weight: 400;
    }

    .genres {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 1.25rem 2.5rem 0.75rem;
    }

    .genre-chip {
      padding: 0.4rem 1rem;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.85rem;
      font-weight: 500;
      letter-spacing: 0.3px;
      transition: all 0.2s ease;
    }

    .genre-chip:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .modal-info {
      padding: 0.75rem 2.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .info-item {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.85);
      font-size: 0.9rem;
    }

    .info-item i {
      color: rgba(255, 255, 255, 0.5);
      font-size: 0.95rem;
    }

    .info-item strong {
      opacity: 0.7;
      font-weight: 600;
      margin-right: 0.25rem;
    }

    .modal-actions {
      padding: 1.5rem 2.5rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
      background: linear-gradient(0deg, rgba(0, 0, 0, 0.2) 0%, transparent 100%);
    }

    .stream-buttons {
      display: flex;
      gap: 0.75rem;
      flex: 1;
    }

    .stream-btn {
      position: relative;
      padding: 0.85rem 1.75rem;
      border: none;
      border-radius: 12px;
      color: white;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      overflow: hidden;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      letter-spacing: 0.3px;
      display: inline-flex;
      align-items: center;
      gap: 0.6rem;
      min-width: 140px;
      justify-content: center;
    }

    .primary-stream {
      background: linear-gradient(135deg, #e50914 0%, #b20710 100%);
      box-shadow: 0 4px 15px rgba(229, 9, 20, 0.4);
      flex: 1;
    }

    .secondary-stream {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .stream-btn i {
      font-size: 1rem;
    }

    .stream-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: 0.6s;
    }

    .stream-btn:hover::before {
      left: 100%;
    }

    .stream-btn:hover {
      transform: translateY(-2px);
    }

    .primary-stream:hover {
      box-shadow: 0 6px 20px rgba(229, 9, 20, 0.5);
    }

    .secondary-stream:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
      box-shadow: 0 6px 20px rgba(255, 255, 255, 0.15);
    }

    .stream-btn:active {
      transform: translateY(0);
    }

    .stream-btn.unavailable {
      background: linear-gradient(135deg, rgba(100, 100, 100, 0.3) 0%, rgba(80, 80, 80, 0.3) 100%);
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      pointer-events: none;
    }

    @media (max-width: 768px) {
      .modal-actions {
        flex-direction: column;
      }

      .stream-buttons {
        width: 100%;
        flex-direction: column;
      }

      .stream-btn {
        width: 100%;
      }
    }

    /* Toast notifications */
    .toast-container {
      position: fixed;
      top: 18px;
      right: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 120000;
      /* above modal (6000) and overlays */
      pointer-events: none;
      /* allow clicks through gaps */
    }

    .toast {
      min-width: 260px;
      max-width: 90vw;
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid var(--glass-border);
      background: rgba(22, 22, 28, 0.9);
      color: var(--text-color);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(10px);
      animation: slideIn 280ms ease both;
      pointer-events: auto;
      /* toast itself clickable */
    }

    .toast .icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 28px;
      margin-top: 2px;
      background: rgba(255, 255, 255, 0.06);
    }

    .toast .icon svg {
      width: 16px;
      height: 16px;
      display: block;
    }

    .toast .title {
      font-weight: 600;
      margin-bottom: 2px;
    }

    .toast .msg {
      opacity: 0.9;
    }

    .toast .close {
      margin-left: auto;
      background: transparent;
      border: none;
      color: inherit;
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      opacity: 0.8;
    }

    .toast .close:hover {
      opacity: 1;
    }

    .toast.info {
      border-left: 4px solid #60a5fa;
    }

    .toast.success {
      border-left: 4px solid #34d399;
    }

    .toast.warning {
      border-left: 4px solid #fbbf24;
    }

    .toast.error {
      border-left: 4px solid #f87171;
    }

    .toast.info .icon {
      background: rgba(96, 165, 250, 0.15);
    }

    .toast.success .icon {
      background: rgba(52, 211, 153, 0.15);
    }

    .toast.warning .icon {
      background: rgba(251, 191, 36, 0.15);
    }

    .toast.error .icon {
      background: rgba(248, 113, 113, 0.15);
    }

    @keyframes slideIn {
      from {
        transform: translateY(-8px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Light theme adjustments */
    [data-theme="light"] .toast {
      background: rgba(255, 255, 255, 0.94);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.15);
    }

    /* Modern translucent scrollbars (WebKit/Blink) */
    /* Global scrollbars */
    *::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    *::-webkit-scrollbar-track {
      background: transparent;
    }

    *::-webkit-scrollbar-thumb {
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.18);
      border: 2px solid transparent;
      background-clip: padding-box;
    }

    *::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.28);
      background-clip: padding-box;
    }

    /* Light theme tweak */
    [data-theme="light"] *::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.18);
      border: 2px solid transparent;
      background-clip: padding-box;
    }

    [data-theme="light"] *::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.28);
    }

    /* Modal content specific (ensures consistent look inside modal scroll area) */
    .modal-content::-webkit-scrollbar {
      width: 10px;
      background: var(--scrollbar-track);
      border-radius: 12px;
    }

    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }

      .movies {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 1rem;
      }

      .poster {
        height: 260px;
      }

      h1 {
        font-size: 2rem;
      }

      .modal-content {
        padding: 1.5rem;
      }

      #modalTitle {
        font-size: 1.5rem;
      }
    }

    /* ------------------------------------------------------------------
       Per-movie CSS blocks
       Edit these blocks to change sizes/spacing for each movie individually.
       Example: change the height below to make the poster taller/shorter.
       Keep the class name format: .movie-<id>  where <id> is the MOVIE_* id.
       ------------------------------------------------------------------ */
    /* Continue Watching Section */
    .continue-watching {
      margin: 0 0 2.5rem 0;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 2rem 0 3rem 0;
      color: var(--text-color);
    }

    .continue-watching-container {
      display: flex;
      gap: 1rem;
      overflow-x: auto;
      padding-bottom: 1rem;
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
      min-height: 280px;
      /* Match the height of the cards */
      position: relative;
      /* For absolute positioning of empty state */
    }

    .continue-watching-container:empty::before {
      /* Hidden by default - only shows when container is actually empty */
      display: none;
    }

    .continue-watching-container::-webkit-scrollbar-track {
      background: transparent;
    }

    .continue-watching-container::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.25);
      border-radius: 3px;
    }

    .continue-watching-item {
      flex: 0 0 200px;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .continue-watching-item:hover {
      transform: translateY(-5px);
    }

    .continue-watching-poster {
      width: 100%;
      height: 280px;
      object-fit: cover;
      border-radius: 8px;
    }

    .continue-watching-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 1rem;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));
      color: white;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .continue-watching-item:hover .continue-watching-overlay {
      opacity: 1;
    }

    .continue-watching-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .progress-bar {
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      margin-bottom: 0.5rem;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #6366f1;
      width: 0%;
      transition: width 0.3s ease;
    }

    .resume-btn {
      display: block;
      width: 100%;
      padding: 0.5rem;
      background: #6366f1;
      color: white;
      border: none;
      border-radius: 6px;
      font-weight: 500;
      cursor: pointer;
      text-align: center;
      transition: background 0.2s ease;
    }

    .resume-btn:hover {
      background: #4f46e5;
    }

    /* Continue Watching Section */
    .continue-watching-section {
      margin: 6rem 0 2rem 0;
      padding: 1.5rem;
      position: relative;
      min-height: 100px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(20, 20, 30, 0.5) 0%, rgba(15, 15, 25, 0.6) 100%);
      border: 1px solid rgba(255, 255, 255, 0.07);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(12px);
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .continue-watching-section:hover {
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.08) inset;
      border-color: rgba(167, 139, 250, 0.15);
    }

    .continue-watching-section [title] {
      position: relative;
    }

    .continue-watching-section [title]:hover::after,
    .continue-watching-section [title]:focus::after {
      content: none !important;
      display: none !important;
    }

    .section-header {
      font-size: 1.8rem;
      font-weight: 700;
      margin-bottom: 1.5rem;
      background: linear-gradient(135deg, #fff 0%, #e0e0e0 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      letter-spacing: -0.3px;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .section-header i {
      color: rgba(167, 139, 250, 0.8);
      font-size: 1.6rem;
      background: linear-gradient(135deg, rgba(167, 139, 250, 0.6), rgba(251, 113, 133, 0.6));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .section-header i {
      color: rgba(167, 139, 250, 0.8);
      font-size: 1.6rem;
      background: linear-gradient(135deg, rgba(167, 139, 250, 0.6), rgba(251, 113, 133, 0.6));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    /* Clear All button styles removed */

    .continue-watching-section h2.section-title {
      font-size: 1.5rem;
      margin: 4rem 0 3rem 0;
      color: #fff;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .continue-watching-section h2 {
      font-size: 1.5rem;
      height: 6px;
    }

    .continue-watching-container::-webkit-scrollbar-track {
      background: transparent;
      border-radius: 3px;
    }

    .continue-watching-container::-webkit-scrollbar-thumb {
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    .continue-watching-card {
      flex: 0 0 180px;
      width: 180px;
      margin: 0;
      border-radius: 8px;
      overflow: hidden;
      background: rgba(30, 30, 30, 0.9);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      position: relative;
      margin: 0 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .continue-watching-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      z-index: 5;
    }

    .continue-watching-poster {
      position: relative;
      width: 100%;
      padding-top: 150%;
      overflow: hidden;
      background: #1a1a1a;
    }

    .continue-watching-poster img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.3s ease;
      background: linear-gradient(45deg, #2a2a2a, #1a1a1a);
    }

    .continue-watching-card:hover .continue-watching-poster img {
      transform: scale(1.05);
    }

    .progress-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(0, 0, 0, 0.4);
      z-index: 15;
      /* Higher than resume overlay */
    }

    .progress-bar .progress {
      height: 100%;
      background: #e50914;
      transition: width 0.3s ease;
    }

    .progress {
      height: 100%;
      background: #e50914;
      background: linear-gradient(90deg, #e50914, #f01828);
      width: 0;
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      box-shadow: 0 0 10px rgba(229, 9, 20, 0.3);
    }

    .progress::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg,
          rgba(255, 255, 255, 0) 0%,
          rgba(255, 255, 255, 0.2) 50%,
          rgba(255, 255, 255, 0) 100%);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    .resume-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to bottom,
          rgba(0, 0, 0, 0.7) 0%,
          rgba(0, 0, 0, 0.3) 30%,
          rgba(0, 0, 0, 0.1) 50%,
          rgba(0, 0, 0, 0.3) 70%,
          rgba(0, 0, 0, 0.7) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 10;
      pointer-events: none;
      /* Allow clicking through to the remove button */
    }

    .resume-overlay>* {
      pointer-events: auto;
      /* But allow clicks on the resume button */
    }

    .continue-watching-card:hover .resume-overlay {
      opacity: 1;
    }

    .resume-button {
      background: #1d1c1c;
      color: rgb(255, 255, 255);
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transform: translateY(10px);
      opacity: 0;
    }

    .continue-watching-card:hover .resume-button {
      transform: translateY(0);
      opacity: 1;
      transition-delay: 0.1s;
    }

    .resume-button:hover {
      background: #0e0d0d;
      border: 1px solid #ffffff;
      transform: translateY(-2px) !important;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    }

    .resume-button:active {
      transform: translateY(0) !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .resume-button::before {
      content: '';
      font-size: 0.8rem;
    }

    .continue-watching-info {
      padding: 0.75rem;
    }

    .continue-watching-info h3 {
      font-size: 0.95rem;
      margin: 0 0 0.25rem;
      color: var(--text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .continue-watching-info p {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.7);
      margin: 0;
    }

    .continue-watching-poster {
      position: relative;
      overflow: visible;
      border-radius: 6px 6px 0 0;
      z-index: 1;
    }

    .remove-button {
      position: absolute;
      top: -260px;
      right: -140px;
      width: 32px;
      height: 32px;
      background: transparent;
      border: 1.5px solid white !important;
      border-radius: 50%;
      color: white !important;
      display: flex !important;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      line-height: 1;
      padding: 0;
      opacity: 1 !important;
      visibility: visible !important;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000 !important;
      margin: 0;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.7);
    }

    .continue-watching-card .remove-button {
      opacity: 0 !important;
      visibility: hidden !important;
      transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease !important;
    }

    .continue-watching-card:hover .remove-button {
      opacity: 1 !important;
      visibility: visible !important;
    }

    .continue-watching-card .remove-button:hover {
      transform: scale(1.15) !important;
      background: #ff0a16 !important;
      box-shadow: 0 0 0 2px rgba(255, 10, 22, 0.6) !important;
    }

    .remove-button:hover {
      background: #e50914;
      transform: scale(1.2) !important;
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: 0 0 0 2px rgba(255, 0, 0, 0.3);
    }

    .remove-button:active {
      transform: scale(0.9) !important;
      background: #c40811;
    }

    .remove-button:hover {
      background: #e50914;
      transform: scale(1.1);
    }

    @media (max-width: 768px) {
      .continue-watching-card {
        flex: 0 0 140px;
        width: 140px;
      }

      .continue-watching-info h3 {
        font-size: 0.85rem;
      }

      .continue-watching-info p {
        font-size: 0.75rem;
      }
    }

    @media (max-width: 480px) {
      .continue-watching-card {
        flex: 0 0 120px;
        width: 120px;
      }

      .continue-watching-section h2 {
        font-size: 1.25rem;
      }

      .remove-button {
        opacity: 1;
        width: 22px;
        height: 22px;
        font-size: 1rem;
      }
    }

    /* Small phones: leave space for the user button on the right */
    @media (max-width: 480px) {
      #userMenuComponent {
        right: 0.5rem;
        top: 0.5rem;
      }

      .user-menu-btn {
        padding: 4px 8px;
        gap: 6px;
        border-radius: 10px;
      }

      .user-avatar {
        width: 28px;
        height: 28px;
      }

      .user-name {
        display: none;
      }

      .user-dropdown {
        min-width: 200px;
        right: 0;
        left: auto;
        transform: translateY(8px);
      }

      .user-dropdown::before {
        right: 16px;
      }

      /* Constrain search to avoid overlapping user menu */
      #searchComponent {
        top: 0.5rem;
        left: 1rem;
        right: 9.5rem;
        transform: none;
        width: auto;
        max-width: none;
        padding: 0;
      }

      .search-top {
        height: 46px;
        gap: 8px;
        padding: 8px 12px;
        border-radius: 16px;
        max-width: 100%;
        width: 100%;
        background: rgba(20, 20, 28, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
        align-items: center;
        background-clip: padding-box;
      }

      /* Remove outer glow ring on mobile */
      .search-top::before {
        display: none !important;
        opacity: 0 !important;
      }

      .search-top .search-icon {
        width: 18px;
        height: 18px;
        opacity: 0.85;
      }

      .search-top input {
        font-size: 0.92rem;
        line-height: 1.2;
        min-width: 100px;
        padding: 0 6px;
      }

      .search-top:focus-within .search-icon {
        transform: none;
      }

      .search-results-container {
        top: 72px;
        left: 0.5rem;
        right: 0.5rem;
        width: auto;
        transform: none;
        max-height: 65vh;
        padding: 12px;
        border-radius: 14px;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.35);
      }
    }

    /* Narrow tablets / large phones */
    @media (max-width: 640px) and (min-width: 481px) {
      #userMenuComponent {
        right: 0.75rem;
        top: 0.75rem;
      }

      #searchComponent {
        top: 0.75rem;
        left: 1rem;
        right: 10rem;
        transform: none;
        width: auto;
      }

      .search-top {
        height: 56px;
        padding: 10px 12px;
        max-width: 100%;
        width: 100%;
        border-radius: 18px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .search-top .home-btn,
      .search-top button {
        width: 48px;
        height: 48px;
        border-radius: 999px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .search-input-wrapper {
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
        border-radius: 999px;
      }

      .search-top input {
        width: 100%;
        min-width: 0;
        padding: 12px 16px;
        font-size: 1rem;
        line-height: 1.25;
      }

      .search-results-container {
        left: 1rem;
        right: 10rem;
        width: auto;
        transform: none;
        top: 84px;
      }
    }

    /* Tablets / landscape phones: 641â€“900px */
    @media (min-width: 641px) and (max-width: 900px) {
      #userMenuComponent {
        right: 1rem;
        top: 1rem;
      }

      /* Leave more room for the user button at this size */
      #searchComponent {
        top: 1rem;
        left: 1rem;
        right: 12rem;
        transform: none;
        width: auto;
      }

      .search-top {
        height: 56px;
        padding: 10px 14px;
        border-radius: 18px;
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(20, 20, 28, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.30);
      }

      .search-top .home-btn,
      .search-top button {
        width: 48px;
        height: 48px;
        border-radius: 999px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .search-input-wrapper {
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .search-top input {
        width: 100%;
        min-width: 0;
        padding: 12px 16px;
        font-size: 1rem;
        line-height: 1.25;
      }

      .search-results-container {
        left: 1rem;
        right: 12rem;
        width: auto;
        transform: none;
        top: 90px;
      }
    }

    /* Unified phones <=600px: make everything inside the search bar fit */
    @media (max-width: 600px) {

      /* Ensure the component uses available width and items don't overflow */
      #searchComponent {
        width: auto;
      }

      .search-top {
        display: flex;
        align-items: center;
        gap: 10px;
        height: 56px;
        padding: 10px 12px;
        background: rgba(20, 20, 28, 0.92);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 18px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.30);
      }

      .search-top .search-icon {
        width: 16px;
        height: 16px;
        opacity: 0.85;
      }

      /* Circular icon buttons (home, search) */
      .search-top .home-btn,
      .search-top button {
        width: 48px;
        height: 48px;
        border-radius: 999px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.04) inset, 0 6px 16px rgba(0, 0, 0, 0.35);
      }

      .search-input-wrapper {
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .search-top input {
        width: 100%;
        min-width: 0;
        padding: 12px 16px;
        font-size: 1rem;
        line-height: 1.25;
        text-overflow: ellipsis;
      }

      .search-top button:active {
        transform: translateY(0);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
      }

      .search-results-container {
        left: 1rem;
        right: 9.5rem;
        width: auto;
        max-height: 65vh;
        top: 84px;
      }
    }

    /* Hide brand on small screens */
    @media (max-width: 640px) {

      #brandComponent,
      .brand {
        display: none !important;
      }
    }

    @media (max-width: 360px) {
      .search-top {
        height: 40px;
        padding: 4px 8px;
      }

      .user-avatar {
        width: 24px;
        height: 24px;
      }
    }
  </style>
</head>

<body>
  <!-- Particle Background -->
  <div class="bg-particles" id="particles"></div>




  <div class="container">
    <!-- Topbar Components -->
    <div class="topbar-wrapper">
      <!-- Brand/Logo Component -->
      <div class="topbar-component" id="brandComponent">
        <div class="brand">
          <h1 class="brand-title">Cinematic Hub</h1>
          <div class="brand-sub">Curated collection</div>
        </div>
      </div>

      <!-- Search Component -->
      <div class="topbar-component" id="searchComponent">
        <div class="search-top" id="searchTop">
          <button id="homeBtn" class="home-btn" aria-label="Home" title="Show all movies">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
              <path
                d="M8.707 1.5a1 1 0 0 0-1.414 0L.646 8.146a.5.5 0 0 0 .708.708L8 2.207l6.646 6.647a.5.5 0 0 0 .708-.708L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.707 1.5Z" />
              <path d="m8 3.293 6 6V13.5a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 13.5V9.293l6-6Z" />
            </svg>
          </button>
          <button id="searchBtn" class="home-btn" aria-label="Search" title="Search movies">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
              <path
                d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0" />
            </svg>
          </button>
          <input type="text" id="searchInput" placeholder="Search movies, genres, year..." aria-label="Search movies" />
          <div class="search-overlay"></div>
        </div>
      </div>

      <!-- Modern User Menu Component -->
      <div id="userMenuComponent">
        <button class="user-menu-btn" id="userMenuBtn">
          <div class="user-avatar" id="userAvatar">
            <img id="userAvatarImg" src="" alt="Profile"
              style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; display: none;">
            <span id="userInitial" style="position: absolute; font-weight: 600; font-size: 14px; color: white;">U</span>
          </div>
          <span class="user-name" id="userName">User</span>
          <i class="fas fa-chevron-down user-caret"></i>
        </button>

        <div class="user-dropdown">
          <a href="profiles.html" class="dropdown-item">
            <i class="fas fa-user"></i>
            <span>Switch Profile</span>
          </a>
          <a href="mylist.html" class="dropdown-item" id="myListLink">
            <i class="far fa-bookmark"></i>
            <span>My List</span>
          </a>
          <a href="settings.html" class="dropdown-item" id="settingsLink">
            <i class="fas fa-cog"></i>
            <span>Settings</span>
          </a>
          <div class="dropdown-divider"></div>
          <a href="#" class="dropdown-item" id="helpLink">
            <i class="fas fa-question-circle"></i>
            <span>Help Center</span>
          </a>
          <div class="dropdown-divider"></div>
          <a href="#" class="dropdown-item" id="signOutLink">
            <i class="fas fa-sign-out-alt"></i>
            <span>Sign Out</span>
          </a>
        </div>
      </div>

      <script>
        // Show resume prompt modal if there is a valid continue watching entry
        document.addEventListener('DOMContentLoaded', function () {
          try {
            const continueWatchingStr = localStorage.getItem(getContinueWatchingKey());
            const continueWatching = continueWatchingStr ? JSON.parse(continueWatchingStr) : {};
            // Find the most recent valid entry
            const validMovies = Object.values(continueWatching).filter(m => {
              return m && m.progress > 0 && m.progress < 95 && m.title && m.title !== 'Untitled';
            });
            if (validMovies.length > 0) {
              validMovies.sort((a, b) => (Number(b.updatedAt || b.timestamp || 0)) - (Number(a.updatedAt || a.timestamp || 0)));
              const movie = validMovies[0];
              // Only show if not already on player.html and not in search mode
            }
          } catch (e) { console.error('Resume prompt error:', e); }
        });

        // Toggle user dropdown
        const userMenuBtn = document.getElementById('userMenuBtn');

        // Handle dropdown toggle
        if (userMenuBtn) {
          userMenuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            userMenuBtn.classList.toggle('active');
          });

          // Close dropdown when clicking outside
          document.addEventListener('click', (e) => {
            if (!e.target.closest('#userMenuComponent')) {
              userMenuBtn.classList.remove('active');
            }
          });

          // Close dropdown when pressing Escape key
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
              userMenuBtn.classList.remove('active');
            }
          });

          // Handle sign out
          const signOutLink = document.getElementById('signOutLink');
          if (signOutLink) {
            signOutLink.addEventListener('click', async (e) => {
              e.preventDefault();
              try {
                await FirebaseAuth.signOut();
                window.location.href = 'login.html';
              } catch (error) {
                console.error('Error signing out:', error);
              }
            });
          }

          // Handle settings navigation
          const settingsLink = document.getElementById('settingsLink');
          if (settingsLink) {
            settingsLink.addEventListener('click', (e) => {
              userMenuBtn.classList.remove('active');
              // Let the default link behavior handle the navigation
            });
          }


          // Handle help link â†’ open in-app report modal
          const helpLink = document.getElementById('helpLink');
          if (helpLink) {
            helpLink.addEventListener('click', (e) => {
              e.preventDefault();
              userMenuBtn.classList.remove('active');
              if (typeof showReportProblem === 'function') showReportProblem();
            });
          }
        }

        // Load user profile data
        async function loadUserProfile() {
          try {
            console.log('Loading user profile...');
            const user = FirebaseAuth.getUser();
            console.log('Current user:', user);
            if (!user) {
              console.log('No user logged in');
              return;
            }

            // Get the selected profile
            console.log('Fetching profile for user:', user.uid);
            const profile = await FirebaseAuth.getSelectedProfile(user.uid);
            console.log('Retrieved profile:', profile);
            if (!profile) {
              console.log('No profile found for user');
              return;
            }

            const userAvatar = document.getElementById('userAvatar');
            const userAvatarImg = document.getElementById('userAvatarImg');
            const userInitial = document.getElementById('userInitial');
            const userNameEl = document.getElementById('userName');

            if (profile.name && userNameEl) {
              userNameEl.textContent = profile.name;
              userNameEl.classList.remove('hide-mobile');
              if (profile.name.length >= 5 && window.matchMedia('(orientation: portrait)').matches) {
                userNameEl.classList.add('hide-mobile');
              }
            }

            if (profile.avatarUrl) {
              // Show the avatar image if available
              userAvatarImg.src = profile.avatarUrl;
              userAvatarImg.style.display = 'block';
              userInitial.style.display = 'none';

              // Add a fallback in case the image fails to load
              userAvatarImg.onerror = () => {
                userAvatarImg.style.display = 'none';
                if (profile.name) {
                  userInitial.textContent = profile.name.charAt(0).toUpperCase();
                }
                userInitial.style.display = 'flex';
              };
            } else if (profile.name) {
              // Fallback to initial if no avatar URL
              userInitial.textContent = profile.name.charAt(0).toUpperCase();
              userInitial.style.display = 'flex';
              userAvatarImg.style.display = 'none';
            }

            // Update the avatar background with the profile color if available
            if (profile.color) {
              userAvatar.style.background = profile.color;
            }

          } catch (error) {
            console.error('Error loading user profile:', error);
            // Fallback to default if there's an error
            const userNameEl = document.getElementById('userName');
            const userInitial = document.getElementById('userInitial');
            if (userNameEl) userNameEl.textContent = 'User';
            if (userInitial) userInitial.textContent = 'U';
          }
        }

        // Load profile when auth state changes
        console.log('Setting up auth state listener...');
        if (typeof FirebaseAuth !== 'undefined') {
          console.log('FirebaseAuth is defined, version:', FirebaseAuth.SDK_VERSION);

          // Set up auth state listener
          FirebaseAuth.onAuthChanged((user) => {
            console.log('Auth state changed, user:', user ? 'Logged in' : 'Logged out');
            if (user) {
              console.log('User is signed in, loading profile...');
              loadUserProfile();
            } else {
              console.log('No user is signed in');
            }
          });

          // Also try loading immediately in case auth is already done
          console.log('Checking current auth state...');
          const currentUser = FirebaseAuth.getUser();
          console.log('Current user from immediate check:', currentUser);
          if (currentUser) {
            console.log('User already authenticated, loading profile...');
            loadUserProfile();
          }
        }
      </script>
    </div>

    <!-- Continue Watching Section -->
    <section id="continueWatchingSection" class="continue-watching-section" style="display: block;">
      <div class="section-header">
        <h2 class="section-title">
          <i class="fas fa-redo"></i> Continue Watching
        </h2>
        <button id="cwClearAll" class="cw-clear-btn" aria-label="Clear all continue watching" title="Clear All">
          <span class="cw-clear-icon">ðŸ§¹</span>
          <span class="cw-clear-text">Clear All</span>
        </button>
      </div>
      <div class="continue-watching-container" id="continueWatchingContainer"></div>
    </section>

    <!-- Category Buttons Mount -->
    <div id="categoryBarMount" style="margin: 1rem 20px 0;"></div>

    <section class="movies-section" id="popularMoviesSection">
      <div class="section-header">
        <h2 class="section-title">
          <i class="fas fa-fire"></i> Popular Movies
        </h2>
      </div>
      <div class="movies-grid" id="trendingMoviesContainer"></div>
    </section>

    <section class="movies-section" id="popularTVSection">
      <div class="section-header">
        <h2 class="section-title">
          <i class="fas fa-tv"></i> Popular Series
        </h2>
      </div>
      <div class="movies-grid" id="trendingTVContainer"></div>
    </section>

    <div class="movies" id="moviesContainer"></div>
  </div>

  <div class="modal" id="movieModal">
    <div class="modal-content">
      <span class="close-btn" id="closeModal">&times;</span>
      
      <div class="modal-header">
        <h2 id="modalTitle"></h2>
        <div class="modal-meta">
          <span class="meta-item" id="modalYear"></span>
          <span class="meta-divider">â€¢</span>
          <span class="meta-item rating-badge">
            <i class="fas fa-star"></i>
            <span id="modalRating"></span>
          </span>
        </div>
      </div>

      <div class="trailer-container">
        <div id="trailerHost" class="video-placeholder" aria-label="Click to play trailer">
          <img id="trailerPlaceholderImg" src="" alt="Trailer preview" />
          <div class="video-play-btn" title="Play trailer"></div>
        </div>
      </div>

      <div class="genres" id="modalGenres"></div>
      
      <p class="overview" id="modalOverview"></p>
      
      <div class="modal-info">
        <div class="info-item">
          <i class="fas fa-calendar-alt"></i>
          <span><strong>Release:</strong> <span id="modalReleaseDate"></span></span>
        </div>
      </div>

      <div class="modal-actions">
        <div class="stream-buttons">
          <button class="stream-btn primary-stream" id="streamBtn" aria-disabled="false">
            <i class="fas fa-play"></i>
            <span>Watch Now</span>
          </button>
          <button class="stream-btn secondary-stream" id="streamBtn2" aria-disabled="false">
            <i class="fas fa-play-circle"></i>
            <span>Stream 2</span>
          </button>
        </div>
        <div class="series-picker" id="seriesPicker" style="display:none;">
          <div class="series-meta" id="seriesMeta"></div>
          <div class="series-selectors">
            <div class="custom-select-wrapper">
              <label class="select-label">Season</label>
              <div class="custom-select" id="seasonSelectWrapper">
                <div class="select-trigger" id="seasonTrigger">
                  <span class="select-value">Select Season</span>
                  <svg class="select-arrow" width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                    <path d="M2 4l4 4 4-4H2z"/>
                  </svg>
                </div>
                <div class="select-dropdown" id="seasonDropdown"></div>
              </div>
              <select id="seasonSelect" style="display: none;"></select>
            </div>
            <div class="custom-select-wrapper">
              <label class="select-label">Episode</label>
              <div class="custom-select" id="episodeSelectWrapper">
                <div class="select-trigger" id="episodeTrigger">
                  <span class="select-value">Select Episode</span>
                  <svg class="select-arrow" width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                    <path d="M2 4l4 4 4-4H2z"/>
                  </svg>
                </div>
                <div class="select-dropdown" id="episodeDropdown"></div>
              </div>
              <select id="episodeSelect" style="display: none;"></select>
            </div>
          </div>
          <button id="seriesPlayBtn" class="stream-btn primary-stream">
            <i class="fas fa-play"></i>
            <span>Play Episode</span>
          </button>
          <button id="openOnYouTubeBtn" class="stream-btn" style="display:none; background:#FF0000; border:none; color:#fff; padding:10px 14px; border-radius:8px; cursor:pointer; align-items:center; gap:6px;">
            <span>Open on YouTube</span>
            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
              <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
            </svg>
          </button>
        </div>
        <button class="bookmark-btn-inline" id="bookmarkBtn" title="Add to My List" aria-label="Add to My List">
          <i class="far fa-bookmark"></i>
          <span class="bookmark-text">My List</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Toast container -->
  <div id="toastContainer" class="toast-container" aria-live="polite" aria-atomic="true"></div>

  <script>

    // --- Ensure themePresets and isSearching are declared first ---
    const themePresets = {
      glossy: {
        bgs: ['rgba(255,255,255,0.06)', 'rgba(255,0,100,0.10)', 'rgba(0,120,255,0.10)'],
        accent: 'linear-gradient(90deg,#ff6b6b,#6b66ff)',
        particles: ['#ff6b6b', '#6b66ff']
      },
      crimson: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(220,38,38,0.14)', 'rgba(244,63,94,0.12)'],
        accent: 'linear-gradient(90deg,#ef4444,#f97316)',
        particles: ['#ef4444', '#f97316']
      },
      ocean: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(14,165,233,0.14)', 'rgba(6,182,212,0.12)'],
        accent: 'linear-gradient(90deg,#22d3ee,#60a5fa)',
        particles: ['#22d3ee', '#60a5fa']
      },
      emerald: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(5,150,105,0.14)', 'rgba(16,185,129,0.12)'],
        accent: 'linear-gradient(90deg,#10b981,#22c55e)',
        particles: ['#10b981', '#22c55e']
      },
      purple: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(147,51,234,0.14)', 'rgba(99,102,241,0.12)'],
        accent: 'linear-gradient(90deg,#a78bfa,#6366f1)',
        particles: ['#a78bfa', '#6366f1']
      },
      sunset: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(251,146,60,0.16)', 'rgba(236,72,153,0.12)'],
        accent: 'linear-gradient(90deg,#f59e0b,#ec4899)',
        particles: ['#f59e0b', '#ec4899']
      },
      neon: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(34,211,238,0.18)', 'rgba(217,70,239,0.14)'],
        accent: 'linear-gradient(90deg,#22d3ee,#d946ef)',
        particles: ['#22d3ee', '#d946ef']
      },
      graphite: {
        bgs: ['rgba(255,255,255,0.04)', 'rgba(107,114,128,0.18)', 'rgba(75,85,99,0.14)'],
        accent: 'linear-gradient(90deg,#6b7280,#9ca3af)',
        particles: ['#6b7280', '#9ca3af']
      },
      gold: {
        bgs: ['rgba(255,255,255,0.05)', 'rgba(234,179,8,0.18)', 'rgba(245,158,11,0.14)'],
        accent: 'linear-gradient(90deg,#eab308,#f59e0b)',
        particles: ['#eab308', '#f59e0b']
      }
    };
    let isSearching = false; // Track if we're currently showing search results

    // ...existing code...
    (function loadYouTubeAPI() {
      if (window.YT && window.YT.Player) return;
      const s = document.createElement('script');
      s.src = 'https://www.youtube.com/iframe_api';
      s.async = true;
      document.head.appendChild(s);
    })();

    let ytPlayer = null;
    let ytPlayerId = null;
    let pendingPlayer = null; // {host, key}
    let ytReady = false;
    const ytQueue = [];
    let currentTrailerKey = null; // Store current trailer key for fallback

    window.onYouTubeIframeAPIReady = function() {
      ytReady = true;
      while (ytQueue.length) {
        const req = ytQueue.shift();
        if (req && req.host && req.key) {
          createYTPlayerFor(req.host, req.key);
        }
      }
    };

    function createYTPlayerFor(host, key) {
      if (!host || !key) return;

      // Queue if API not ready
      if (!ytReady || !window.YT || !YT.Player) {
        ytQueue.push({ host, key });
        pendingPlayer = { host, key };
        return;
      }

      // Store current key for fallback
      currentTrailerKey = key;

      // Clear existing content
      host.innerHTML = '';

      const id = `yt-player-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
      const wrapper = document.createElement('div');
      wrapper.id = id;
      wrapper.style.width = '100%';
      wrapper.style.height = '100%';
      host.appendChild(wrapper);

      ytPlayerId = id;
      ytPlayer = new YT.Player(id, {
        videoId: key,
        playerVars: {
          autoplay: 1,
          rel: 0,
          modestbranding: 1,
          playsinline: 1
        },
        events: {
          onReady: (event) => {
            try { event.target.playVideo(); } catch (_) {}
          },
          onError: (err) => {
            console.warn('YouTube embed error', err);
            // Show error message in player area
            const container = document.getElementById(id);
            if (container && container.parentElement) {
              container.parentElement.innerHTML = `
                <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#1a1a1a;color:#fff;flex-direction:column;gap:15px;padding:20px;text-align:center;">
                  <svg width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                  </svg>
                  <div style="font-size:1.1rem;font-weight:500;">This video cannot be embedded</div>
                  <div style="font-size:0.9rem;color:#999;max-width:400px;">The video owner has restricted playback on other websites.</div>
                  <a href="https://www.youtube.com/watch?v=${key}" target="_blank" style="margin-top:10px;padding:10px 20px;background:#e50914;color:#fff;text-decoration:none;border-radius:6px;font-weight:500;">Watch on YouTube</a>
                </div>
              `;
            }
          }
        }
      });
    }

    // All hardcoded movies removed - using TMDB API instead


    const curatedMovies = [];
    // Note: Using TMDB API instead of hardcoded movies to avoid conflicts

    // Support email config (edit this to your target email)
    const SUPPORT_EMAIL = 'moive776@gmail.com';
    // Email sending is now handled securely via backend API. All client-side EmailJS config and usage removed.

    function showReportProblem() {
      // prevent duplicates
      if (document.querySelector('.report-overlay')) return;
      const overlay = document.createElement('div');
      overlay.className = 'report-overlay';
      const modal = document.createElement('div');
      modal.className = 'report-modal';
      modal.innerHTML = `
          <div class="report-title">
            <i class="fas fa-life-ring"></i>
            Report a Problem
          </div>
          <div class="report-grid">
            <div class="report-field">
              <label for="reportType">Category</label>
              <select id="reportType" class="report-select">
                <option>Playback issue</option>
                <option>Subtitles</option>
                <option>Login / Profiles</option>
                <option>Continue Watching</option>
                <option>Other</option>
              </select>
            </div>
            <div class="report-field">
              <label for="reportEmail">Your email (optional)</label>
              <input id="reportEmail" class="report-input" type="email" placeholder="you@example.com" />
            </div>
          </div>
          <div class="report-grid full" style="margin-top:10px;">
            <div class="report-field">
              <label for="reportSubject">Subject</label>
              <input id="reportSubject" class="report-input" type="text" placeholder="Short summary" />
            </div>
            <div class="report-field">
              <label for="reportDesc">Description</label>
              <textarea id="reportDesc" class="report-textarea" placeholder="Describe what happened, steps to reproduce, expected vs actual..."></textarea>
            </div>
            <label style="display:flex;align-items:center;gap:8px;margin-top:4px;color:var(--text-secondary);font-size:0.9rem;">
              <input id="reportDiag" type="checkbox" checked /> Include diagnostics (browser, page, profile)
            </label>
          </div>
          <div class="report-actions">
            <button class="btn-ghost" id="reportCancel">Cancel</button>
            <button class="btn-primary" id="reportSubmit">Report</button>
          </div>
        `;
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
      document.body.classList.add('modal-open');

      // Add mobile-specific style for report email input
      const style = document.createElement('style');
      style.innerHTML = `
          @media (max-width: 600px) {
            .report-modal .report-input[type="email"] {
              max-width: 220px;
              width: 90%;
              min-width: 140px;
            }
          }
        `;
      document.head.appendChild(style);

      // Prefill user email if available
      try {
        const getUser = window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function' ? window.FirebaseAuth.getUser : null;
        const user = getUser ? getUser() : null;
        if (user && user.email) modal.querySelector('#reportEmail').value = user.email;
      } catch (_) { }

      // Build a custom dropdown for Category, matching settings.html style
      (function () {
        const nativeSelect = modal.querySelector('#reportType');
        if (!nativeSelect) return;
        const field = nativeSelect.parentElement;
        // Create custom structure
        const selectedText = nativeSelect.options[nativeSelect.selectedIndex]?.text || nativeSelect.options[0]?.text || '';
        const custom = document.createElement('div');
        custom.className = 'custom-select';
        custom.innerHTML = `
            <div class="select-selected" tabindex="0">
              <span class="selected-option">${selectedText}</span>
              <span class="select-arrow">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M7 10l5 5 5-5z"></path></svg>
              </span>
            </div>
            <div class="select-items" role="listbox"></div>
          `;
        const items = custom.querySelector('.select-items');
        // Populate items from native select
        Array.from(nativeSelect.options).forEach(opt => {
          const div = document.createElement('div');
          div.className = 'select-option';
          div.textContent = opt.textContent;
          div.dataset.value = opt.value || opt.textContent;
          if (opt.selected) div.setAttribute('data-selected', 'true');
          items.appendChild(div);
        });

        // Hide native select (kept for value/state)
        nativeSelect.classList.add('report-select');
        field.appendChild(custom);

        const selBtn = custom.querySelector('.select-selected');
        const selectedSpan = custom.querySelector('.selected-option');
        const optionDivs = Array.from(items.querySelectorAll('.select-option'));

        function openClose(toggle) {
          const makeOpen = toggle === undefined ? !custom.classList.contains('select-active') : !!toggle;
          custom.classList.toggle('select-active', makeOpen);
        }

        function choose(value, text) {
          nativeSelect.value = value;
          selectedSpan.textContent = text;
          optionDivs.forEach(d => d.removeAttribute('data-selected'));
          const match = optionDivs.find(d => (d.dataset.value === value));
          if (match) match.setAttribute('data-selected', 'true');
          openClose(false);
        }

        selBtn.addEventListener('click', (e) => { e.stopPropagation(); openClose(); });
        selBtn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openClose(); }
          if (e.key === 'Escape') { openClose(false); }
        });
        optionDivs.forEach(d => d.addEventListener('click', () => choose(d.dataset.value, d.textContent)));

        // Close when clicking outside
        const onDocClick = (e) => { if (!custom.contains(e.target)) openClose(false); };
        document.addEventListener('click', onDocClick);
        // Ensure listener removed on modal close
        const prevClose = close;
        close = function () { document.removeEventListener('click', onDocClick); prevClose(); };
      })();

      function close() {
        modal.classList.add('closing');
        overlay.style.animation = 'fadeOut 0.2s ease-out';
        setTimeout(() => { overlay.remove(); document.body.classList.remove('modal-open'); }, 200);
      }
      modal.querySelector('#reportCancel').addEventListener('click', close);
      overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });

      // Submit handler
      const submitBtn = modal.querySelector('#reportSubmit');
      submitBtn.addEventListener('click', () => {
        const t = modal.querySelector('#reportType').value;
        const fromEmail = modal.querySelector('#reportEmail').value.trim();
        const subject = modal.querySelector('#reportSubject').value.trim() || `[${t}] User report`;
        const desc = modal.querySelector('#reportDesc').value.trim();
        const includeDiag = modal.querySelector('#reportDiag').checked;

        const lines = [];
        lines.push(`Category: ${t}`);
        if (fromEmail) lines.push(`Reporter: ${fromEmail}`);
        if (desc) { lines.push(''); lines.push(desc); }
        if (includeDiag) {
          try {
            const getUser = window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function' ? window.FirebaseAuth.getUser : null;
            const user = getUser ? getUser() : null;
            const uid = user && user.uid;
            const profileKey = uid ? localStorage.getItem(`fb_selected_profile_${uid}`) : null;
            lines.push('');
            lines.push('--- Diagnostics ---');
            lines.push(`URL: ${location.href}`);
            lines.push(`Time: ${new Date().toISOString()}`);
            lines.push(`User-Agent: ${navigator.userAgent}`);
            lines.push(`UID: ${uid || 'guest'}`);
            lines.push(`Profile: ${profileKey || 'n/a'}`);
          } catch (_) { }
        }
        const message = lines.join('\n');


        // Set to true if you want to allow fallback to mailto: links, false to only copy to clipboard
        const ALLOW_MAILTO_FALLBACK = false;
        const copyFallback = () => {
          try {
            navigator.clipboard && navigator.clipboard.writeText(message);
            if (window.UIToast && UIToast.info) UIToast.info('Copied report to clipboard', 'Direct send unavailable. Paste into any email/chat.');
          } catch (_) {
            if (window.UIToast && UIToast.warning) UIToast.warning('Direct send unavailable', 'Could not copy automatically.');
          }
        };

        const doMailto = () => {
          if (!ALLOW_MAILTO_FALLBACK) { copyFallback(); return close(); }
          const mailto = `mailto:${encodeURIComponent(SUPPORT_EMAIL)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(message)}`;
          window.location.href = mailto;
          close();
          if (window.UIToast && UIToast.success) UIToast.success('Report prepared', 'Your email client will open a pre-filled report.');
        };

        // Button loading state
        submitBtn.disabled = true;
        const prevText = submitBtn.textContent;
        submitBtn.textContent = 'Sendingâ€¦';

        const finish = (ok) => {
          submitBtn.disabled = false;
          submitBtn.textContent = prevText;
          if (ok) close();
        };

        // Validate config
        const hasEmailJsConfig = EMAILJS.enabled && EMAILJS.serviceId && EMAILJS.templateId && EMAILJS.publicKey;
        if (!hasEmailJsConfig) {
          if (window.UIToast && UIToast.warning) UIToast.warning('Direct send not configured', 'Add your EmailJS keys in testing.html to send without opening email.');
          finish(false);
          return doMailto();
        }

        try {
          const params = {
            to_email: SUPPORT_EMAIL,
            subject,
            message,
            from_email: fromEmail || 'moive776@gmail.com',
            reply_to: fromEmail || SUPPORT_EMAIL,
            category: t,
            site_url: location.href
          };
          window.emailjs.send(EMAILJS.serviceId, EMAILJS.templateId, params).then(() => {
            if (window.UIToast && UIToast.success) UIToast.success('Report sent', 'Thanks for your feedback!');
              finish(true);
            }).catch((err) => {
              if (window.UIToast && UIToast.error) UIToast.error('Direct send failed', (err && err.text) ? String(err.text) : 'Check EmailJS serviceId/templateId and template fields.');
              finish(false);
              doMailto();
            });
          } catch (err) {
            if (window.UIToast && UIToast.error) UIToast.error('Direct send failed', 'Unexpected error while sending.');
            finish(false);
            doMailto();
          }
        });
    }

    // Removed: showClearConfirmation and related Clear All UI

    // Create continue watching row (disabled: using unified loadContinueWatching path)
    function createContinueWatchingRow() {
      // Disabled to prevent duplicate sections; loadContinueWatching manages the single section (by id)
      // Keeping the function to avoid breaking callers; it now returns null so callers simply no-op.
      return null;
      try {
        const continueWatching = JSON.parse(localStorage.getItem('continueWatching') || '{}');
        console.log('Continue watching data:', continueWatching);

        const continueWatchingMovies = Object.entries(continueWatching)
          .map(([id, movie]) => {
            // Ensure all required fields have proper fallbacks
            const movieData = {
              ...movie,
              id: movie.movieId || id,
              movieId: movie.movieId || id,
              title: movie.title || 'Untitled Movie',
              poster: movie.poster || movie.thumbnail || movie.posterUrl || '',
              posterUrl: movie.posterUrl || movie.poster || movie.thumbnail || '',
              thumbnail: movie.thumbnail || movie.poster || movie.posterUrl || '',
              progress: parseFloat(movie.progress) || 0,
              currentTime: parseFloat(movie.currentTime) || 0,
              duration: parseFloat(movie.duration) || 0,
              timestamp: parseInt(movie.timestamp) || Date.now()
            };

            // Calculate progress if not set but we have currentTime and duration
            if ((!movieData.progress || movieData.progress === 0) && movieData.duration > 0) {
              movieData.progress = Math.min(95, (movieData.currentTime / movieData.duration) * 100);
            }

            return movieData;
          })
          .filter(movie => {
            // More lenient validation with better debugging
            const hasValidProgress = movie.progress > 0 && movie.progress <= 100;
            const hasValidTitle = movie.title &&
              movie.title !== 'Untitled Movie' &&
              movie.title !== 'Untitled' &&
              movie.title.trim() !== '';
            const hasValidId = movie.id || movie.movieId;

            // Debug logging
            if (!hasValidProgress) {
              console.log('Skipping movie - Invalid progress:', {
                title: movie.title || 'No title',
                progress: movie.progress,
                id: movie.id || movie.movieId || 'No ID',
                currentTime: movie.currentTime,
                duration: movie.duration
              });
            }
            if (!hasValidTitle) {
              console.log('Skipping movie - Invalid title:', {
                title: movie.title || 'No title',
                id: movie.id || movie.movieId || 'No ID'
              });
            }
            if (!hasValidId) {
              console.log('Skipping movie - Missing ID:', movie.title || 'No title');
            }

            return hasValidProgress && hasValidTitle && hasValidId;
          })
          .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // Sort by most recent

        if (continueWatchingMovies.length === 0) return null;

        const section = document.createElement('div');
        section.className = 'continue-watching-section';
        section.innerHTML = `
          <div class="section-header">
            <h2 class="section-title">
              <i class="fas fa-redo"></i> Continue Watching
            </h2>
            <!-- Clear All button removed -->
          </div>
          <div class="continue-watching-container"></div>
        `;

        const container = section.querySelector('.continue-watching-container');

        // Clear button handler attached later after items render (single attachment)

        continueWatchingMovies.forEach(movie => {
          const title = movie.title || 'Untitled';
          const posterPath = movie.poster || movie.thumbnail || movie.posterUrl || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MDAgNzUwIj4KICA8cmVjdCB3aWR0aD0iNTAwIiBoZWlnaHQ9Ijc1MCIgZmlsbD0iIzFhMWExYSIvPgogIDx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM4MDgwODAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPk5vIFBvc3RlcjwvdGV4dD4KPC9zdmc+';
          const progress = Math.round(movie.progress || 0);

          const card = document.createElement('div');
          card.className = 'continue-watching-card';
          card.innerHTML = `
            <div class="continue-watching-poster">
              <img src="${posterPath}" alt="${title}" />
              <div class="progress-bar">
                <div class="progress" style="width: ${progress}%"></div>
              </div>
              <div class="resume-overlay">
                <div class="resume-button">Resume</div>
              </div>
              <div class="remove-button" title="Remove from Continue Watching">Ã—</div>
            </div>
            <div class="continue-watching-info">
              <h3>${title}</h3>
              <p>${progress}% watched</p>
            </div>
          `;

          // Click to resume - Navigate to the correct player
          card.addEventListener('click', (e) => {
            if (!e.target.closest('.remove-button')) {
              const duration = movie.duration || 0;
              const resumeTime = (duration * progress) / 100;

              // Build the player URL with the movie's details
              const params = new URLSearchParams();
              params.append('id', movie.id);
              params.append('title', movie.title);
              if (movie.posterUrl) params.append('poster', movie.posterUrl);

              // Use the player that was used when watching this movie
              // Default to player1 if playerUsed field is missing
              const playerUsed = movie.playerUsed || 'player1';
              const playerBase = playerUsed === 'player2' ? 'player-2.html' : 'player.html';
              console.log('ðŸŽ¬ Resuming', movie.title);
              console.log('ðŸ“Š Movie object:', JSON.stringify(movie, null, 2));
              console.log('ðŸ“¹ Player to use:', playerBase, '(playerUsed field:', playerUsed, ')');
              // Navigate to the correct player with the resume time
              window.location.href = `${playerBase}?${params.toString()}&t=${Math.floor(resumeTime)}`;
            }
          });

          // Enhanced remove from continue watching with animation
          const removeBtn = card.querySelector('.remove-button');
          removeBtn.addEventListener('click', async (e) => {
            e.stopPropagation();

            // Add visual feedback
            card.style.transform = 'scale(0.98)';
            card.style.opacity = '0.7';

            // Add a small delay for better UX
            await new Promise(resolve => setTimeout(resolve, 100));

            // Remove from localStorage
            const continueWatching = JSON.parse(localStorage.getItem('continueWatching') || '{}');
            if (continueWatching[movie.id]) {
              delete continueWatching[movie.id];
              localStorage.setItem('continueWatching', JSON.stringify(continueWatching));

              // Animate removal
              card.style.transform = 'translateX(100%)';
              card.style.opacity = '0';
              await new Promise(resolve => setTimeout(resolve, 200));

              card.remove();

              // Remove section if no more continue watching items
              const remainingItems = Object.keys(continueWatching).length;
              if (remainingItems === 0) {
                section.style.opacity = '0';
                section.style.height = '0';
                section.style.margin = '0';
                section.style.padding = '0';
                await new Promise(resolve => setTimeout(resolve, 300));
                section.remove();
              }
            }
          });

          container.appendChild(card);
        });

        return section;
      } catch (error) {
        console.error('Error creating continue watching row:', error);
        return null;
      }
    }

    // Load continue watching from localStorage (scoped per user/profile)
    function getContinueWatchingKey() {
      try {
        const user = (window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function')
          ? window.FirebaseAuth.getUser()
          : null;
        const uid = user && user.uid;
        if (!uid) return 'continueWatching_guest';
        const sel = localStorage.getItem(`fb_selected_profile_${uid}`);
        return sel ? `continueWatching_${uid}_${sel}` : `continueWatching_${uid}`;
      } catch (e) {
        return 'continueWatching_guest';
      }
    }

    // Get bookmark storage key (scoped per user/profile)
    function getBookmarksKey() {
      try {
        const user = (window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function')
          ? window.FirebaseAuth.getUser()
          : null;
        const uid = user && user.uid;
        if (!uid) return 'myList_guest';
        const sel = localStorage.getItem(`fb_selected_profile_${uid}`);
        return sel ? `myList_${uid}_${sel}` : `myList_${uid}`;
      } catch (e) {
        console.error('Error getting bookmarks key:', e);
        return 'myList_guest';
      }
    }

    // Add movie to bookmarks
    function addBookmark(movie) {
      try {
        const key = getBookmarksKey();
        console.log('Adding bookmark with key:', key, 'Movie:', movie.id, movie.title);
        const bookmarksStr = localStorage.getItem(key);
        const bookmarks = bookmarksStr ? JSON.parse(bookmarksStr) : {};

        bookmarks[movie.id] = {
          id: movie.id,
          title: movie.title,
          poster: movie.posterUrl || movie.poster || movie.thumbnail || '',
          rating: movie.rating,
          year: movie.year,
          genres: movie.genres,
          timestamp: Date.now()
        };

        localStorage.setItem(key, JSON.stringify(bookmarks));
        console.log('Bookmark added successfully. Total bookmarks:', Object.keys(bookmarks).length);
        console.log('Current bookmarks:', bookmarks);
        return true;
      } catch (e) {
        console.error('Error adding bookmark:', e);
        return false;
      }
    }

    // Remove movie from bookmarks
    function removeBookmark(movieId) {
      try {
        const key = getBookmarksKey();
        console.log('Removing bookmark with key:', key, 'Movie ID:', movieId);
        const bookmarksStr = localStorage.getItem(key);
        const bookmarks = bookmarksStr ? JSON.parse(bookmarksStr) : {};

        delete bookmarks[movieId];
        localStorage.setItem(key, JSON.stringify(bookmarks));
        console.log('Bookmark removed successfully. Remaining bookmarks:', Object.keys(bookmarks).length);
        return true;
      } catch (e) {
        console.error('Error removing bookmark:', e);
        return false;
      }
    }

    // Check if movie is bookmarked
    function isBookmarked(movieId) {
      try {
        const key = getBookmarksKey();
        const bookmarksStr = localStorage.getItem(key);
        const bookmarks = bookmarksStr ? JSON.parse(bookmarksStr) : {};
        const result = !!bookmarks[movieId];
        console.log('Checking bookmark for movie:', movieId, 'Key:', key, 'Result:', result, 'All bookmarks:', bookmarks);
        return result;
      } catch (e) {
        console.error('Error checking bookmark:', e);
        return false;
      }
    }

    // Load continue watching from Firebase AND localStorage (merged)
    async function loadContinueWatching(forceShow = false) {
      // Wait for auth/profile to be ready to avoid flicker with wrong storage key
      try {
        if (!window.FirebaseAuth || typeof window.FirebaseAuth.getUser !== 'function' || !window.FirebaseAuth.getUser()) {
          // Try again shortly
          setTimeout(() => loadContinueWatching(forceShow), 250);
          return;
        }
      } catch (_) { }
      // Don't show continue watching if we're in search mode and not forcing a show
      if (isSearching && !forceShow) {
        const section = document.getElementById('continueWatchingSection');
        if (section) section.style.display = 'none';
        return;
      }

      console.log('=== DEBUG: loadContinueWatching() called ===');
      try {
        // 1. Get Cloud Data
        let cloudData = {};
        
        // ALWAYS use async method to ensure we get latest data from Firebase
        if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.getAllProgressAsync === 'function') {
          console.log('Loading continue watching from ContinueWatchingManager (async)...');
          cloudData = await window.ContinueWatchingManager.getAllProgressAsync();
        } else if (window.FirebaseSync && window.FirebaseSync.initialized) {
          console.log('Loading continue watching from FirebaseSync...');
          cloudData = await window.FirebaseSync.getContinueWatching();
        } else {
          console.warn('No Firebase source available, trying ContinueWatchingManager sync...');
          if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.getAllProgress === 'function') {
            cloudData = window.ContinueWatchingManager.getAllProgress();
          }
        }

        // 2. Get Local Data (from Player 2 or offline)
        let localData = {};
        try {
            const user = window.FirebaseAuth.getUser();
            const uid = user ? user.uid : null;
            const profileId = uid ? localStorage.getItem(`fb_selected_profile_${uid}`) : null;
            
            // Check all possible keys
            const keys = ['continueWatching'];
            if (uid) keys.push(`continueWatching_${uid}`);
            if (uid && profileId) keys.push(`continueWatching_${uid}_${profileId}`);
            
            keys.forEach(key => {
                try {
                    const data = JSON.parse(localStorage.getItem(key) || '{}');
                    Object.assign(localData, data);
                } catch(e) {}
            });
            console.log('Loaded local continue watching data:', Object.keys(localData).length, 'items');
        } catch (e) { console.warn('Error reading local continue watching:', e); }

        // 3. Merge Data (Cloud wins on conflict, unless Local is newer)
        let continueWatching = { ...cloudData };
        
        Object.entries(localData).forEach(([id, localMovie]) => {
            const cloudMovie = continueWatching[id];
            if (!cloudMovie) {
                continueWatching[id] = localMovie;
            } else {
                // Compare timestamps
                const localTime = Number(localMovie.updatedAt || localMovie.timestamp || 0);
                const cloudTime = Number(cloudMovie.updatedAt || cloudMovie.timestamp || 0);
                if (localTime > cloudTime) {
                    continueWatching[id] = localMovie;
                    console.log('Using newer local data for:', localMovie.title);
                }
            }
        });

        console.log('Merged continue watching data:', Object.keys(continueWatching).length, 'items');
        
        // Log each item for debugging
        Object.entries(continueWatching).forEach(([id, movie]) => {
          console.log('  -', movie.title || 'Untitled', '|', movie.progress || 0, '% | ID:', id);
        });

        // Get movies that have progress
        const continueWatchingMovies = Object.entries(continueWatching).map(([id, movie]) => {
          const mapped = {
            ...movie,
            id: movie.movieId || movie.id || id, // Use movieId first, then id, then key
            movieId: movie.movieId || movie.id || id,
            title: movie.title || 'Untitled',
            progress: parseFloat(movie.progress) || 0,
            currentTime: parseFloat(movie.currentTime) || 0,
            duration: parseFloat(movie.duration) || 0,
            timestamp: parseInt(movie.updatedAt || movie.timestamp) || 0,
            updatedAt: parseInt(movie.updatedAt || movie.timestamp) || 0,
            poster: movie.poster || movie.posterUrl || movie.thumbnail || '',
            posterUrl: movie.posterUrl || movie.poster || movie.thumbnail || ''
          };
          console.log('Mapped movie:', mapped.title, 'Progress:', mapped.progress, 'ID:', mapped.id);
          return mapped;
        });

        // Deduplicate by strong key (movieId/id) first, then fallback to normalized title
        const dedupMap = new Map();
        for (const m of continueWatchingMovies) {
          const keyId = String(m.movieId || m.id || '').trim();
          const keyTitle = String(m.title || '').toLowerCase().trim();
          const key = keyId || `title:${keyTitle}`;

          const existing = dedupMap.get(key);
          if (!existing) {
            dedupMap.set(key, m);
            continue;
          }

          const tsNew = Number(m.updatedAt || m.timestamp || 0);
          const tsOld = Number(existing.updatedAt || existing.timestamp || 0);
          const progNew = Number(m.progress || 0);
          const progOld = Number(existing.progress || 0);

          // Pick newer; if tie, pick higher progress
          if (tsNew > tsOld || (tsNew === tsOld && progNew > progOld)) {
            dedupMap.set(key, m);
          }
        }

        const dedupedMovies = Array.from(dedupMap.values());

        let validMovies = dedupedMovies.filter(movie => {
          const hasProgress = movie.progress > 0 && movie.progress < 95;
          const hasValidId = movie.id || movie.movieId;
          const hasTitle = movie.title && movie.title !== 'Untitled' && movie.title !== 'Unknown Movie';
          const isValid = hasProgress && hasValidId && hasTitle;
          
          if (!isValid) {
            console.log('Filtered out movie:', movie.title, {
              hasProgress,
              hasValidId,
              hasTitle,
              progress: movie.progress,
              id: movie.id,
              movieId: movie.movieId,
              title: movie.title
            });
          }
          
          return isValid;
        });
        
        console.log('Valid movies after filter:', validMovies.length, validMovies.map(m => m.title));

        // Final dedupe pass by movieId/title to avoid edge duplicates after validation
        if (validMovies.length > 1) {
          const byKey = new Map();
          for (const m of validMovies) {
            const keyId = String(m.movieId || m.id || '').trim();
            const keyTitle = String(m.title || '').toLowerCase().trim();
            const key = keyId || `title:${keyTitle}`;
            const existing = byKey.get(key);
            const ts = Number(m.updatedAt || m.timestamp || 0);
            const existingTs = Number(existing?.updatedAt || existing?.timestamp || 0);
            if (!existing || ts > existingTs || (ts === existingTs && (m.progress || 0) > (existing?.progress || 0))) {
              byKey.set(key, m);
            }
          }
          validMovies = Array.from(byKey.values());
        }

        if (validMovies.length === 0) {
          console.log('No valid continue watching items to display');
          const section = document.getElementById('continueWatchingSection');
          if (section) section.style.display = 'none';
          return;
        }

        // Sort by most recently watched (fall back to updatedAt)
        validMovies.sort((a, b) => (Number(b.updatedAt || b.timestamp || 0)) - (Number(a.updatedAt || a.timestamp || 0)));

        // Don't create the section if we're in search mode
        if (isSearching && !forceShow) {
          return;
        }

        // Get or create the continue watching section
        let section = document.getElementById('continueWatchingSection');
        if (!section) {
          section = document.createElement('section');
          section.id = 'continueWatchingSection';
          section.className = 'continue-watching-section';
          section.innerHTML = `
            <div class="section-header">
              <h2 class="section-title">
                <i class="fas fa-redo"></i> Continue Watching
              </h2>
              <!-- Clear All button removed -->
            </div>
            <div class="continue-watching-container" id="continueWatchingContainer"></div>
          `;

          // Insert at the beginning of the movies container
          const moviesContainer = document.getElementById('moviesContainer');
          if (moviesContainer) {
            moviesContainer.insertBefore(section, moviesContainer.firstChild);
          }
        }

        // Clear existing content
        const container = section.querySelector('#continueWatchingContainer');
        if (container) {
          container.innerHTML = '';

          // Add each movie to the container
          validMovies.forEach(movie => {
            const title = movie.title || 'Untitled';
            const posterPath = movie.poster || movie.thumbnail || movie.posterUrl || 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MDAgNzUwIj4KICA8cmVjdCB3aWR0aD0iNTAwIiBoZWlnaHQ9Ijc1MCIgZmlsbD0iIzFhMWExYSIvPgogIDx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM4MDgwODAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGRvbWluYW50LWJhc2VsaW5lPSJtaWRkbGUiPk5vIFBvc3RlcjwvdGV4dD4KPC9zdmc+';
            const progress = Math.round(movie.progress || 0);

            const card = document.createElement('div');
            card.className = 'continue-watching-card';
            card.innerHTML = `
              <div class="continue-watching-poster">
                <img src="${posterPath}" alt="${title}" />
                <div class="progress-bar">
                  <div class="progress" style="width: ${progress}%"></div>
                </div>
                <div class="resume-overlay">
                  <div class="resume-button">Resume</div>
                </div>
                <div class="remove-button" title="Remove from Continue Watching">Ã—</div>
              </div>
              <div class="continue-watching-info">
                <h3>${title}</h3>
                <p>${progress}% watched</p>
              </div>
            `;

            // Click to resume
            card.addEventListener('click', (e) => {
              if (!e.target.closest('.remove-button')) {
                const durationSeconds = Number(movie.duration) || 0;
                const progressSeconds = durationSeconds && movie.progress ? (durationSeconds * movie.progress) / 100 : 0;

                // Freshly fetch progress from manager for most accurate resume time
                let managerSeconds = 0;
                try {
                  const mgr = window.ContinueWatchingManager;
                  const mgrProgress = mgr && typeof mgr.getMovieProgress === 'function' ? mgr.getMovieProgress(movie.id || movie.movieId) : null;
                  managerSeconds = mgrProgress && Number(mgrProgress.currentTime) ? Number(mgrProgress.currentTime) : 0;
                } catch (_) { }

                const resumeSeconds = Math.floor(
                  managerSeconds || movie.currentTime || progressSeconds || 0
                );

                const idParam = movie.id ? `&id=${encodeURIComponent(movie.id)}` : '';
                const movieIdParam = movie.id ? `&movieId=${encodeURIComponent(movie.id)}` : '';
                const base = `player.html?title=${encodeURIComponent(movie.title)}&poster=${encodeURIComponent(movie.posterUrl || movie.poster || '')}&trailer=${encodeURIComponent(movie.trailerUrl || '')}${idParam}${movieIdParam}`;

                // Only add t if we have a positive timestamp; otherwise let player prompt using cloud progress
                const url = resumeSeconds > 0 ? `${base}&t=${resumeSeconds}` : base;
                window.location.href = url;
              }
            });

            // Remove button
            const removeButton = card.querySelector('.remove-button');
            if (removeButton) {
              removeButton.addEventListener('click', async (e) => {
                e.stopPropagation();

                const movieId = movie.id || movie.movieId;
                if (movieId) {
                  // 1. Remove from Cloud
                  if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.removeMovieProgress === 'function') {
                    await window.ContinueWatchingManager.removeMovieProgress(movieId);
                  } else if (window.FirebaseSync && window.FirebaseSync.initialized) {
                    await window.FirebaseSync.removeContinueWatchingItem(movieId);
                  }

                  // 2. Remove from Local Storage
                  try {
                      const user = window.FirebaseAuth.getUser();
                      const uid = user ? user.uid : null;
                      const profileId = uid ? localStorage.getItem(`fb_selected_profile_${uid}`) : null;
                      
                      const keys = ['continueWatching'];
                      if (uid) keys.push(`continueWatching_${uid}`);
                      if (uid && profileId) keys.push(`continueWatching_${uid}_${profileId}`);
                      
                      keys.forEach(key => {
                          try {
                              const data = JSON.parse(localStorage.getItem(key) || '{}');
                              if (data[movieId]) {
                                  delete data[movieId];
                                  localStorage.setItem(key, JSON.stringify(data));
                              }
                          } catch(e) {}
                      });
                  } catch(e) {}

                  // Remove the card with animation
                  card.style.opacity = '0';
                  card.style.transition = 'opacity 0.2s ease';
                  setTimeout(() => {
                    card.remove();
                    
                    // Update trash icon after removal
                    updateTrashIcon();
                    
                    // If no more items, hide the section
                    if (container.children.length === 0) {
                      section.style.display = 'none';
                    }
                  }, 200);
                }
              });
            }

            container.appendChild(card);
          });

          // Update trash icon based on items
          const updateTrashIcon = () => {
            const clearButton = section.querySelector('#clearAllBtn');
            if (!clearButton) return;

            const items = container.querySelectorAll('.continue-watching-card');
            const icon = clearButton.querySelector('i');

            if (items.length > 0) {
              // Filled trash can when there are items
              icon.className = 'fas fa-trash-alt';
              clearButton.style.opacity = '1';
              clearButton.style.pointerEvents = 'auto';
              clearButton.style.cursor = 'pointer';
              clearButton.classList.add('has-items');
              clearButton.classList.remove('is-empty');
            } else {
              // Empty trash can when no items
              icon.className = 'far fa-trash-alt';
              clearButton.style.opacity = '0.6';
              clearButton.style.pointerEvents = 'none';
              clearButton.style.cursor = 'default';
              clearButton.classList.add('is-empty');
              clearButton.classList.remove('has-items');
            }
          };

          // Initial icon update
          updateTrashIcon();

          // Clear All button removed

          // Show the section only if not in search mode
          section.style.display = isSearching ? 'none' : 'block';
          
          // Listen for continue watching updates from other sources (Firebase sync, etc.)
          const handleContinueWatchingUpdate = () => {
            loadContinueWatching(false);
          };
          window.addEventListener('continueWatchingUpdated', handleContinueWatchingUpdate);
        }

      } catch (error) {
        console.error('Error in loadContinueWatching:', error);
        const section = document.getElementById('continueWatchingSection');
        if (section) section.style.display = 'none';
      }
    }

    // runtime mappings

    // Movies Google Drive Mappings
    const localTrailers = {};
    const driveMovieMappings = {
      "1": "",  // Manjummel Boys (2024)
      "2": "",  // Tourist Family (2025)
      "3": "",  // Kaithi (2019)
      "4": "",  // Vikram (2022)
      "5": "",  // Leo (2023)
      "6": "",  // Coolie (2025)
      "7": "",  // Maharaja (2024)
      "8": "",  // Hi Papa (2023)
      "9": "",  // Kantara (2022)
      "10": "",  // Hridayam (2022)
      "11": "",  // Lokah Chapter 1 (2025)
      "12": "",  // Lucky Bhaskar (2024)
      "13": "",  // Court - State Vs. A Nobody (2025)
      "14": "",  // Master (2021)
      "15": "",  // HIT: The First Case (2020)
      "16": "",  // HIT: The Second Case (2022)
      "17": "",  // HIT: The Third Case (2025)
      "18": "",  // Retro (2025)
      "19": "",  // Kuberaa (2025)
      "20": "",  // Thalaivan Thalaivii (2025)
    };

    // Direct MP4 overrides by normalized title (DISABLED - use WebStreamr API instead)
    const mp4Overrides = {};

    // Normalize titles and resolve MP4 override by title robustly
    function normalizeTitleForKey(t) {
      return String(t || '')
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ');
    }

    function getMp4Override(title) {
      const base = normalizeTitleForKey(title);
      if (mp4Overrides[base]) return mp4Overrides[base];
      // try without common suffixes
      const simplified = base
        .replace(/\bchapter\s*\d+\b/g, '')
        .replace(/\bpart\s*\d+\b/g, '')
        .replace(/\bthe\s+/g, '')
        .replace(/\s+/g, ' ')
        .trim();
      return mp4Overrides[simplified] || null;
    }

    // Flag to toggle TMDB-driven catalog rendering
    let useTMDBCatalog = false;

    // Store scroll position before opening modal
    let savedScrollPosition = 0;

    // Elements
    const moviesContainer = document.getElementById('moviesContainer');
    const modal = document.getElementById('movieModal');
    const closeModalBtn = document.getElementById('closeModal');
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const streamBtn = document.getElementById('streamBtn');




    function extractYouTubeId(url) {
      if (!url) return null;
      // Handle standard YouTube URLs
      let m = String(url).match(/(?:v=|be\/)([0-9A-Za-z_-]{6,})/);
      if (m) return m[1];
      // Handle embedded URLs
      m = String(url).match(/embed\/([0-9A-Za-z_-]{6,})/);
      return m ? m[1] : null;
    }

    // Apply per-movie trailerUrl into localTrailers map for playback
    function applyPerMovieUrls() {
      curatedMovies.forEach(m => {
        if (m.trailerUrl) {
          const key = extractYouTubeId(m.trailerUrl);
          if (key) localTrailers[m.id] = key;
        }
      });

      // Update continue watching section when new data is loaded
      const continueWatchingSection = createContinueWatchingRow();
      if (continueWatchingSection) {
        const existingSection = document.querySelector('.continue-watching-section');
        if (existingSection) {
          existingSection.replaceWith(continueWatchingSection);
        } else if (moviesContainer.firstChild) {
          moviesContainer.insertBefore(continueWatchingSection, moviesContainer.firstChild);
        } else {
          moviesContainer.appendChild(continueWatchingSection);
        }
      }
    }

    // Update trailer host markup based on available poster/trailer sources
    function setTrailerHostContent(movie, trailerHost, placeholderImg) {
      if (!movie || !trailerHost || !placeholderImg) return;

      const posterSafe = movie.posterUrl && !movie.posterUrl.includes('archive.org') ? movie.posterUrl : null;
      const key = movie.trailerUrl ? extractYouTubeId(movie.trailerUrl) : localTrailers[movie.id];
      const placeholder = posterSafe || (key ? `https://i.ytimg.com/vi/${key}/hqdefault.jpg` : ('data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%221280%22 height=%22720%22%3E%3Crect fill=%22%23333%22 width=%221280%22 height=%22720%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 font-size=%2250%22 fill=%22%23999%22 text-anchor=%22middle%22 dominant-baseline=%22middle%22%3EPlay Trailer%3C/text%3E%3C/svg%3E'));

      placeholderImg.src = placeholder;

      const isMP4 = movie.trailerUrl && (movie.trailerUrl.endsWith('.mp4') || movie.trailerUrl.includes('.mp4'));
      if (isMP4) {
        trailerHost.dataset.mp4Url = movie.trailerUrl;
        trailerHost.dataset.youtubeKey = '';
        trailerHost.innerHTML = `
          <img id="trailerPlaceholderImg" src="${placeholder}" alt="Trailer preview" style="max-width:100%;height:auto;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%221280%22 height=%22720%22%3E%3Crect fill=%22%23333%22 width=%221280%22 height=%22720%22/%3E%3C/svg%3E'" />
          <div class="video-play-btn" title="Play trailer"></div>
        `;
      } else {
        trailerHost.dataset.youtubeKey = key || '';
        trailerHost.dataset.mp4Url = '';
        trailerHost.innerHTML = `<img id="trailerPlaceholderImg" src="${placeholder}" alt="Trailer preview" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%221280%22 height=%22720%22%3E%3Crect fill=%22%23333%22 width=%221280%22 height=%22720%22/%3E%3C/svg%3E'" /><div class="video-play-btn" title="Play trailer"></div>`;
      }
    }

    // Lazy-fetch TMDB trailers for movies without trailerUrl
    async function ensureMovieTrailer(movie) {
      if (!movie || movie.trailerUrl) return movie.trailerUrl;
      if (!movieDb) return null;

      try {
        let videos = [];
        if (movie.mediaType === 'tv' && typeof movieDb.getTVVideos === 'function') {
          videos = await movieDb.getTVVideos(movie.id);
        } else if (typeof movieDb.getMovieVideos === 'function') {
          videos = await movieDb.getMovieVideos(movie.id);
        } else {
          videos = [];
        }
        const best = videos.find(v => v.site === 'YouTube' && v.type === 'Trailer' && v.official) ||
          videos.find(v => v.site === 'YouTube' && (v.type === 'Trailer' || v.type === 'Teaser')) ||
          videos.find(v => v.site === 'YouTube');

        if (best && best.key) {
          movie.trailerUrl = `https://www.youtube.com/watch?v=${best.key}`;
          localTrailers[movie.id] = best.key;
          return movie.trailerUrl;
        }
      } catch (error) {
        console.warn('Unable to fetch TMDB trailer', movie.id, error);
      }

      // Fallback to YouTube search if API key is provided
      if (YT_API_KEY) {
        try {
          const ytKey = await fetchYouTubeTrailer(movie.title, movie.year || movie.release_date);
          if (ytKey) {
            movie.trailerUrl = `https://www.youtube.com/watch?v=${ytKey}`;
            localTrailers[movie.id] = ytKey;
            return movie.trailerUrl;
          }
        } catch (error) {
          console.warn('YouTube trailer lookup failed', movie.title, error);
        }
      }

      return null;
    }

    // YouTube Data API fallback search
    async function fetchYouTubeTrailer(title, year) {
      if (!YT_API_KEY || !title) return null;
      const query = `${title} official trailer ${year || ''}`.trim();
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=5&q=${encodeURIComponent(query)}&key=${YT_API_KEY}`;
      const resp = await fetch(url);
      if (!resp.ok) {
        console.warn('YouTube API error', resp.status);
        return null;
      }
      const data = await resp.json();
      const items = data.items || [];
      const pick = items.find(i => (i.snippet?.title || '').toLowerCase().includes('trailer')) || items[0];
      return pick && pick.id && pick.id.videoId ? pick.id.videoId : null;
    }


    // Display Movies
    let currentCategory = 'all'; // category filter state

    // Category mapping by movie id
    const categoryMap = {
      bollywood: [22, 23, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], // Court - State Vs. A Nobody, HIT: The First Case (Hindi)
      tollywood: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 25, 26], // South Indian set (Tamil/Telugu/etc.)
    };

    /**
     * Filter TMDB movies by category based on original language
     * Bollywood: Hindi language (hi)
     * Tollywood: South Indian languages (Tamil, Telugu, Kannada, Malayalam)
     */
    function filterTMDBByCategory(movies, category) {
      if (!movies || !Array.isArray(movies)) return [];
      
      if (category === 'bollywood') {
        // Filter for Hindi language movies
        return movies.filter(movie => movie.original_language === 'hi');
      } else if (category === 'tollywood') {
        // Filter for South Indian languages: Tamil, Telugu, Kannada, Malayalam
        const southIndianLanguages = ['ta', 'te', 'kn', 'ml'];
        return movies.filter(movie => southIndianLanguages.includes(movie.original_language));
      }
      
      return movies;
    }

    function applyCategory(cat) {
      currentCategory = cat;

      // Hide/show popular movies section based on category
      const popularSection = document.getElementById('popularMoviesSection');
      const popularTVSection = document.getElementById('popularTVSection');
      if (popularSection) {
        popularSection.style.display = (cat === 'all') ? '' : 'none';
      }
      if (popularTVSection) {
        popularTVSection.style.display = (cat === 'all') ? '' : 'none';
      }

      // TMDB-driven catalog handling
      if (useTMDBCatalog) {
        // Show/hide continue watching section (only show for 'all' movies)
        const cwSection = document.getElementById('continueWatchingSection');
        if (cwSection) {
          cwSection.style.display = (cat === 'all') ? '' : 'none';
        }

        // Update category bar active state
        mountCategoryBar();

        // Series â†’ switch to TV mode
        if (cat === 'series' && typeof setTMDBMode === 'function' && typeof loadAllTMDBTV === 'function') {
          setTMDBMode('tv');
          loadAllTMDBTV().then(shows => {
            displayMovies(shows, false, 'Series');
            // Scroll to movies section
            setTimeout(() => {
              const title = document.querySelector('.section-title');
              if (title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
          });
          return;
        }

        // Movies: all/bollywood/tollywood
        if (typeof setTMDBMode === 'function') setTMDBMode('movie');
        const label = cat === 'all' ? 'All Movies' : (cat.charAt(0).toUpperCase() + cat.slice(1));
        if (cat === 'all' && typeof loadAllTMDBMovies === 'function') {
          loadAllTMDBMovies().then(movies => {
            displayMovies(movies, false, label);
            // Scroll to movies section
            setTimeout(() => {
              const title = document.querySelector('.section-title');
              if (title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
          });
        } else if (typeof loadTMDBByLanguage === 'function') {
          loadTMDBByLanguage(cat, 10).then(movies => {
            displayMovies(movies, false, label);
            // Scroll to movies section
            setTimeout(() => {
              const title = document.querySelector('.section-title');
              if (title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
          });
        } else if (typeof loadAllTMDBMovies === 'function') {
          loadAllTMDBMovies().then(movies => {
            const filtered = typeof filterTMDBByCategory === 'function' ? filterTMDBByCategory(movies, cat) : movies;
            displayMovies(filtered, false, label);
            // Scroll to movies section
            setTimeout(() => {
              const title = document.querySelector('.section-title');
              if (title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
          });
        }
        return;
      }

      // Local curated catalog fallback
      if (cat === 'all') {
        displayMovies(curatedMovies, false, 'All Movies');
      } else {
        // Use language-based filtering for bollywood/tollywood
        const filtered = filterTMDBByCategory(curatedMovies, cat);
        const label = cat.charAt(0).toUpperCase() + cat.slice(1);
        displayMovies(filtered, false, label);
      }
      const cwSection = document.getElementById('continueWatchingSection');
      if (cwSection) {
        cwSection.style.display = (cat === 'all') ? '' : 'none';
      }
      mountCategoryBar();
      // Scroll to movies section
      setTimeout(() => {
        const title = document.querySelector('.section-title');
        if (title) title.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 100);
    }

    function buildCategoryBar(activeCat) {
      const bar = document.createElement('div');
      bar.className = 'category-bar';
      bar.innerHTML = `
        <button class="cat-btn" data-cat="all">All</button>
        <button class="cat-btn" data-cat="bollywood">Bollywood</button>
        <button class="cat-btn" data-cat="tollywood">Tollywood</button>
        <button class="cat-btn" data-cat="series">Series</button>
      `;
      const setActive = (cat) => {
        bar.querySelectorAll('.cat-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.cat === cat);
        });
      };
      setActive(activeCat || 'all');
      // Event listener is attached in mountCategoryBar using event delegation
      // to avoid duplicate listeners when the bar is rebuilt
      return bar;
    }

    // Mount the category bar into the persistent mount point
    let categoryBarListenerAttached = false;
    function mountCategoryBar() {
      const mount = document.getElementById('categoryBarMount');
      if (!mount) return;
      mount.innerHTML = '';
      mount.appendChild(buildCategoryBar(currentCategory));
      
      // Attach event listener only once using event delegation
      if (!categoryBarListenerAttached) {
        mount.addEventListener('click', (e) => {
          const btn = e.target.closest('.cat-btn');
          if (!btn) return;
          applyCategory(btn.dataset.cat);
        });
        categoryBarListenerAttached = true;
      }
    }

    function displayMovies(movies, isSearchResults = false, titleOverride = null) {
      // Clear the movies container completely
      moviesContainer.innerHTML = '';

      // The persistent mount renders the category bar; avoid duplicating it here
      // Keep legacy fallback only if mount is missing and using curated catalog
      if (!useTMDBCatalog && !document.getElementById('categoryBarMount')) {
        const catBar = buildCategoryBar(currentCategory);
        moviesContainer.appendChild(catBar);
      }

      // Add section title for all movies
      const sectionTitle = document.createElement('h2');
      sectionTitle.className = 'section-title';
      sectionTitle.style.marginTop = '0.5rem';
      sectionTitle.textContent = titleOverride || (movies === curatedMovies ? 'All Movies' : 'Search Results');
      moviesContainer.appendChild(sectionTitle);

      // Add all movies
      const moviesGrid = document.createElement('div');
      moviesGrid.className = 'movies-grid';

      movies.forEach(movie => {
        const title = movie.title || 'Untitled';
        const posterPath = movie.posterUrl || ('https://via.placeholder.com/500x750?text=' + encodeURIComponent(title));

        const movieCard = document.createElement('div');
        movieCard.className = 'movie-card movie-' + movie.id;
        movieCard.innerHTML = `
          <div class="poster">
            <img src="${posterPath}" alt="${title}" loading="lazy" />
            <div class="rating-badge"><span class="star">â˜…</span><span class="value">${movie.rating ? movie.rating.toFixed(1) : 'N/A'}</span></div>
            <div class="play-icon"></div>
            <div class="movie-title-overlay">${title}</div>
          </div>
          <div class="movie-info">
            <h3 class="movie-title">${title} (${movie.year || ''})</h3>
          </div>
        `;

        // Add error handler for broken images
        const img = movieCard.querySelector('img');
        if (img) {
          img.addEventListener('error', () => {
            // Replace with placeholder if image fails to load
            img.src = `https://via.placeholder.com/500x750?text=${encodeURIComponent(title)}`;
          });
        }

        movieCard.addEventListener('click', () => openMovieModal(movie));
        moviesGrid.appendChild(movieCard);
      });

      moviesContainer.appendChild(moviesGrid);
    }




    /**
     * Apply theme to the page
     * @param {string} theme - Theme name (must match a key in themePresets)
     */
    // Return a profile-scoped theme key using selected profile local state
    function getScopedThemeKey() {
      try {
        const getUser = window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function' ? window.FirebaseAuth.getUser : null;
        const user = getUser ? getUser() : null;
        const uid = user && user.uid;
        if (!uid) return 'app_theme_guest';
        const sel = localStorage.getItem(`fb_selected_profile_${uid}`);
        return sel ? `app_theme_${uid}_${sel}` : `app_theme_${uid}`;
      } catch (e) {
        return 'app_theme_guest';
      }
    }

    function applyTheme(theme) {
      const presets = themePresets[theme] || themePresets.glossy;
      const root = document.documentElement.style;

      // Update CSS variables
      root.setProperty('--theme-bg1', presets.bgs[0]);
      root.setProperty('--theme-bg2', presets.bgs[1]);
      root.setProperty('--theme-bg3', presets.bgs[2]);
      root.setProperty('--accent', presets.accent);
      root.setProperty('--particle-color-1', presets.particles[0]);
      root.setProperty('--particle-color-2', presets.particles[1]);

      // Save to localStorage (scoped per profile when available)
      const key = getScopedThemeKey();
      if (localStorage.getItem(key) !== theme) {
        localStorage.setItem(key, theme);
      }

      // Recreate particles with new colors
      // Guard: if particles script hasn't loaded yet, skip silently
      if (typeof createParticles === 'function') {
        createParticles();
      }
    }

    /**
     * Set up event listeners for theme changes
     */
    function setupThemeListener() {
      // Listen for theme changes from other tabs/windows
      window.addEventListener('storage', (e) => {
        const key = getScopedThemeKey();
        if (e.key === key) {
          applyTheme(e.newValue);
        }
      });

      // Listen for theme changes via BroadcastChannel (for same-origin tabs)
      if (typeof BroadcastChannel !== 'undefined') {
        const channel = new BroadcastChannel('theme_channel');
        channel.onmessage = (e) => {
          if (e.data && e.data.type === 'THEME_CHANGED') {
            try {
              const getUser = window.FirebaseAuth && typeof window.FirebaseAuth.getUser === 'function' ? window.FirebaseAuth.getUser : null;
              const user = getUser ? getUser() : null;
              const uid = user && user.uid;
              const sel = uid ? localStorage.getItem(`fb_selected_profile_${uid}`) : null;
              if (!uid || !sel) return;
              if (e.data.uid === uid && e.data.profileId === sel) {
                applyTheme(e.data.theme);
              }
            } catch (_) { }
          }
        };
      }
    }

    // Open Modal (lazy-load trailer iframe on demand)
    function openMovieModal(movie) {
            // Save current scroll position before opening modal
            savedScrollPosition = window.scrollY || window.pageYOffset;
            
            // Store current movie and category in sessionStorage so player can restore on back
            sessionStorage.setItem('currentModalMovie', JSON.stringify(movie));
            sessionStorage.setItem('currentModalCategory', currentCategory);
            
            console.log('Opening modal for movie:', movie.title);
            const isSeries = (movie && (movie.mediaType === 'tv' || movie.type === 'series' || movie.isSeries));
            // Set up Stream 2 button to open player-2.html with the same logic as Stream (movies only)
            const streamBtn2 = document.getElementById('streamBtn2');
            if (!isSeries && streamBtn2) {
              // Get watch data for Stream 2 button too
              let watchData2 = null;
              if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.getMovieProgress === 'function') {
                watchData2 = window.ContinueWatchingManager.getMovieProgress(movie.id);
              }
              if (!watchData2) {
                const legacyCW = JSON.parse(localStorage.getItem('continueWatching') || '{}');
                watchData2 = legacyCW[movie.id];
              }

              streamBtn2.onclick = null;
              streamBtn2.onclick = (e) => {
                e.preventDefault();
                const isAvailable = streamBtn2.dataset.available === '1';
                if (!isAvailable) {
                  // Fallback: resolve via 8Stream API for player-2
                  streamBtn2.textContent = 'Resolvingâ€¦';
                  streamBtn2.disabled = true;
                  (async () => {
                    try {
                      const result = await window.resolveStreamUrlForMovie(movie, ['English','Hindi','Tamil','Telugu','Bengali']);
                      if (result && result.success && result.src) {
                        const params = new URLSearchParams();
                        params.append('id', movie.id);
                        params.append('movieId', movie.id);
                        params.append('title', movie.title);
                        if (movie.posterUrl) params.append('poster', movie.posterUrl);
                        const isHls2 = /\.m3u8(\?.*)?$/.test(result.src) || result.type === 'hls';
                        params.append('type', isHls2 ? 'hls' : (result.type || 'mp4'));
                        params.append('src', result.src);
                        if (result.imdbId) params.append('imdbId', result.imdbId);
                        if (result.key) params.append('streamKey', result.key);
                        if (result.language) params.append('currentLang', result.language);
                        if (result.availableLanguages) params.append('availableLangs', JSON.stringify(result.availableLanguages));
                        const finalUrl = `player-2.html?${params.toString()}`;
                        localStorage.setItem('lastPlayerUsed', 'player2');
                        window.location.href = finalUrl;
                      } else {
                        showToast('error', 'Stream Unavailable', 'Could not resolve a stream for this title.');
                      }
                    } catch (e) {
                      console.error('Stream resolve failed:', e);
                      showToast('error', 'Stream Error', 'Failed to resolve stream.');
                    } finally {
                      streamBtn2.textContent = 'Stream 2';
                      streamBtn2.disabled = false;
                    }
                  })();
                  return;
                }
                // Build the player-2.html URL with the current movie's details
                const params = new URLSearchParams();
                params.append('id', movie.id);
                params.append('movieId', movie.id);
                params.append('title', movie.title);
                if (movie.posterUrl) params.append('poster', movie.posterUrl);
                const normTitle = String(movie.title || '').trim().toLowerCase();
                let player2Url = null;
                const mp4Url = mp4Overrides[normTitle];
                if (mp4Url) {
                  const isHls = /\.m3u8(\?.*)?$/.test(mp4Url);
                  params.append('type', isHls ? 'hls' : 'mp4');
                  params.append('src', mp4Url);
                  player2Url = `player-2.html?${params.toString()}`;
                } else if (driveMovieMappings[String(movie.id)]) {
                  params.append('type', 'drive');
                  params.append('id', driveMovieMappings[String(movie.id)]);
                  player2Url = `player-2.html?${params.toString()}`;
                } else if (movie.streamUrl) {
                  const isHls = /\.m3u8(\?.*)?$/.test(movie.streamUrl);
                  params.append('type', isHls ? 'hls' : 'mp4');
                  params.append('src', movie.streamUrl);
                  player2Url = `player-2.html?${params.toString()}`;
                } else {
                  // Resolve via 8Stream API for player-2
                  streamBtn2.textContent = 'Resolvingâ€¦';
                  streamBtn2.disabled = true;
                  (async () => {
                    try {
                      const result = await window.resolveStreamUrlForMovie(movie, ['English','Hindi','Tamil','Telugu','Bengali']);
                      if (result && result.success && result.src) {
                        const isHls2 = /\.m3u8(\?.*)?$/.test(result.src) || result.type === 'hls';
                        params.append('type', isHls2 ? 'hls' : (result.type || 'mp4'));
                        params.append('src', result.src);
                        if (result.imdbId) params.append('imdbId', result.imdbId);
                        if (result.key) params.append('streamKey', result.key);
                        if (result.language) params.append('currentLang', result.language);
                        if (result.availableLanguages) params.append('availableLangs', JSON.stringify(result.availableLanguages));
                        player2Url = `player-2.html?${params.toString()}`;
                        localStorage.setItem('lastPlayerUsed', 'player2');
                        window.location.href = player2Url;
                      } else {
                        showToast('error', 'Stream Unavailable', 'Could not resolve a stream for this title.');
                      }
                    } catch (e) {
                      console.error('Stream resolve failed:', e);
                      showToast('error', 'Stream Error', 'Failed to resolve stream.');
                    } finally {
                      streamBtn2.textContent = 'Stream 2';
                      streamBtn2.disabled = false;
                    }
                  })();
                }
                if (player2Url) {
                  // Check if we have saved progress and ask whether to resume
                  if (watchData2 && watchData2.progress > 0 && watchData2.progress < 95) {
                    const duration = Number(watchData2.duration) || 0;
                    const savedCurrent = Number(watchData2.currentTime) || 0;
                    const percentBased = duration > 0 && watchData2.progress ? (duration * watchData2.progress) / 100 : 0;
                    const resumeTime = savedCurrent > 0 ? savedCurrent : percentBased;
                    const wantsResume = window.confirm(`You have progress at ${Math.round(watchData2.progress)}%.\n\nOK: Resume from there\nCancel: Start from beginning`);
                    localStorage.setItem('lastPlayerUsed', 'player2');
                    const finalUrl = wantsResume ? `${player2Url}&t=${Math.floor(resumeTime)}` : player2Url;
                    window.location.href = finalUrl;
                  } else if (player2Url) {
                    localStorage.setItem('lastPlayerUsed', 'player2');
                    window.location.href = player2Url;
                  } else {
                    showToast('error', 'Stream Unavailable', 'Stream is not available for this movie yet.');
                  }
                } else {
                  // If resolution flow navigates, we don't reach here; else show error
                }
              };
            }
      currentMovie = movie;

      // Series handling: hide stream buttons, show season/episode selectors
      // isSeries already computed above
      const seriesPicker = document.getElementById('seriesPicker');
      const seasonSelect = document.getElementById('seasonSelect');
      const episodeSelect = document.getElementById('episodeSelect');
      const seriesMeta = document.getElementById('seriesMeta');

      // Custom dropdown elements
      let dropdownsInitialized = false;
      function initCustomDropdowns() {
        // Always re-initialize dropdowns when series picker is shown
        dropdownsInitialized = false;
        // Always get fresh references to dropdown elements
        const seasonTrigger = document.getElementById('seasonTrigger');
        const seasonDropdown = document.getElementById('seasonDropdown');
        const seasonWrapper = document.getElementById('seasonSelectWrapper');
        const episodeTrigger = document.getElementById('episodeTrigger');
        const episodeDropdown = document.getElementById('episodeDropdown');
        const episodeWrapper = document.getElementById('episodeSelectWrapper');
        if (dropdownsInitialized) return;
        dropdownsInitialized = true;

        // Remove previous event listeners by replacing elements with clones
        if (seasonTrigger) {
          const newSeasonTrigger = seasonTrigger.cloneNode(true);
          seasonTrigger.parentNode.replaceChild(newSeasonTrigger, seasonTrigger);
        }
        if (episodeTrigger) {
          const newEpisodeTrigger = episodeTrigger.cloneNode(true);
          episodeTrigger.parentNode.replaceChild(newEpisodeTrigger, episodeTrigger);
        }

        // Get fresh references again after cloning
        const freshSeasonTrigger = document.getElementById('seasonTrigger');
        const freshEpisodeTrigger = document.getElementById('episodeTrigger');

        // Season dropdown toggle - use mousedown for instant response
        if (freshSeasonTrigger && seasonWrapper) {
          freshSeasonTrigger.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            if (episodeWrapper) episodeWrapper.classList.remove('active');
            if (seasonWrapper.classList.contains('active')) {
              seasonWrapper.classList.remove('active');
            } else {
              seasonWrapper.classList.add('active');
            }
          }, { passive: false });
        }

        // Episode dropdown toggle - use mousedown for instant response
        if (freshEpisodeTrigger && episodeWrapper) {
          freshEpisodeTrigger.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            if (seasonWrapper) seasonWrapper.classList.remove('active');
            if (episodeWrapper.classList.contains('active')) {
              episodeWrapper.classList.remove('active');
            } else {
              episodeWrapper.classList.add('active');
            }
          }, { passive: false });
        }

        // Close dropdowns when clicking outside
        document.addEventListener('mousedown', function(e) {
          if (seasonWrapper && !seasonWrapper.contains(e.target)) {
            seasonWrapper.classList.remove('active');
          }
          if (episodeWrapper && !episodeWrapper.contains(e.target)) {
            episodeWrapper.classList.remove('active');
          }
        });
      }

      function updateSeasonDropdown(seasons) {
        if (!seasonDropdown || !seasonTrigger) return;
        
        seasonDropdown.innerHTML = '';
        const seasonValue = seasonTrigger.querySelector('.select-value');
        
        if (!seasons || seasons.length === 0) {
          if (seasonValue) seasonValue.textContent = 'No seasons available';
          return;
        }

        seasons.forEach((season, index) => {
          const option = document.createElement('div');
          option.className = 'select-option';
          option.textContent = season.name || `Season ${season.season_number}`;
          option.dataset.value = season.season_number;
          
          if (index === 0) {
            option.classList.add('selected');
            if (seasonValue) seasonValue.textContent = option.textContent;
          }

          option.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Update visual selection
            seasonDropdown.querySelectorAll('.select-option').forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            if (seasonValue) seasonValue.textContent = option.textContent;
            
            // Update hidden select and trigger change - get fresh reference
            const currentSeasonSelect = document.getElementById('seasonSelect');
            if (currentSeasonSelect) {
              const num = season.season_number;
              currentSeasonSelect.value = String(num);
              currentSeasonSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }
            
            // Close dropdown
            if (seasonWrapper) seasonWrapper.classList.remove('active');
          }, { passive: false });

          seasonDropdown.appendChild(option);
        });
      }

      function updateEpisodeDropdown(episodes, seasonNumber) {
        if (!episodeDropdown || !episodeTrigger) return;
        
        episodeDropdown.innerHTML = '';
        const episodeValue = episodeTrigger.querySelector('.select-value');
        
        if (!episodes || episodes.length === 0) {
          if (episodeValue) episodeValue.textContent = 'No episodes available';
          return;
        }

        episodes.forEach((ep, index) => {
          const option = document.createElement('div');
          option.className = 'select-option';
          const epNum = ep.episode_number;
          option.textContent = `E${epNum} â€¢ ${ep.name || 'Episode ' + epNum}`;
          option.dataset.value = epNum;
          
          if (index === 0) {
            option.classList.add('selected');
            if (episodeValue) episodeValue.textContent = option.textContent;
          }

          option.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Update visual selection
            episodeDropdown.querySelectorAll('.select-option').forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            if (episodeValue) episodeValue.textContent = option.textContent;
            
            // Update hidden select and trigger change - get fresh reference
            const currentEpisodeSelect = document.getElementById('episodeSelect');
            if (currentEpisodeSelect) {
              currentEpisodeSelect.value = String(epNum);
              currentEpisodeSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }
            
            // Close dropdown
            if (episodeWrapper) episodeWrapper.classList.remove('active');
          }, { passive: false });

          episodeDropdown.appendChild(option);
        });
      }

      initCustomDropdowns();

      const streamButtonsWrapper = document.querySelector('.stream-buttons');
      if (streamButtonsWrapper) {
        streamButtonsWrapper.style.display = isSeries ? 'none' : 'flex';
      }
      if (seriesPicker) {
        seriesPicker.style.display = isSeries ? 'flex' : 'none';
      }

      // If series, load seasons/episodes and skip stream button wiring
      if (isSeries && seriesPicker && seasonSelect && episodeSelect) {
        // Always re-initialize dropdowns when series picker is shown
        setTimeout(() => { initCustomDropdowns(); }, 0);
        // reset selects
        const seasonValue = seasonTrigger?.querySelector('.select-value');
        const episodeValue = episodeTrigger?.querySelector('.select-value');
        if (seasonValue) seasonValue.textContent = 'Loading seasons...';
        if (episodeValue) episodeValue.textContent = 'Select a season first';
        seasonSelect.innerHTML = '<option>Loading seasons...</option>';
        episodeSelect.innerHTML = '<option>Select a season first</option>';
        if (seriesMeta) seriesMeta.textContent = 'Loading series info...';

        const loadEpisodesForSeason = async (seasonNumber) => {
          if (!movieDb || typeof movieDb.getTVSeason !== 'function') return;
          if (episodeValue) episodeValue.textContent = 'Loading episodes...';
          episodeSelect.innerHTML = '<option>Loading episodes...</option>';
          try {
            const seasonData = await movieDb.getTVSeason(movie.id, seasonNumber);
            const episodes = (seasonData && seasonData.episodes) ? seasonData.episodes : [];
            if (!episodes.length) {
              if (episodeValue) episodeValue.textContent = 'No episodes found';
              episodeSelect.innerHTML = '<option>No episodes found</option>';
              return;
            }
            episodeSelect.innerHTML = '';
            episodes.forEach(ep => {
              const opt = document.createElement('option');
              const epNum = ep.episode_number;
              opt.value = String(epNum);
              opt.textContent = `S${seasonNumber} Â· E${epNum} â€” ${ep.name || 'Episode'}`;
              episodeSelect.appendChild(opt);
            });
            
            // Update custom dropdown
            updateEpisodeDropdown(episodes, seasonNumber);
          } catch (err) {
            console.error('Failed to load episodes', err);
            if (episodeValue) episodeValue.textContent = 'Error loading episodes';
            episodeSelect.innerHTML = '<option>Error loading episodes</option>';
          }
        };

        (async () => {
          if (!movieDb || typeof movieDb.getTVDetails !== 'function') return;
          try {
            const details = await movieDb.getTVDetails(movie.id);
            const seasons = (details && details.seasons) ? details.seasons.filter(s => s.season_number > 0) : [];
            const seasonCount = seasons.length;
            const episodeCount = seasons.reduce((sum, s) => sum + (s.episode_count || 0), 0);
            if (seriesMeta) {
              seriesMeta.textContent = `${seasonCount} Season${seasonCount !== 1 ? 's' : ''}${episodeCount ? ` â€¢ ${episodeCount} Episode${episodeCount !== 1 ? 's' : ''}` : ''}`;
            }
            seasonSelect.innerHTML = '';
            if (!seasons.length) {
              if (seasonValue) seasonValue.textContent = 'No seasons found';
              seasonSelect.innerHTML = '<option>No seasons found</option>';
              return;
            }
            seasons.forEach(s => {
              const opt = document.createElement('option');
              opt.value = String(s.season_number);
              opt.textContent = s.name || `Season ${s.season_number}`;
              seasonSelect.appendChild(opt);
            });

            // Update custom dropdown
            updateSeasonDropdown(seasons);

            // Load first season by default
            const firstSeason = seasons[0];
            if (firstSeason) {
              loadEpisodesForSeason(firstSeason.season_number);
            }

            seasonSelect.onchange = (e) => {
              const seasonNumber = Number(e.target.value);
              if (!seasonNumber) return;
              loadEpisodesForSeason(seasonNumber);
            };

            // Handle episode selection to show YouTube fallback button
            let currentYouTubeKey = null;
            const openOnYouTubeBtn = document.getElementById('openOnYouTubeBtn');

            episodeSelect.onchange = async (e) => {
              const episodeNumber = Number(e.target.value);
              const seasonNumber = Number(seasonSelect.value);
              if (!episodeNumber || !seasonNumber) {
                if (openOnYouTubeBtn) openOnYouTubeBtn.style.display = 'none';
                return;
              }

              // Fetch episode videos to get YouTube key
              try {
                let videos = [];
                if (movieDb && typeof movieDb.getTVEpisodeVideos === 'function') {
                  videos = await movieDb.getTVEpisodeVideos(movie.id, seasonNumber, episodeNumber);
                }
                const best = videos.find(v => v.site === 'YouTube' && v.type === 'Trailer' && v.official) ||
                  videos.find(v => v.site === 'YouTube' && (v.type === 'Trailer' || v.type === 'Teaser' || v.type === 'Clip')) ||
                  videos.find(v => v.site === 'YouTube');

                if (best && best.key) {
                  currentYouTubeKey = best.key;
                  if (openOnYouTubeBtn) {
                    openOnYouTubeBtn.style.display = 'inline-flex';
                    openOnYouTubeBtn.onclick = (e) => {
                      e.preventDefault();
                      window.open(`https://www.youtube.com/watch?v=${currentYouTubeKey}`, '_blank');
                    };
                  }
                } else {
                  if (openOnYouTubeBtn) openOnYouTubeBtn.style.display = 'none';
                }
              } catch (err) {
                console.error('Failed to fetch episode videos', err);
                if (openOnYouTubeBtn) openOnYouTubeBtn.style.display = 'none';
              }
            };

            // Handle Play Episode button click
            const seriesPlayBtn = document.getElementById('seriesPlayBtn');
            if (seriesPlayBtn) {
              seriesPlayBtn.addEventListener('click', (e) => {
                e.preventDefault();
                
                const seasonNumber = Number(seasonSelect.value);
                const episodeNumber = Number(episodeSelect.value);
                
                if (!seasonNumber || !episodeNumber) {
                  console.warn('Please select both season and episode');
                  UIToast.warning('Select Episode', 'Please select both a season and episode');
                  return;
                }
                
                // Build player URL with season and episode parameters
                const posterUrl = movie.poster_path 
                  ? `https://image.tmdb.org/t/p/w500${movie.poster_path}`
                  : '';
                  
                const playerUrl = new URL('player.html', window.location.origin);
                playerUrl.searchParams.set('title', movie.title || movie.name);
                playerUrl.searchParams.set('movieId', movie.id);
                playerUrl.searchParams.set('season', seasonNumber);
                playerUrl.searchParams.set('episode', episodeNumber);
                playerUrl.searchParams.set('poster', posterUrl);
                playerUrl.searchParams.set('type', 'hls');
                
                console.log('Opening episode:', playerUrl.toString());
                window.location.href = playerUrl.toString();
              });
            }
          } catch (err) {
            console.error('Failed to load TV details', err);
            const currentSeasonSelect = document.getElementById('seasonSelect');
            if (currentSeasonSelect) {
              currentSeasonSelect.innerHTML = '<option>Error loading seasons</option>';
            }
            if (seriesMeta) seriesMeta.textContent = 'Unable to load series info';
          }
        })();
      }

      // Update or add resume button in modal
      const streamBtn = document.getElementById('streamBtn');
      if (!isSeries && streamBtn) {
        // Prefer the unified ContinueWatchingManager; fall back to legacy storage
        let watchData = null;
        if (window.ContinueWatchingManager && typeof window.ContinueWatchingManager.getMovieProgress === 'function') {
          watchData = window.ContinueWatchingManager.getMovieProgress(movie.id);
        }
        if (!watchData) {
          const legacyCW = JSON.parse(localStorage.getItem('continueWatching') || '{}');
          watchData = legacyCW[movie.id];
        }

        // Always check for saved progress and show appropriate button label
        if (watchData && watchData.progress > 0 && watchData.progress < 95) {
          streamBtn.innerHTML = `
            <span>Resume (${Math.round(watchData.progress)}%)</span>
            <span class="stream-icon">â–¶ï¸</span>
          `;
        } else {
          streamBtn.innerHTML = `
            <span>Watch Now</span>
            <span class="stream-icon">â–¶ï¸</span>
          `;
        }

        // Remove any existing onclick handlers
        streamBtn.onclick = null;
        streamBtn.onclick = (e) => {
          e.preventDefault();
          const isAvailable = streamBtn.dataset.available === '1';
          if (!isAvailable) {
            // Fallback: resolve via 8Stream API even when no direct source
            streamBtn.textContent = 'Resolving streamâ€¦';
            streamBtn.disabled = true;
            (async () => {
              try {
                const result = await window.resolveStreamUrlForMovie(movie, ['English','Hindi','Tamil','Telugu','Bengali']);
                if (result && result.success && result.src) {
                  const params = new URLSearchParams();
                  params.append('id', movie.id);
                  params.append('movieId', movie.id);
                  params.append('title', movie.title);
                  if (movie.posterUrl) params.append('poster', movie.posterUrl);
                  const isHls = /\.m3u8(\?.*)?$/.test(result.src) || result.type === 'hls';
                  params.append('type', isHls ? 'hls' : (result.type || 'mp4'));
                  params.append('src', result.src);
                  if (result.imdbId) params.append('imdbId', result.imdbId);
                  if (result.key) params.append('streamKey', result.key);
                  if (result.language) params.append('currentLang', result.language);
                  if (result.availableLanguages) params.append('availableLangs', JSON.stringify(result.availableLanguages));
                  const finalUrl = `player.html?${params.toString()}`;
                  window.location.href = finalUrl;
                } else {
                  showToast('error', 'Stream Unavailable', 'Could not resolve a stream for this title.');
                }
              } catch (e) {
                console.error('Stream resolve failed:', e);
                showToast('error', 'Stream Error', 'Failed to resolve stream.');
              } finally {
                streamBtn.textContent = (watchData && watchData.progress > 0 && watchData.progress < 95) ? `Resume (${Math.round(watchData.progress)}%)` : 'Watch Now';
                streamBtn.disabled = false;
              }
            })();
            return;
          }

          // Build the player URL with the movie's details
          const params = new URLSearchParams();
          params.append('id', movie.id);
          params.append('movieId', movie.id);
          params.append('title', movie.title);
          if (movie.posterUrl) params.append('poster', movie.posterUrl);

          // Check for available sources in order of preference
          const normTitle = String(movie.title || '').trim().toLowerCase();
          let playerUrl = null;

          // 1) Check for direct MP4 override
          const mp4Url = getMp4Override(movie.title);
          if (mp4Url) {
            const isHls = /\.m3u8(\?.*)?$/.test(mp4Url);
            params.append('type', isHls ? 'hls' : 'mp4');
            params.append('src', mp4Url);
            playerUrl = `player.html?${params.toString()}`;
          }
          // 2) Check for Google Drive mapping
          else if (driveMovieMappings[String(movie.id)]) {
            params.append('type', 'drive');
            params.append('id', driveMovieMappings[String(movie.id)]);
            playerUrl = `player.html?${params.toString()}`;
          }
          // 3) Check for direct stream URL
          else if (movie.streamUrl) {
            const isHls = /\.m3u8(\?.*)?$/.test(movie.streamUrl);
            params.append('type', isHls ? 'hls' : 'mp4');
            params.append('src', movie.streamUrl);
            playerUrl = `player.html?${params.toString()}`;
          } else {
            // 5) Resolve via 8Stream API on-demand
            streamBtn.textContent = 'Resolving streamâ€¦';
            streamBtn.disabled = true;
            (async () => {
              try {
                const result = await window.resolveStreamUrlForMovie(movie, ['English','Hindi','Tamil','Telugu','Bengali']);
                if (result && result.success && result.src) {
                  // Handle iframe embeds (VidSrc) differently
                  if (result.type === 'iframe') {
                    params.append('type', 'iframe');
                    params.append('src', result.src);
                    if (result.provider) params.append('provider', result.provider);
                    if (result.languageStreams) params.append('languageStreams', JSON.stringify(result.languageStreams));
                    if (result.tmdbId) params.append('tmdbId', result.tmdbId);
                  } else {
                    const isHls2 = /\.m3u8(\?.*)?$/.test(result.src) || result.type === 'hls';
                    params.append('type', isHls2 ? 'hls' : (result.type || 'mp4'));
                    params.append('src', result.src);
                  }
                  if (result.imdbId) params.append('imdbId', result.imdbId);
                  if (result.key) params.append('streamKey', result.key);
                  if (result.language) params.append('currentLang', result.language);
                  if (result.availableLanguages) params.append('availableLangs', JSON.stringify(result.availableLanguages));
                  if (result.languageInfo) params.append('languageInfo', JSON.stringify(result.languageInfo));
                  const finalUrl = `player.html?${params.toString()}`;
                  window.location.href = finalUrl;
                } else {
                  const errorMsg = result?.message || 'Could not resolve a stream for this title.';
                  console.warn('Stream resolution failed:', errorMsg);
                  showToast('error', 'Stream Unavailable', errorMsg);
                }
              } catch (e) {
                console.error('Stream resolve failed:', e);
                showToast('error', 'Stream Error', 'Failed to resolve stream.');
              } finally {
                streamBtn.textContent = (watchData && watchData.progress > 0 && watchData.progress < 95) ? `Resume (${Math.round(watchData.progress)}%)` : 'Watch Now';
                streamBtn.disabled = false;
              }
            })();
            return;
          }

          if (playerUrl) {
            // Check if we have saved progress and ask whether to resume
            if (watchData && watchData.progress > 0 && watchData.progress < 95) {
              const duration = Number(watchData.duration) || 0;
              const savedCurrent = Number(watchData.currentTime) || 0;
              const percentBased = duration > 0 && watchData.progress ? (duration * watchData.progress) / 100 : 0;
              const resumeTime = savedCurrent > 0 ? savedCurrent : percentBased;
              const wantsResume = window.confirm(`You have progress at ${Math.round(watchData.progress)}%.\n\nOK: Resume from there\nCancel: Start from beginning`);
              
              const finalUrl = wantsResume ? `${playerUrl}&t=${Math.floor(resumeTime)}` : playerUrl;
              window.location.href = finalUrl;
            } else {
              // No saved progress, navigate in the same tab
              window.location.href = playerUrl;
            }
          } else {
            showToast('error', 'Stream Unavailable', 'Stream is not available for this movie yet.');
          }
        };
      }

      // ... existing code for setting up modal content ...
      const title = movie.title || 'Untitled';
      const year = movie.year || (movie.release_date ? movie.release_date.split('-')[0] : '');
      document.getElementById('modalTitle').innerText = title;
      document.getElementById('modalYear').innerText = year;
      document.getElementById('modalOverview').innerText = movie.overview || '';
      document.getElementById('modalRating').innerText = movie.rating ? movie.rating.toFixed(1) : 'N/A';
      document.getElementById('modalReleaseDate').innerText = movie.release_date || 'Unknown';
      const genresEl = document.getElementById('modalGenres');
      if (genresEl) {
        const list = Array.isArray(movie.genres) ? movie.genres : [];
        genresEl.innerHTML = list.map(g => `<span class="genre-chip">${g}</span>`).join('');
      }

      const trailerHost = document.getElementById('trailerHost');
      const placeholderImg = document.getElementById('trailerPlaceholderImg');
      
      setTrailerHostContent(movie, trailerHost, placeholderImg);
      ensureMovieTrailer(movie).then(() => {
        setTrailerHostContent(movie, trailerHost, placeholderImg);
      });

      // Stream availability: drive mapping OR MP4 OR streamUrl OR API resolver
      if (!isSeries && streamBtn) {
        const normTitle = String(title).trim().toLowerCase();
        const canResolve = typeof window.resolveStreamUrlForMovie === 'function';
        const hasStream = !!(driveMovieMappings[String(movie.id)] || getMp4Override(title) || movie.streamUrl || canResolve);
        streamBtn.dataset.movieId = movie.id;
        streamBtn.dataset.available = hasStream ? '1' : '0';
        streamBtn.textContent = hasStream ? 'Stream' : 'Stream';
        streamBtn.classList.toggle('unavailable', !hasStream);
        streamBtn.disabled = !hasStream;
        // Keep button clickable so we can show a system message when unavailable
        streamBtn.disabled = false;
      }

      if (!isSeries) {
        // Stream 2 availability: Any video source available (Drive, MP4, or streamUrl)
        const normTitle = String(title).trim().toLowerCase();
        const streamBtn2El = document.getElementById('streamBtn2');
        const canResolve2 = typeof window.resolveStreamUrlForMovie === 'function';
        const hasStream2 = !!(driveMovieMappings[String(movie.id)] || getMp4Override(title) || movie.streamUrl || canResolve2);
        if (streamBtn2El) {
          streamBtn2El.dataset.movieId = movie.id;
          streamBtn2El.dataset.available = hasStream2 ? '1' : '0';
          streamBtn2El.textContent = hasStream2 ? 'Stream 2' : 'Stream 2';
          streamBtn2El.classList.toggle('unavailable', !hasStream2);
          streamBtn2El.disabled = !hasStream2;
          // Keep button clickable so we can show a system message when unavailable
          streamBtn2El.disabled = false;
        }
      }

    // Update bookmark button state - now async
      const bookmarkBtn = document.getElementById('bookmarkBtn');
      if (bookmarkBtn) {
        // Update button state immediately when modal opens
        isBookmarked(movie.id).then(bookmarked => {
          bookmarkBtn.classList.toggle('bookmarked', bookmarked);
          bookmarkBtn.title = bookmarked ? 'Remove from My List' : 'Add to My List';
          bookmarkBtn.setAttribute('aria-label', bookmarked ? 'Remove from My List' : 'Add to My List');

          // Update icon
          const icon = bookmarkBtn.querySelector('i');
          if (icon) {
            icon.className = bookmarked ? 'fas fa-bookmark' : 'far fa-bookmark';
          }

          // Update text
          const textSpan = bookmarkBtn.querySelector('.bookmark-text');
          if (textSpan) {
            textSpan.textContent = bookmarked ? 'In My List' : 'Add to My List';
          }
        });
      }

      // Prevent background scrolling when modal opens
      document.body.style.overflow = 'hidden';
      modal.style.display = 'flex';
    }

    // Video player controls and touch gestures
    let hideControlsTimeout;
    const HIDE_CONTROLS_DELAY = 3000; // 3 seconds

    // Save video progress to localStorage
    function saveVideoProgress(video, movieId, title, posterUrl) {
      if (!video || !movieId) return;

      const progress = (video.currentTime / video.duration) * 100;

      // Only save if video has been watched for at least 5 seconds and less than 95%
      if (video.currentTime > 5 && progress < 95) {
        const continueWatching = JSON.parse(localStorage.getItem('continueWatching') || '{}');

        continueWatching[movieId] = {
          id: movieId,
          title: title || 'Untitled',
          poster: posterUrl || '',
          progress: progress,
          currentTime: video.currentTime,
          duration: video.duration,
          timestamp: Date.now()
        };

        // Clean up old entries (keep only the 20 most recent)
        const entries = Object.entries(continueWatching)
          .sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0))
          .slice(0, 20);

        const cleanedContinueWatching = {};
        entries.forEach(([id, data]) => {
          cleanedContinueWatching[id] = data;
        });

        localStorage.setItem('continueWatching', JSON.stringify(cleanedContinueWatching));
      }
    }

    // Load saved progress for a video
    function loadVideoProgress(video, movieId) {
      if (!video || !movieId) return;

      const continueWatching = JSON.parse(localStorage.getItem('continueWatching') || '{}');
      const savedProgress = continueWatching[movieId];

      if (savedProgress && savedProgress.currentTime && savedProgress.duration) {
        // Only resume if there's significant progress (at least 5 seconds)
        if (savedProgress.currentTime > 5 && savedProgress.progress < 95) {
          // Set a flag to prevent multiple timeupdate events during initial seek
          video.dataset.seeking = 'true';

          // Set the video time to the saved position
          video.currentTime = savedProgress.currentTime;

          // Update the progress bar
          updateProgressBar(video);

          // Show a 'resuming from...' notification
          showNotification(`Resuming from ${Math.round(savedProgress.progress)}%`);

          // Remove the seeking flag after a short delay
          setTimeout(() => {
            delete video.dataset.seeking;
          }, 1000);
        }
      }
    }

    // Update progress bar
    function updateProgressBar(video) {
      const progressBar = document.querySelector('.video-progress-bar');
      if (progressBar) {
        const progress = (video.currentTime / video.duration) * 100;
        progressBar.style.width = `${progress}%`;
      }
    }

    function setupVideoPlayer(video) {
      if (!video) return;

      // Get movie ID from the video element or its parent
      const movieCard = video.closest('.movie-card');
      const movieId = movieCard ? movieCard.dataset.movieId : null;
      const movieTitle = movieCard ? movieCard.dataset.title : 'Untitled';
      const posterUrl = movieCard ? movieCard.dataset.poster : '';

      // Load saved progress
      if (movieId) {
        loadVideoProgress(video, movieId);
      }

      // Auto-hide controls in fullscreen
      const controls = video.parentElement.querySelector('.video-controls');

      function showControls() {
        if (controls) controls.style.opacity = '1';
        resetHideControlsTimeout();
      }

      function hideControls() {
        if (document.fullscreenElement && controls) {
          controls.style.opacity = '0';
        }
      }

      function resetHideControlsTimeout() {
        clearTimeout(hideControlsTimeout);
        if (document.fullscreenElement) {
          hideControlsTimeout = setTimeout(hideControls, HIDE_CONTROLS_DELAY);
        }
      }

      // Touch event handlers for double tap
      let lastTap = 0;
      let tapTimeout;

      video.addEventListener('touchend', function (e) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;

        clearTimeout(tapTimeout);

        if (tapLength < 300 && tapLength > 0) {
          // Double tap detected
          const rect = video.getBoundingClientRect();
          const tapX = e.changedTouches[0].clientX - rect.left;
          const tapPosition = tapX / rect.width;

          if (tapPosition > 0.7) {
            // Right side - skip forward 10s
            video.currentTime = Math.min(video.duration, video.currentTime + 10);
          } else if (tapPosition < 0.3) {
            // Left side - rewind 10s
            video.currentTime = Math.max(0, video.currentTime - 10);
          }

          // Show feedback
          showControls();
        } else {
          tapTimeout = setTimeout(() => {
            clearTimeout(tapTimeout);
          }, 300);
        }

        lastTap = currentTime;
      });

      // Show controls on interaction
      ['mousemove', 'touchmove', 'click'].forEach(event => {
        video.addEventListener(event, showControls);
      });

      // Fullscreen change handler
      document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement) {
          showControls();
        } else if (controls) {
          controls.style.opacity = '1';
        }
      });

      // Update progress bar and save progress as video plays
      video.addEventListener('timeupdate', () => {
        // Only update if not currently seeking
        if (!video.dataset.seeking) {
          updateProgressBar(video);

          // Save progress every 5 seconds
          if (movieId && Math.floor(video.currentTime) % 5 === 0) {
            saveVideoProgress(video, movieId, movieTitle, posterUrl);
          }
        }
      });

      // Save final progress when video ends
      video.addEventListener('ended', () => {
        if (movieId) {
          saveVideoProgress(video, movieId, movieTitle, posterUrl);
        }
      });

      // Handle seeking
      video.addEventListener('seeking', () => {
        video.dataset.seeking = 'true';
      });

      video.addEventListener('seeked', () => {
        delete video.dataset.seeking;
        if (movieId) {
          saveVideoProgress(video, movieId, movieTitle, posterUrl);
        }
      });
    }

    // Check if device is in portrait mode
    function isPortraitMode() {
      return window.matchMedia("(orientation: portrait)").matches;
    }

    // Request landscape orientation
    async function requestLandscape() {
      try {
        if (screen.orientation && screen.orientation.lock) {
          await screen.orientation.lock('landscape');
        } else if (screen.lockOrientation) {
          screen.lockOrientation('landscape');
        } else if (screen.mozLockOrientation) {
          screen.mozLockOrientation('landscape');
        } else if (screen.msLockOrientation) {
          screen.msLockOrientation('landscape');
        }
      } catch (err) {
        console.warn('Failed to lock orientation:', err);
      }
    }

    // Stream behavior - open player in the same tab
    streamBtn.addEventListener('click', (e) => {
      e.preventDefault();
      if (!currentMovie) return showToast('error', 'No Movie', 'No movie selected.');

      const isAvailable = streamBtn.dataset.available === '1';
      if (!isAvailable) {
        showToast('error', 'Stream Unavailable', 'This stream is not available currently!');
        return;
      }
      // ...existing code for opening the player...
      // Pause any playing YouTube trailer
      if (ytPlayer) {
        try {
          ytPlayer.pauseVideo();
        } catch (e) { }
      }
      // Pause any playing HTML5 video trailer
      const trailerHost = document.getElementById('trailerHost');
      if (trailerHost) {
        const video = trailerHost.querySelector('video');
        if (video && !video.paused) {
          video.pause();
        }
      }
      // Check if in portrait mode and request landscape
      if (isPortraitMode()) {
        requestLandscape().catch(console.error);
      }

      // Get movie details
      const movieId = String(currentMovie.id);
      const title = encodeURIComponent(currentMovie.title || '');
      const poster = encodeURIComponent(currentMovie.posterUrl || '');
      // Check for watch progress (prefer manager, then legacy storage)
      let resumeSeconds = 0;
      try {
        const mgr = window.ContinueWatchingManager;
        const mgrProgress = mgr && typeof mgr.getMovieProgress === 'function' ? mgr.getMovieProgress(movieId) : null;
        if (mgrProgress && Number(mgrProgress.currentTime) > 0) {
          resumeSeconds = Number(mgrProgress.currentTime);
        }
      } catch (_) { }

      if (resumeSeconds <= 0) {
        const watchData = JSON.parse(localStorage.getItem('watchProgress') || '{}');
        const hasProgress = watchData[movieId] && watchData[movieId].progress > 0;
        if (hasProgress) {
          resumeSeconds = Math.floor((watchData[movieId].duration * watchData[movieId].progress) / 100);
        }
      }
      // Build the player URL with the current movie's details
      const params = new URLSearchParams();
      params.append('id', movieId);
      params.append('movieId', movieId);
      params.append('title', currentMovie.title);
      if (currentMovie.posterUrl) params.append('poster', currentMovie.posterUrl);

      // Check for available sources in order of preference
      const normTitle = String(currentMovie.title || '').trim().toLowerCase();
      let playerUrl = null;

      // 1) Check for direct MP4 override
      const mp4Url = getMp4Override(currentMovie.title);
      if (mp4Url) {
        const isHls = /\.m3u8(\?.*)?$/.test(mp4Url);
        params.append('type', isHls ? 'hls' : 'mp4');
        params.append('src', mp4Url);
        playerUrl = `player.html?${params.toString()}`;
      }
      // 2) Check for Google Drive mapping
      else if (driveMovieMappings[movieId]) {
        params.append('type', 'drive');
        params.append('id', driveMovieMappings[movieId]);
        playerUrl = `player.html?${params.toString()}`;
      }
      // 3) Check for direct stream URL
      else if (currentMovie.streamUrl) {
        const isHls = /\.m3u8(\?.*)?$/.test(currentMovie.streamUrl);
        params.append('type', isHls ? 'hls' : 'mp4');
        params.append('src', currentMovie.streamUrl);
        playerUrl = `player.html?${params.toString()}`;
      } else {
        // Resolve on-demand from hero section
        const heroStreamBtn = document.getElementById('heroStreamBtn') || document.querySelector('[data-hero-stream-btn]');
        if (heroStreamBtn) {
          heroStreamBtn.textContent = 'Resolvingâ€¦';
          heroStreamBtn.disabled = true;
        }
        (async () => {
          try {
            const result = await window.resolveStreamUrlForMovie(currentMovie, ['English','Hindi','Tamil','Telugu','Bengali']);
            if (result && result.success && result.src) {
              const isHls2 = /\.m3u8(\?.*)?$/.test(result.src) || result.type === 'hls';
              params.append('type', isHls2 ? 'hls' : (result.type || 'mp4'));
              params.append('src', result.src);
              if (result.imdbId) params.append('imdbId', result.imdbId);
              if (result.key) params.append('streamKey', result.key);
              if (result.language) params.append('currentLang', result.language);
              if (result.availableLanguages) params.append('availableLangs', JSON.stringify(result.availableLanguages));
              if (result.languageInfo) params.append('languageInfo', JSON.stringify(result.languageInfo));
              playerUrl = `player.html?${params.toString()}`;
              const finalUrl = resumeSeconds > 0 ? `${playerUrl}&t=${Math.floor(resumeSeconds)}` : playerUrl;
              window.location.href = finalUrl;
            } else {
              const errorMsg = result?.message || 'Could not resolve a stream for this title.';
              console.warn('Hero stream resolution failed:', errorMsg);
              showToast('error', 'Stream Resolution Failed', errorMsg);
            }
          } catch (e) {
            console.error('Hero stream resolve failed:', e);
            showToast('error', 'Stream Error', 'Failed to resolve stream: ' + (e?.message || 'Unknown error'));
          } finally {
            const heroStreamBtn = document.getElementById('heroStreamBtn') || document.querySelector('[data-hero-stream-btn]');
            if (heroStreamBtn) {
              heroStreamBtn.textContent = 'Stream';
              heroStreamBtn.disabled = false;
            }
          }
        })();
        return; // Don't fall through to the playerUrl check below
      }

      if (playerUrl) {
        // Append resume time only if we have it to trigger prompt/resume
        const finalUrl = resumeSeconds > 0 ? `${playerUrl}&t=${Math.floor(resumeSeconds)}` : playerUrl;
        window.location.href = finalUrl;
      } else {
        showToast('error', 'No Stream', 'Stream is not available for this movie yet.');
      }
    });

    // Prefetch player pages so first playback starts faster
    function warmupPlayerPages() {
      const head = document.head || document.getElementsByTagName('head')[0];
      const targets = [
        { href: 'player.html', as: 'document' },
        { href: 'player-2.html', as: 'document' },
        { href: 'js/player-continue-watching.js', as: 'script' }
      ];

      targets.forEach(({ href, as }) => {
        if (document.querySelector(`link[rel="prefetch"][href="${href}"]`)) return;
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = href;
        if (as) link.as = as;
        head.appendChild(link);
      });
    }

    function schedulePlayerWarmup() {
      const run = () => warmupPlayerPages();
      if ('requestIdleCallback' in window) {
        requestIdleCallback(run, { timeout: 2000 });
      } else {
        setTimeout(run, 1000);
      }
    }

    // Toast helper
    function showToast(type, title, message, timeout = 4000) {
      const container = document.getElementById('toastContainer');
      if (!container) return;
      const toast = document.createElement('div');
      const t = type || 'info';
      toast.className = `toast ${t}`;
      toast.setAttribute('role', 'status');
      const icons = {
        info: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#60a5fa"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm0 5.5a1.25 1.25 0 1 1 0 2.5 1.25 1.25 0 0 1 0-2.5Zm1.5 11h-3v-1.5h1v-5h-1V10h2v7.5h1V18.5Z"/></svg>',
        success: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#34d399"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm-1.1 13.6-3.9-3.9 1.4-1.4 2.5 2.5 5.2-5.2 1.4 1.4-6.6 6.6Z"/></svg>',
        warning: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#fbbf24"><path d="M12.87 3.5a1.5 1.5 0 0 0-2.74 0L2.3 18.2A1.5 1.5 0 0 0 3.63 20.4h16.74a1.5 1.5 0 0 0 1.33-2.2L12.87 3.5ZM11 9h2v5h-2V9Zm0 6h2v2h-2v-2Z"/></svg>',
        error: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#f87171"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Zm3.5 12.09-1.41 1.41L12 13.41l-2.09 2.09-1.41-1.41L10.59 12 8.5 9.91l1.41-1.41L12 10.59l2.09-2.09 1.41 1.41L13.41 12l2.09 2.09Z"/></svg>'
      };
      const iconSvg = icons[t] || icons.info;
      toast.innerHTML = `
        <div class="icon" aria-hidden="true">${iconSvg}</div>
        <div style="display:flex; flex-direction:column; gap:2px;">
          <div class="title">${title || ''}</div>
          <div class="msg">${message || ''}</div>
        </div>
        <button class="close" aria-label="Close" title="Close">Ã—</button>
      `;
      const closeBtn = toast.querySelector('.close');
      closeBtn.addEventListener('click', () => toast.remove());
      container.appendChild(toast);
      if (timeout > 0) {
        setTimeout(() => { try { toast.remove(); } catch (e) { } }, timeout);
      }
    }

    // Load continue watching when the page loads
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize theme first (fallback until auth/profile resolves)
      const key = getScopedThemeKey();
      const savedTheme = localStorage.getItem(key) || 'glossy';
      applyTheme(savedTheme);
      schedulePlayerWarmup();

      // Load continue watching after a short delay to ensure DOM is ready
      setTimeout(() => {
        console.log('DOM fully loaded, loading continue watching...');
        loadContinueWatching();

        // Wire up Clear All button
        const clearBtn = document.getElementById('cwClearAll');
        if (clearBtn) {
          clearBtn.addEventListener('click', async () => {
            try {
              clearBtn.disabled = true;
              clearBtn.style.opacity = '0.7';
              if (!window.FirebaseSync || typeof window.FirebaseSync.clearContinueWatching !== 'function') {
                console.warn('FirebaseSync.clearContinueWatching not available');
                return;
              }
              const ok = await window.FirebaseSync.clearContinueWatching();
              if (ok) {
                await loadContinueWatching(true);
              }
            } finally {
              clearBtn.disabled = false;
              clearBtn.style.opacity = '1';
            }
          });
        }

        // Also listen for continue watching updates from other tabs/windows
        window.addEventListener('storage', (e) => {
          if (e.key === 'continueWatching') {
            loadContinueWatching();
          }
        });

        // Dispatch a custom event to notify that continue watching is loaded
        document.dispatchEvent(new CustomEvent('continueWatchingLoaded'));
      }, 300);
    });

    // (Removed duplicate unconditional streamBtn click handler that always showed the error message)

    // Lazy-load trailer iframe when placeholder is clicked
    document.addEventListener('click', (e) => {
      const host = e.target.closest && e.target.closest('#trailerHost');
      if (!host) return;
      // If a player is already present and visible, do nothing
      if (host.querySelector('iframe') || host.querySelector('div[id^="yt-player-"]')) return;

      const mp4Url = host.dataset.mp4Url;
      const key = host.dataset.youtubeKey;

      if (mp4Url) {
        // Create video player directly (don't preload)
        host.innerHTML = `
          <video id="trailerVideo" class="video-player" controls style="width:100%;height:100%;background:#000;" crossorigin="anonymous">
            <source src="${mp4Url}" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        `;
        
        let video = host.querySelector('#trailerVideo');
        let retryCount = 0;
        const maxRetries = 3;
        
        function createRetryButton() {
          const retryBtn = document.createElement('button');
          retryBtn.style = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:15px 30px;background:#ff6b6b;border:none;border-radius:8px;color:#fff;font-size:1rem;cursor:pointer;z-index:100;';
          retryBtn.textContent = `Retry Loading (${retryCount + 1}/${maxRetries})`;
          retryBtn.onclick = (e) => {
            e.stopPropagation();
            retryCount++;
            if (retryCount <= maxRetries) {
              retryBtn.remove();
              video.load();
              showSpinner();
            } else {
              retryBtn.textContent = 'Failed to load trailer';
              retryBtn.disabled = true;
            }
          };
          return retryBtn;
        }
        // Add spinner for trailer buffering
        let spinner = host.querySelector('.trailer-loading-spinner');
        if (!spinner) {
          spinner = document.createElement('div');
          spinner.className = 'trailer-loading-spinner';
          spinner.style = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:1000;width:48px;height:48px;border:6px solid #fff;border-top:6px solid #888;border-radius:50%;animation:spin 1s linear infinite;display:none;';
          host.appendChild(spinner);
        }
        function showSpinner() { 
          spinner.style.display = 'block'; 
          console.log('Trailer loading...');
        }
        function hideSpinner() { 
          spinner.style.display = 'none'; 
          console.log('Trailer loaded');
        }
        
        // Add timeout for stuck loading
        let loadingTimeout;
        let hasStartedLoading = false;
        
        // Attach spinner events
        setTimeout(() => {
          let v = host.querySelector('video');
          if (v) {
            // Track if video has started loading data
            v.addEventListener('loadstart', () => {
              hasStartedLoading = true;
              clearTimeout(loadingTimeout);
              showSpinner();
              console.log('Trailer: Video data started loading');
            });
            
            v.addEventListener('waiting', () => {
              showSpinner();
              // Set timeout to show warning if loading takes too long
              clearTimeout(loadingTimeout);
              loadingTimeout = setTimeout(() => {
                if (spinner.style.display === 'block' && hasStartedLoading) {
                  // Show retry button on timeout
                  hideSpinner();
                  if (retryCount < maxRetries) {
                    const retryBtn = createRetryButton();
                    host.appendChild(retryBtn);
                  } else {
                    const errorMsg = document.createElement('div');
                    errorMsg.style = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,0.8);padding:20px;border-radius:8px;text-align:center;max-width:80%;z-index:100;';
                    errorMsg.innerHTML = `<p>Trailer is loading very slowly.</p><p style="font-size:0.85em;opacity:0.7;margin-top:8px;">Maximum retry attempts reached. Please try again later.</p>`;
                    host.appendChild(errorMsg);
                    setTimeout(() => errorMsg.remove(), 5000);
                  }
                }
              }, 15000); // 15 second timeout for slow connections
            });
            v.addEventListener('seeking', showSpinner);
            v.addEventListener('stalled', showSpinner);
            v.addEventListener('playing', () => {
              clearTimeout(loadingTimeout);
              hideSpinner();
              console.log('Trailer: Video playing');
            });
            v.addEventListener('canplay', () => {
              clearTimeout(loadingTimeout);
              hideSpinner();
              console.log('Trailer: Video ready to play');
            });
            v.addEventListener('canplaythrough', () => {
              clearTimeout(loadingTimeout);
              hideSpinner();
              console.log('Trailer: Video can play through');
            });
            v.addEventListener('ended', hideSpinner);
            
            // Handle video errors
            v.addEventListener('error', function(e) {
              console.error('Trailer video error:', e, v.error);
              clearTimeout(loadingTimeout);
              hideSpinner();
              
              // Show retry button if retries available
              if (retryCount < maxRetries) {
                const retryBtn = createRetryButton();
                host.appendChild(retryBtn);
              } else {
                // Show error message after max retries
                const errorMsg = document.createElement('div');
                errorMsg.style = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;background:rgba(0,0,0,0.8);padding:20px;border-radius:8px;text-align:center;max-width:80%;z-index:100;';
                let errorDetails = 'The video file may not be available or there was a network error.';
                if (v.error) {
                  switch(v.error.code) {
                    case 1: errorDetails = 'Video loading was aborted.'; break;
                    case 2: errorDetails = 'Network error occurred while loading the video.'; break;
                    case 3: errorDetails = 'Video decoding failed.'; break;
                    case 4: errorDetails = 'Video format is not supported.'; break;
                  }
                }
                errorMsg.innerHTML = `<p>Unable to load trailer video.</p><p style="font-size:0.85em;opacity:0.7;margin-top:8px;">${errorDetails}</p>`;
                host.appendChild(errorMsg);
              }
            });
            
            // On mobile/landscape, reload and play after seek
            v.addEventListener('seeked', function() {
              if ((window.innerWidth <= 900 && window.matchMedia('(orientation: landscape)').matches) || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                // Only reload if not already loading
                if (v.readyState < 2) v.load();
                if (v.paused) {
                  const playPromise = v.play();
                  if (playPromise !== undefined) { playPromise.catch(() => {}); }
                }
              }
            });
          }
        }, 100);
      } else if (key) {
        createYTPlayerFor(host, key);
      } else {
        alert('Trailer not available.');
      }
    });

    // Click outside modal to close (backdrop)
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeModalBtn.click();
      }
    });

    // ESC to close
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && modal.style.display === 'flex') {
        closeModalBtn.click();
      }
    });

    // Search
    function searchLocalMovies(query) {
      const q = query.trim().toLowerCase();
      if (!q) return curatedMovies.slice();
      return curatedMovies.filter(m => {
        return (m.title || '').toLowerCase().includes(q) || (m.genres || []).some(g => g.toLowerCase().includes(q)) || String(m.year).includes(q);
      });
    }

    function performSearch() {
      const query = searchInput.value.trim();
      const popularSection = document.getElementById('popularMoviesSection');
      const popularTVSection = document.getElementById('popularTVSection');

      // Add searching class to body
      document.body.classList.add('searching');

      // Delegate search to TMDB when enabled
      if (useTMDBCatalog && typeof searchTMDB === 'function') {
        if (!query) {
          document.body.classList.remove('searching');
          isSearching = false;
          if (popularSection) popularSection.style.display = '';
          if (popularTVSection) popularTVSection.style.display = '';
          loadAllTMDBMovies().then(movies => displayMovies(movies, false, 'All Movies'));
          return;
        }

        // Hide popular movies section during search
        if (popularSection) popularSection.style.display = 'none';
        if (popularTVSection) popularTVSection.style.display = 'none';
        isSearching = true;
        searchTMDB(query);
        return;
      }

      if (!query) {
        // If search is empty, show all movies with continue watching
        document.body.classList.remove('searching');
        isSearching = false;
        if (popularSection) popularSection.style.display = '';
        if (popularTVSection) popularTVSection.style.display = '';
        displayMovies(curatedMovies, false);
        return;
      }

      // Hide popular movies section during search
      if (popularSection) popularSection.style.display = 'none';
      if (popularTVSection) popularTVSection.style.display = 'none';

      // Set searching state
      isSearching = true;

      // Perform search
      const results = searchLocalMovies(query);

      if (results.length === 0) {
        document.body.classList.remove('searching');
        isSearching = false;
        showToast('info', 'No Results', 'No matching movies found in the curated list.', 3000);
        return;
      }

      // Display only search results (no continue watching)
      displayMovies(results, true);
    }

    searchBtn.addEventListener('click', performSearch);
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        performSearch();
      }
    });

    // Close modal: stop playback and remove iframe to free resources
    closeModalBtn.addEventListener('click', () => {
      modal.style.display = 'none';
      // Restore scroll position to where user was
      window.scrollTo(0, savedScrollPosition);
      // Restore background scrolling when modal closes
      document.body.style.overflow = '';
      // Re-enable theme switch
      (function () {
        const ts = document.getElementById('themeSwitch');
        if (ts) {
          ts.style.pointerEvents = '';
          ts.style.opacity = '';
          ts.removeAttribute('aria-disabled');
          const prev = ts.getAttribute('data-prev-tabindex');
          if (prev !== null) {
            if (prev === '') ts.removeAttribute('tabindex');
            else ts.setAttribute('tabindex', prev);
          } else {
            ts.removeAttribute('tabindex');
          }
        }
      })();
      const trailerHost = document.getElementById('trailerHost');
      if (trailerHost) {
        // Stop and remove video element if present
        const video = trailerHost.querySelector('video');
        if (video) {
          video.pause();
          video.src = '';
        }
        // destroy YT player if present
        try {
          if (ytPlayer) { ytPlayer.stopVideo(); ytPlayer.destroy(); }
        } catch (e) { }
        ytPlayer = null;
        // restore placeholder structure
        trailerHost.innerHTML = '<img id="trailerPlaceholderImg" src="" alt="Trailer preview" /><div class="video-play-btn" title="Play trailer"></div>';
        trailerHost.style.willChange = '';
        trailerHost.style.transform = '';
      }
    });

    // Bookmark button handler
    const bookmarkBtn = document.getElementById('bookmarkBtn');
    if (bookmarkBtn) {
      bookmarkBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (!currentMovie) return;

        const bookmarked = await isBookmarked(currentMovie.id);
        console.log('Bookmark button clicked. Current state:', bookmarked, 'Movie:', currentMovie.id);

        if (bookmarked) {
          // Remove from bookmarks
          if (await removeBookmark(currentMovie.id)) {
            bookmarkBtn.classList.remove('bookmarked');
            bookmarkBtn.title = 'Add to My List';
            bookmarkBtn.setAttribute('aria-label', 'Add to My List');
            const icon = bookmarkBtn.querySelector('i');
            if (icon) icon.className = 'far fa-bookmark';
            const textSpan = bookmarkBtn.querySelector('.bookmark-text');
            if (textSpan) textSpan.textContent = 'Add to My List';
            showToast('info', 'Removed', `${currentMovie.title} removed from My List`, 2000);
          }
        } else {
          // Add to bookmarks
          if (await addBookmark(currentMovie)) {
            bookmarkBtn.classList.add('bookmarked');
            bookmarkBtn.title = 'Remove from My List';
            bookmarkBtn.setAttribute('aria-label', 'Remove from My List');
            const icon = bookmarkBtn.querySelector('i');
            if (icon) icon.className = 'fas fa-bookmark';
            const textSpan = bookmarkBtn.querySelector('.bookmark-text');
            if (textSpan) textSpan.textContent = 'In My List';
            showToast('success', 'Added', `${currentMovie.title} added to My List`, 2000);
          }
        }
      });
    }

    // Save watch progress
    function saveWatchProgress(movieId, progress, duration) {
      if (!movieId) return;

      const key = getContinueWatchingKey();
      const continueWatching = JSON.parse(localStorage.getItem(key) || '{}');

      // Only save if progress is between 1% and 95%
      if (progress > 1 && progress < 95) {
        const movie = continueWatching[movieId] || {};
        continueWatching[movieId] = {
          ...movie,
          movieId: movieId,
          progress: progress,
          timestamp: Date.now(),
          duration: duration
        };
        localStorage.setItem(key, JSON.stringify(continueWatching));

        // Update the UI if we're on the main page
        if (typeof loadContinueWatching === 'function') {
          loadContinueWatching();
        }
      } else if (progress >= 95) {
        // Remove if video is almost finished
        delete continueWatching[movieId];
        localStorage.setItem(key, JSON.stringify(continueWatching));
      }
    }

    // Initial load
    window.onload = function () {
      applyPerMovieUrls();
      // Ensure the category bar is visible immediately
      mountCategoryBar();
      displayMovies(curatedMovies, false);
      // loadContinueWatching is now called after auth/profile is confirmed to avoid flicker

      // Check if there's a movie ID in the URL to open modal
      const urlParams = new URLSearchParams(window.location.search);
      const movieId = urlParams.get('movie');
      if (movieId) {
        // Find the movie in the curatedMovies array
        const movie = curatedMovies.find(m => m.id === movieId);
        if (movie) {
          // Open modal after a short delay to ensure everything is loaded
          setTimeout(() => {
            openMovieModal(movie);
          }, 500);
        }
      }
    };

    // Home button: reset to full curated list
    (function wireHomeButton() {
      const homeBtn = document.getElementById('homeBtn');
      if (!homeBtn) return;

      homeBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        // Clear search input and any active search state
        searchInput.value = '';
        document.body.classList.remove('searching');
        isSearching = false;

        const searchTop = document.getElementById('searchTop');
        if (searchTop) {
          searchTop.classList.remove('active');
        }

        // Show popular movies section
        const popularSection = document.getElementById('popularMoviesSection');
        const popularTVSection = document.getElementById('popularTVSection');
        if (popularSection) popularSection.style.display = '';
        if (popularTVSection) popularTVSection.style.display = '';

        // Reset category filter and show TMDB movies
        try { currentCategory = 'all'; } catch (_) { }
        mountCategoryBar();
        
        // Load and display TMDB movies if available
        if (typeof loadAllTMDBMovies === 'function' && typeof displayMovies === 'function') {
          const tmdbMovies = await loadAllTMDBMovies(3);
          if (tmdbMovies.length > 0) {
            displayMovies(tmdbMovies, false, 'All Movies');
          } else {
            displayMovies([], false, 'All Movies');
          }
        } else {
          displayMovies([], false, 'All Movies');
        }

        // Ensure continue watching is shown
        const continueWatchingSection = document.getElementById('continueWatchingSection');
        if (continueWatchingSection) {
          continueWatchingSection.style.display = 'block';
        }
      });

      homeBtn.addEventListener('click', () => {
        // close modal if open
        if (modal && modal.style.display === 'flex') {
          closeModalBtn.click();
        }
        // clear search
        if (searchInput) {
          searchInput.value = '';
          searchInput.dispatchEvent(new Event('input'));
        }
        // Show popular movies section
        const popularSection = document.getElementById('popularMoviesSection');
        const popularTVSection = document.getElementById('popularTVSection');
        if (popularSection) popularSection.style.display = '';
        if (popularTVSection) popularTVSection.style.display = '';
        
        // reset movies and category filter
        try { currentCategory = 'all'; } catch (_) { }
        mountCategoryBar();
        displayMovies(curatedMovies);
        // smooth scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    })();

    // Keep search-top visually 'active' when input is focused or contains text
    (function wireSearchActiveState() {
      const searchTop = document.getElementById('searchTop');
      const searchInputEl = document.getElementById('searchInput');

      function updateActive() {
        if (!searchTop || !searchInputEl) return;
        if (document.activeElement === searchInputEl || (searchInputEl.value && searchInputEl.value.trim() !== '')) {
          searchTop.classList.add('active');
        } else {
          searchTop.classList.remove('active');
        }
      }

      // focus/blur/value events
      searchInputEl.addEventListener('focus', updateActive);
      searchInputEl.addEventListener('blur', () => { setTimeout(updateActive, 0); });
      searchInputEl.addEventListener('input', updateActive);

      // If user clicks the search button while the input is empty, focus it instead
      const searchButton = document.getElementById('searchBtn');
      if (searchButton && searchInputEl) {
        searchButton.addEventListener('click', (e) => {
          // allow existing click handler above to run; but if input is empty, focus first
          if (!searchInputEl.value || searchInputEl.value.trim() === '') {
            e.preventDefault();
            searchInputEl.focus();
          }
        }, { capture: true });
      }

      // initialize state
      updateActive();
    })();

    // Dark/Light mode removed â€“ site now uses saved Settings theme only
  </script>
  <!-- Firebase compat SDKs + App auth helpers -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="public/firebaseConfig.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
  <script src="public/emailConfig.js"></script>
  <script>
    if (window.emailjs && window.EMAILJS && window.EMAILJS.publicKey) {
      window.emailjs.init(window.EMAILJS.publicKey);
    }
  </script>
  <script src="auth-firebase.js?v=3"></script>
  <script src="firebase-sync.js"></script>
  <script src="storage-adapter.js"></script>
  <script src="ui.js"></script>
  <script>
    // Particle background functionality
    function createParticles() {
      const container = document.getElementById('particles');
      if (!container) return;

      // Clear existing particles
      container.innerHTML = '';

      // Get current theme colors
      const style = getComputedStyle(document.documentElement);
      const color1 = style.getPropertyValue('--particle-color-1').trim() || '#ff6b6b';
      const color2 = style.getPropertyValue('--particle-color-2').trim() || '#6b66ff';

      // Create 50-70 particles for a denser effect
      const particleCount = Math.floor(Math.random() * 21) + 50; // 50-70 particles

      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';

        // Slightly smaller size range for more particles (4-10px)
        const size = Math.random() * 6 + 4;

        // Random position
        const posX = Math.random() * 100;
        const posY = Math.random() * 100;

        // Random animation duration
        const duration = Math.random() * 20 + 10; // 10-30s
        const delay = Math.random() * -20; // Start at random times

        // Increased opacity for brighter particles
        const opacity = Math.random() * 0.4 + 0.4; // 0.4-0.8 (brighter range)

        // Randomly choose between the two theme colors with higher brightness
        const color = Math.random() > 0.5 ?
          color1.replace('rgb', 'rgba').replace(')', ', 0.8)') :
          color2.replace('rgb', 'rgba').replace(')', ', 0.8)');

        // Apply enhanced styles for brightness and glow
        Object.assign(particle.style, {
          width: `${size}px`,
          height: `${size}px`,
          left: `${posX}%`,
          top: `${posY}%`,
          animationDuration: `${duration}s`,
          animationDelay: `${delay}s`,
          opacity: opacity,
          background: `radial-gradient(circle at center, white 0%, ${color1} 50%, ${color2} 100%)`,
          boxShadow: `0 0 ${size * 4}px ${size}px ${color}`,
          filter: 'saturate(1.5) brightness(1.3)'
        });
        particle.style.animation = `float ${duration}s ${delay}s infinite ease-in-out`;

        container.appendChild(particle);
      }
    }

    // Stream Button Functionality
    document.addEventListener('click', function (e) {
      const streamButton = e.target.closest('.stream-button');
      if (!streamButton) return;

      // Create ripple effect
      const rect = streamButton.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const ripple = document.createElement('span');
      ripple.classList.add('ripple');
      ripple.style.left = x + 'px';
      ripple.style.top = y + 'px';

      // Remove any existing ripples
      const existingRipples = streamButton.querySelectorAll('.ripple');
      existingRipples.forEach(r => r.remove());

      streamButton.appendChild(ripple);

      // Remove ripple after animation completes
      setTimeout(() => {
        ripple.remove();
      }, 600);

      // Add temporary click effect
      streamButton.classList.add('clicked');
      setTimeout(() => {
        streamButton.classList.remove('clicked');
      }, 200);

      // Get the current movie from the modal
      const modal = document.getElementById('movieModal');
      if (modal && modal.style.display === 'flex') {
        var modalTitleElem = document.getElementById('modalTitle');
        if (modalTitleElem && modalTitleElem.textContent) {
          var movieTitle = modalTitleElem.textContent;
          // Request landscape orientation if in portrait mode
          function proceedToStream() {
            // Here you can add your streaming logic
            console.log('Streaming:', movieTitle);
            // Example: window.open('streaming-url-here', '_blank');
          }
          if (window.matchMedia('(orientation: portrait)').matches && screen.orientation && screen.orientation.lock) {
            var requestFs = document.documentElement.requestFullscreen ? document.documentElement.requestFullscreen() : Promise.resolve();
            requestFs.then(function () {
              return screen.orientation.lock('landscape');
            }).then(function () {
              proceedToStream();
            }).catch(function () {
              proceedToStream();
            });
          } else {
            proceedToStream();
          }
        }
      }
    });

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize theme
      const key = getScopedThemeKey();
      const savedTheme = localStorage.getItem(key) || 'glossy';
      applyTheme(savedTheme);

      // Set up theme change listeners
      setupThemeListener();

      // Initialize particles and handle window resize with debounce
      let resizeTimer;
      const handleResize = () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(createParticles, 250);
      };

      // Initial particle creation with theme colors
      createParticles();

      // Set up event listeners
      window.addEventListener('resize', handleResize);

      // Watch for theme changes via style attribute
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'style') {
            createParticles();
          }
        });
      });

      // Start observing the document for style changes
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['style']
      });
    });

    // Auth gate + profile + theme load
    FirebaseAuth.onAuthChanged(async (user) => {
      const menu = document.getElementById('appUserMenu');
      if (!user) { window.location.assign('/login.html'); return; }
      // Load selected profile or redirect to profiles page
      const prof = await FirebaseAuth.getSelectedProfile(user.uid);
      if (!prof) { window.location.assign('/profiles.html'); return; }
      
      // Initialize FirebaseSync with the confirmed profile
      if (window.FirebaseSync && typeof window.FirebaseSync.initializeForProfile === 'function') {
        await window.FirebaseSync.initializeForProfile();
      }
      
      // Populate mini user menu
      if (menu) menu.style.display = 'block';

      // Get all necessary elements
      const userNameElement = document.querySelector('.user-name');
      const userAvatar = document.getElementById('userAvatar');

      // Update username
      if (userNameElement) {
        userNameElement.textContent = prof.name || 'User';
      }

      // Update avatar
      if (userAvatar) {
        // Clear existing content
        userAvatar.innerHTML = '';

        // Apply background color if specified
        if (prof.color) {
          userAvatar.style.backgroundColor = prof.color;
          userAvatar.style.backgroundImage = 'none';
        }

        if (prof.avatarUrl) {
          // Show avatar image if available
          const img = document.createElement('img');
          img.id = 'userAvatarImg';
          img.src = prof.avatarUrl;
          img.alt = 'Profile';
          img.style.cssText = 'width:100%;height:100%;object-fit:cover;border-radius:inherit;';
          userAvatar.appendChild(img);
        } else {
          // Show initial if no avatar
          const initial = document.createElement('span');
          initial.id = 'userInitial';
          initial.textContent = (prof.name || '?').charAt(0).toUpperCase();
          initial.style.cssText = 'position:absolute;font-weight:600;font-size:14px;color:white;display:flex;align-items:center;justify-content:center;width:100%;height:100%;';
          userAvatar.appendChild(initial);
        }
      }

      // Log the profile data for debugging
      console.log('Profile data:', {
        name: prof.name,
        color: prof.color,
        hasAvatar: !!prof.avatarUrl,
        timestamp: new Date().toISOString()
      });

      // Log the applied styles for verification
      if (userAvatar) {
        setTimeout(() => {
          console.log('Avatar element after update:', {
            id: userAvatar.id,
            outerHTML: userAvatar.outerHTML,
            computedStyles: window.getComputedStyle(userAvatar)
          });
        }, 100);
      }

      // Resolve and apply profile-scoped theme
      try {
        const key = getScopedThemeKey();
        const local = localStorage.getItem(key);
        let theme = local;
        if (!theme) {
          // Try profile document field first, then user settings per-profile, then global
          theme = (prof && prof.theme) || null;
          if (!theme) {
            const s = await FirebaseAuth.getUserSettings(user.uid).catch(() => null);
            theme = (s && s.profiles && prof && s.profiles[prof.id] && s.profiles[prof.id].theme) || (s && s.theme) || null;
          }
        }
        applyTheme(theme || 'glossy');
      } catch (e) { }

      // Now that auth/profile are ready, render Continue Watching without flicker
      if (typeof loadContinueWatching === 'function') {
        loadContinueWatching(true);
      }

      // Wire dropdown with smooth animations
      const btn = document.getElementById('userMenuBtn');
      const dd = document.querySelector('.user-dropdown');
      let isAnimating = false;

      const closeDD = () => {
        if (!dd || isAnimating) return;
        isAnimating = true;

        // Start closing animation
        dd.classList.remove('visible');

        // Wait for animation to complete before hiding
        setTimeout(() => {
          dd.classList.remove('show');
          if (btn) btn.setAttribute('aria-expanded', 'false');
          isAnimating = false;
        }, 200);
      };

      const openDD = () => {
        if (!dd || isAnimating) return;
        isAnimating = true;

        // Show the dropdown first
        dd.classList.add('show');

        // Force reflow to ensure the element is in the render tree
        void dd.offsetHeight;

        // Position the dropdown
        const rect = btn.getBoundingClientRect();
        const screenWidth = window.innerWidth;

        // Responsive positioning based on screen size
        if (screenWidth <= 480) {
          // Mobile: align right edge with button
          dd.style.top = `${rect.bottom + 4}px`;
          dd.style.left = 'auto';
          dd.style.right = `${screenWidth - rect.right - 10}px`;
        } else if (screenWidth <= 768) {
          // Tablet: align right edge with button
          dd.style.top = `${rect.bottom + 4}px`;
          dd.style.left = 'auto';
          dd.style.right = `${screenWidth - rect.right - 20}px`;
        } else {
          // Desktop: align right edge with button, positioned below
          dd.style.top = `${rect.bottom + 4}px`;
          dd.style.left = 'auto';
          dd.style.right = `${screenWidth - rect.right - 20}px`;
        }

        // Show the dropdown
        dd.classList.add('show');
        btn.setAttribute('aria-expanded', 'true');

        // Force reflow to ensure the initial state is applied
        void dd.offsetHeight;

        // Start opening animation
        setTimeout(() => {
          dd.classList.add('visible');
          isAnimating = false;
        }, 10);
      };

      // Click handler with animation support
      if (btn && dd) {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (dd.classList.contains('show')) {
            closeDD();
          } else {
            openDD();
          }
        });

        // Close when clicking outside
        document.addEventListener('click', (e) => {
          if (!btn.contains(e.target) && !dd.contains(e.target)) {
            closeDD();
          }
        });

        // Close with Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && dd.classList.contains('show')) {
            closeDD();
          }
        });
      } else {
        if (!btn) console.warn('Dropdown button element not found');
        if (!dd) console.warn('Dropdown menu element not found');
      }

      // Keyboard support
      if (btn) {
        btn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            if (dd && dd.classList) {
              if (dd.classList.contains('show')) {
                closeDD();
              } else {
                openDD();
              }
            }
          } else if (e.key === 'Escape' && dd && dd.classList && dd.classList.contains('show')) {
            e.preventDefault();
            closeDD();
          }
        });
      }

      // Close when clicking outside
      document.addEventListener('click', (e) => {
        if (btn && dd && !btn.contains(e.target) && !dd.contains(e.target)) {
          closeDD();
        }
      });

      // Menu item click handlers with proper element IDs
      const settingsLink = document.getElementById('settingsLink');
      const switchProfileLink = document.querySelector('a[href="profiles.html"]');
      const signOutLink = document.getElementById('signOutLink');

      if (settingsLink) {
        settingsLink.addEventListener('click', (e) => {
          e.preventDefault();
          closeDD();
          window.location.href = 'settings.html';
        });
      } else {
        console.warn('Settings link element not found');
      }

      if (switchProfileLink) {
        switchProfileLink.addEventListener('click', (e) => {
          e.preventDefault();
          closeDD();
          window.location.href = 'profiles.html';
        });
      } else {
        console.warn('Switch profile link not found');
      }

      if (signOutLink) {
        signOutLink.addEventListener('click', async (e) => {
          e.preventDefault();
          closeDD();
          try {
            if (typeof FirebaseAuth !== 'undefined' && FirebaseAuth.signOut) {
              await FirebaseAuth.signOut();
            }
            window.location.href = 'login.html';
          } catch (error) {
            console.error('Error during sign out:', error);
            window.location.href = 'login.html';
          }
        });
      } else {
        console.warn('Sign out link not found');
      }
    });
  </script>

  <!-- Movie Database Integration -->
  <script src="js/movie-db.js"></script>
  <script src="js/tmdb-integration.js"></script>
  <script src="public/streamApiConfig.js?v=20260112"></script>
  <script src="js/consumet-api.js"></script>
  <script src="js/stream-api.js"></script>
  
  <!-- Enhanced Multi-Provider Streaming API with Multi-Language Support -->
  <script src="js/enhanced-stream-api.js?v=20260113-fixed"></script>
  <script src="js/audio-language-selector.js"></script>
  <script src="js/stream-player-handler.js"></script>
  
  <!-- Streaming Compatibility Layer - bridges old & new APIs -->
  <script src="js/stream-compatibility.js?v=20260113-fixed"></script>
  
  <!-- Stream Debug Helper -->
  <script src="js/stream-debug.js"></script>
  
  <!-- Ad-Blocker Proxy Integration -->
  <script src="js/ad-blocker-proxy-integration.js"></script>
  
  <script src="js/player-integration.js"></script>
  <script>
    // TMDB API Configuration - Add your free API key from https://www.themoviedb.org/settings/api
    const TMDB_API_KEY = 'f66d9d54a03e21f8ef99dd0c4258aa8a'; // Replace with your actual API key
    // YouTube Data API key for trailer fallback (optional but required for auto lookup)
    const YT_API_KEY = 'AIzaSyAZQSlyEUO5yMN0AGp94RVarUFxOlceuDM';
    let movieDb = null;

    // Check if there's a movie modal to restore from player back button
    (function restoreModalOnPageLoad() {
      try {
        const storedMovie = sessionStorage.getItem('currentModalMovie');
        const storedCategory = sessionStorage.getItem('currentModalCategory');
        const shouldRestore = sessionStorage.getItem('restoreModalOnLoad');
        
        if (storedMovie && shouldRestore === 'true') {
          const movie = JSON.parse(storedMovie);
          const categoryToRestore = storedCategory || 'all';
          sessionStorage.removeItem('restoreModalOnLoad');
          
          // Delay slightly to ensure DOM is ready
          setTimeout(() => {
            // Restore the category first, then open the modal
            if (categoryToRestore !== currentCategory) {
              applyCategory(categoryToRestore);
            }
            openMovieModal(movie);
          }, 100);
        }
      } catch (e) {
        console.warn('Failed to restore modal:', e);
      }
    })();

    // Initialize movie database
    function initMovieDb() {
      if (!TMDB_API_KEY || TMDB_API_KEY === 'YOUR_API_KEY_HERE') {
        console.warn('TMDB API key not configured. Movie database features will be limited.');
        return;
      }
      movieDb = new MovieDatabase(TMDB_API_KEY);
      // Expose to window for stream-api.js
      window.movieDb = movieDb;
      // Load trending movies and TV shows
      loadTrendingMovies();
      loadTrendingTV();
      // Start trending refresh with auto-updates every 5-15 minutes
      if (typeof startTrendingRefresh === 'function') {
        console.log('Starting trending refresh on page load...');
        startTrendingRefresh();
      }
      if (typeof initializeTMDBIntegration === 'function') {
        initializeTMDBIntegration();
      }
    }

    // Load and display trending movies from TMDB trending endpoint with rank badges
    async function loadTrendingMovies() {
      if (!movieDb) return;
      try {
        // Use getTrendingMovies if available (new method), fallback to getPopularMovies
        const getTrending = typeof movieDb.getTrendingMovies === 'function' ? movieDb.getTrendingMovies : movieDb.getPopularMovies;
        const result = await getTrending.call(movieDb, 1);
        const container = document.getElementById('trendingMoviesContainer');
        if (!container) return;
        container.innerHTML = '';

        const movies = (result && result.movies) ? result.movies.slice(0, 20) : [];
        
        if (movies.length === 0) {
          container.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">No trending movies available</p>';
          return;
        }

        movies.forEach((m, index) => {
          const title = m.title || 'Untitled';
          const posterPath = m.poster || (m.posterUrl || (m.poster_path ? `${movieDb.imageUrl}${m.poster_path}` : null)) || (`https://via.placeholder.com/500x750?text=${encodeURIComponent(title)}`);
          const year = m.releaseDate ? (m.releaseDate.split('-')[0]) : (m.year || '');
          const rating = m.rating || (typeof m.vote_average === 'number' ? m.vote_average : null);
          const rank = index + 1; // Trending rank badge

          const card = document.createElement('div');
          card.className = 'movie-card movie-' + (m.id || 'trending-' + index);
          card.innerHTML = `
            <div class="poster">
              <img src="${posterPath}" alt="${title}" loading="lazy" />
              <div class="rating-badge"><span class="star">â˜…</span><span class="value">${rating ? Number(rating).toFixed(1) : 'N/A'}</span></div>
              <div class="trending-rank-badge">#${rank}</div>
              <div class="play-icon"></div>
              <div class="movie-title-overlay">${title}</div>
            </div>
            <div class="movie-info">
              <h3 class="movie-title">${title} (${year || ''})</h3>
            </div>
          `;

          const img = card.querySelector('img');
          if (img) {
            img.addEventListener('error', () => {
              img.src = `https://via.placeholder.com/500x750?text=${encodeURIComponent(title)}`;
            });
          }

          card.addEventListener('click', async () => {
            const details = await getMovieDetailsDb(m.id);
            const mappedMovie = details ? {
              id: details.id,
              title: details.title,
              year: details.releaseDate ? details.releaseDate.split('-')[0] : '',
              genres: details.genres || [],
              rating: details.rating || 0,
              overview: details.overview || '',
              release_date: details.releaseDate || '',
              posterUrl: details.poster || null,
              backdropUrl: details.backdrop || null,
              trailerUrl: '',
              streamUrl: ''
            } : {
              id: m.id,
              title: title,
              year: year,
              genres: [],
              rating: rating || 0,
              overview: m.overview || '',
              release_date: m.releaseDate || '',
              posterUrl: posterPath,
              backdropUrl: m.backdrop || null,
              trailerUrl: '',
              streamUrl: ''
            };
            if (typeof openMovieModal === 'function') openMovieModal(mappedMovie);
          });

          container.appendChild(card);
        });
      } catch (error) {
        console.error('Failed to load trending movies:', error);
        const container = document.getElementById('trendingMoviesContainer');
        if (container) {
          container.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">Failed to load trending movies</p>';
        }
      }
    }

    // Load and display trending TV shows from TMDB trending endpoint with rank badges
    async function loadTrendingTV() {
      if (!movieDb) return;
      try {
        // Use getTrendingTV if available (new method), fallback to popular TV
        const getTrending = typeof movieDb.getTrendingTV === 'function' ? movieDb.getTrendingTV : movieDb.getPopularTV;
        const result = await getTrending.call(movieDb, 1);
        const container = document.getElementById('trendingTVContainer');
        if (!container) return;
        container.innerHTML = '';

        const shows = (result && result.movies) ? result.movies.slice(0, 20) : [];
        
        if (shows.length === 0) {
          container.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">No trending series available</p>';
          return;
        }

        shows.forEach((m, index) => {
          const title = m.title || 'Untitled';
          const posterPath = m.poster || (m.posterUrl || (m.poster_path ? `${movieDb.imageUrl}${m.poster_path}` : null)) || (`https://via.placeholder.com/500x750?text=${encodeURIComponent(title)}`);
          const year = m.releaseDate ? (m.releaseDate.split('-')[0]) : (m.year || '');
          const rating = m.rating || (typeof m.vote_average === 'number' ? m.vote_average : null);
          const rank = index + 1; // Trending rank badge

          const card = document.createElement('div');
          card.className = 'movie-card movie-' + (m.id || 'trending-tv-' + index);
          card.innerHTML = `
            <div class="poster">
              <img src="${posterPath}" alt="${title}" loading="lazy" />
              <div class="rating-badge"><span class="star">â˜…</span><span class="value">${rating ? Number(rating).toFixed(1) : 'N/A'}</span></div>
              <div class="trending-rank-badge">#${rank}</div>
              <div class="play-icon"></div>
              <div class="movie-title-overlay">${title}</div>
            </div>
            <div class="movie-info">
              <h3 class="movie-title">${title} (${year || ''})</h3>
            </div>
          `;

          const img = card.querySelector('img');
          if (img) {
            img.addEventListener('error', () => {
              img.src = `https://via.placeholder.com/500x750?text=${encodeURIComponent(title)}`;
            });
          }

          card.addEventListener('click', async () => {
            const details = await movieDb.getTVDetails(m.id);
            const mappedShow = details ? {
              id: details.id,
              title: details.title,
              year: details.releaseDate ? details.releaseDate.split('-')[0] : '',
              genres: details.genres || [],
              rating: details.rating || 0,
              overview: details.overview || '',
              release_date: details.releaseDate || '',
              posterUrl: details.poster || null,
              backdropUrl: details.backdrop || null,
              trailerUrl: '',
              streamUrl: '',
              mediaType: 'tv'
            } : {
              id: m.id,
              title: title,
              year: year,
              genres: [],
              rating: rating || 0,
              overview: m.overview || '',
              release_date: m.releaseDate || '',
              posterUrl: posterPath,
              backdropUrl: m.backdrop || null,
              trailerUrl: '',
              streamUrl: '',
              mediaType: 'tv'
            };
            if (typeof openMovieModal === 'function') openMovieModal(mappedShow);
          });

          container.appendChild(card);
        });
      } catch (error) {
        console.error('Failed to load trending TV shows:', error);
        const container = document.getElementById('trendingTVContainer');
        if (container) {
          container.innerHTML = '<p style="padding: 20px; text-align: center; color: #999;">Failed to load trending series</p>';
        }
      }
    }

    // Show movie details in modal
    function showMovieModal(movie) {
      const modal = document.getElementById('movieModal');
      const title = document.getElementById('modalTitle');
      const overview = document.getElementById('modalOverview');
      const genres = document.getElementById('modalGenres');
      const rating = document.getElementById('modalRating');
      const releaseDate = document.getElementById('modalReleaseDate');
      const trailerImg = document.getElementById('trailerPlaceholderImg');
      
      if (title) title.textContent = movie.title;
      if (overview) overview.textContent = movie.overview;
      if (genres) genres.textContent = movie.genres ? movie.genres.join(', ') : 'N/A';
      if (rating) rating.textContent = `${movie.rating.toFixed(1)}/10`;
      if (releaseDate) releaseDate.textContent = movie.releaseDate || 'N/A';
      if (trailerImg) trailerImg.src = movie.backdrop || movie.poster || '';
      
      if (modal) {
        modal.style.display = 'flex';
      }
    }

    // Search movies
    async function searchMoviesDb(query) {
      if (!movieDb || !query) return [];
      try {
        const results = await movieDb.searchMovies(query);
        return results.movies;
      } catch (error) {
        console.error('Search failed:', error);
        return [];
      }
    }

    // Get movie details
    async function getMovieDetailsDb(movieId) {
      if (!movieDb) return null;
      try {
        return await movieDb.getMovieDetails(movieId);
      } catch (error) {
        console.error('Failed to get movie details:', error);
        return null;
      }
    }

    // Initialize when page loads
    window.addEventListener('load', () => {
      initMovieDb();
    });
  </script>
  </script>

  <!-- Migration Helper - Disabled for now -->
  <!-- Can be enabled later when needed -->

  <!-- Initialize Continue Watching (removed duplicate inline UI; unified on loadContinueWatching) -->
</body>

</html>