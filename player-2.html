<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
    <title>Cinematic Hub Movies</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="css/subtitles.css">
    
    <!-- Firebase compat SDKs + Auth helpers for per-profile continue-watching scoping -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="public/firebaseConfig.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="auth-firebase.js?v=3"></script>
    <script src="firebase-sync.js"></script>
    <!-- hls.js for HLS (.m3u8) playback -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    
    <!-- Stream API Configuration and Client -->
    <script src="public/streamApiConfig.js"></script>
    <script src="js/stream-api.js"></script>
    
    <!-- Continue Watching and Player Resume scripts -->
    <script src="js/continue-watching.js"></script>
    <script src="js/player-continue-watching.js"></script>
    
    <!-- Initialize Continue Watching Tracking -->
    <script>
    (function() {
      'use strict';
      console.log('[Tracking] Initializing explicit video tracking for player-2...');

      // Wait for DOM and video element
      function initializeTracking() {
        // Player-2 uses 'videoPlayer' as the ID
        const video = document.getElementById('videoPlayer') || document.getElementById('video');
        if (!video) {
          console.warn('[Tracking] Video element not found, retrying...');
          setTimeout(initializeTracking, 100);
          return;
        }
        
        console.log('[Tracking] Video element found:', video.id);

        // Get movie data from URL
        const urlParams = new URLSearchParams(window.location.search);
        const movieId = urlParams.get('movieId') || urlParams.get('id') || `movie_${Date.now()}`;
        const title = urlParams.get('title') || 'Unknown Movie';
        const poster = urlParams.get('poster') || urlParams.get('thumbnail') || '';

        console.log('[Tracking] URL Parameters:', {
          movieId,
          title,
          poster: poster ? 'Yes - ' + poster.substring(0, 50) : 'No'
        });

        const movieData = {
          movieId: movieId,
          title: title,
          posterUrl: poster,
          thumbnail: poster,
          poster: poster
        };

        console.log('[Tracking] Movie data created:', {
          movieId: movieData.movieId,
          title: movieData.title,
          hasPoster: !!movieData.posterUrl,
          posterUrl: movieData.posterUrl ? movieData.posterUrl.substring(0, 50) : 'empty'
        });

        // Wait for ContinueWatchingManager
        function startTracking() {
          if (!window.ContinueWatchingManager) {
            console.warn('[Tracking] Manager not ready, waiting...');
            setTimeout(startTracking, 100);
            return;
          }

          console.log('[Tracking] ✅ ContinueWatchingManager found!');

          // Initialize tracking when video metadata loads
          const initOnReady = () => {
            if (video.readyState >= 1 && video.duration > 0) {
              console.log('[Tracking] ✅ Video ready, starting tracking');
              console.log('[Tracking] Duration:', video.duration, 'seconds');

              try {
                window.ContinueWatchingManager.initializeVideoTracking(video, movieData);
                console.log('[Tracking] ✅ Tracking initialized successfully');
              } catch (e) {
                console.error('[Tracking] ❌ Error initializing tracking:', e);
              }
            } else {
              console.log('[Tracking] Video not ready yet, waiting... (readyState:', video.readyState, ')');
            }
          };

          // Try now
          initOnReady();

          // Also listen for events
          video.addEventListener('loadedmetadata', () => {
            console.log('[Tracking] loadedmetadata event fired');
            initOnReady();
          }, { once: true });

          video.addEventListener('canplay', () => {
            console.log('[Tracking] canplay event fired');
            initOnReady();
          }, { once: true });

          // Force check after 2 seconds
          setTimeout(() => {
            console.log('[Tracking] Force check after 2s');
            initOnReady();
          }, 2000);
        }

        startTracking();
      }

      // Start initialization
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeTracking);
      } else {
        initializeTracking();
      }
    })();
    </script>
    <style>
        :root {
            --mx-primary: #1976d2;
            --mx-secondary: #2196f3;
            --mx-dark: #0d47a1;
            --mx-light: #bbdefb;
            --mx-black: #000000;
            --mx-white: #ffffff;
            --mx-gray: #424242;
            --mx-light-gray: #757575;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Force full screen coverage */
        html, body, .video-container, video {
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            outline: none !important;
            left: 0 !important;
            top: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100dvw !important;
            height: 100dvh !important;
            min-width: 100dvw !important;
            min-height: 100dvh !important;
            max-width: 100dvw !important;
            max-height: 100dvh !important;
        }

        html, body {
            margin: 0 !important;
            padding: 0 !important;
            width: 100dvw !important;
            height: 100dvh !important;
            overflow: hidden !important;
            background: #000 !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
        }

        body {
            font-family: 'Roboto', sans-serif;
            color: var(--mx-white);
            position: relative !important;
            display: block !important;
        }

        /* Video Container */
        .video-container {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            min-width: 100vw !important;
            min-height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            background: #000 !important;
            display: block !important;
            overflow: hidden !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            border-radius: 0 !important;
            transform: none !important;
        }

        video {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            min-width: 100vw !important;
            min-height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            object-fit: cover !important;
            object-position: center center !important;
            background: #000 !important;
            display: block !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            border-radius: 0 !important;
            z-index: 1 !important;
        }
        @media (orientation: landscape) {
            html, body {
                margin: 0 !important;
                padding: 0 !important;
                width: 100dvw !important;
                height: 100dvh !important;
                overflow: hidden !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
            }
            .video-container {
                width: 100dvw !important;
                height: 100dvh !important;
                max-width: 100dvw !important;
                max-height: 100dvh !important;
                margin: 0 !important;
                padding: 0 !important;
                border-radius: 0 !important;
                background: #000 !important;
                display: block !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                overflow: hidden !important;
            }
            video {
                width: 100dvw !important;
                height: 100dvh !important;
                max-width: 100dvw !important;
                max-height: 100dvh !important;
                object-fit: cover !important;
                object-position: center center !important;
                margin: 0 !important;
                border-radius: 0 !important;
                box-shadow: none !important;
                background: #000 !important;
                transform: none !important;
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                z-index: 1 !important;
            }
            .controls-overlay {
                z-index: 10 !important;
            }
        }
        /* Mobile-specific landscape mode fix */
        @media (orientation: landscape) and (max-width: 900px) {
            html, body {
                margin: 0 !important;
                padding: 0 !important;
                overflow: hidden !important;
                width: 100dvw !important;
                height: 100dvh !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
            }
            .video-container {
                width: 100dvw !important;
                height: 100dvh !important;
                max-width: 100dvw !important;
                max-height: 100dvh !important;
                margin: 0 !important;
                padding: 0 !important;
                border-radius: 0 !important;
                background: #000 !important;
                display: block !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                overflow: hidden !important;
                transform: translateZ(0) !important;
                z-index: 0 !important;
            }
            video {
                width: 100dvw !important;
                height: 100dvh !important;
                max-width: 100dvw !important;
                max-height: 100dvh !important;
                object-fit: cover !important;
                object-position: center center !important;
                margin: 0 !important;
                border-radius: 0 !important;
                box-shadow: none !important;
                background: #000 !important;
                transform: none !important;
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                z-index: 1 !important;
            }
            .controls-overlay {
                z-index: 10 !important;
            }
        }

        video:fullscreen, video:-webkit-full-screen {
            object-fit: cover;
            width: 100vw !important;
            height: 100vh !important;
            background: #000 !important;
            left: 0 !important;
        }

        /* MX Player Style Controls */
        .controls-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 20%, transparent 80%, rgba(0,0,0,0.7) 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 10 !important;
        }

        .controls-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        /* Top Controls */
        .top-controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .back-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: var(--mx-white);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .video-title {
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            flex: 1;
            margin: 0 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .top-right-controls {
            display: flex;
            gap: 10px;
        }

        .control-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: var(--mx-white);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Bottom Controls */
        .bottom-controls {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 20px;
            z-index: 20;
        }

        @media (max-width: 600px) and (orientation: portrait) {
            .video-container {
                height: 100vh;
                min-height: 100vh;
                max-height: 100vh;
            }
            .controls-overlay {
                padding-bottom: 0;
                justify-content: flex-end;
            }
            .bottom-controls {
                padding: 0 0 env(safe-area-inset-bottom,8px) 0;
                bottom: 0;
                position: fixed;
                left: 0;
                right: 0;
                z-index: 30;
                background: linear-gradient(to top, rgba(0,0,0,0.7) 60%, transparent 100%);
                width: 100vw;
                box-sizing: border-box;
            }
            .progress-container {
                margin-bottom: 2px;
            }
            .time-display {
                margin-bottom: 2px;
                font-size: 13px;
            }
            .main-controls {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                gap: 0;
                width: 100%;
                min-width: 0;
                overflow-x: auto;
            }
            .left-controls, .right-controls {
                gap: 4px;
                min-width: 0;
            }
            .right-controls {
                justify-content: flex-end;
                flex-shrink: 0;
            }
            .play-pause-btn {
                width: 44px;
                height: 44px;
                font-size: 22px;
                min-width: 44px;
                min-height: 44px;
            }
            .control-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
                min-width: 36px;
                min-height: 36px;
            }
            .volume-slider {
                width: 50px;
                min-width: 40px;
            }
            .right-controls button:last-child {
                margin-right: 4px;
            }
            .main-controls > * {
                min-width: 0;
            }
        }

        .progress-container {
            margin-bottom: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .progress-filled {
            height: 100%;
            background: var(--mx-primary);
            border-radius: 2px;
            width: 0%;
            transition: width 0.1s linear;
            position: relative;
        }

        .progress-thumb {
            position: absolute;
            top: 50%;
            right: -8px;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            background: var(--mx-primary);
            border: 2px solid var(--mx-white);
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .progress-bar:hover .progress-thumb,
        .controls-overlay.visible .progress-thumb {
            opacity: 1;
        }

        .progress-buffered {
            height: 100%;
            background: rgba(255,255,255,0.5);
            border-radius: 2px;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Video Thumbnail Preview */
        .thumbnail-preview {
            position: absolute;
            bottom: 25px;
            left: 0;
            transform: translateX(-50%);
            display: none;
            pointer-events: none;
            z-index: 10000;
            width: 160px;
            height: auto;
        }

        .thumbnail-preview.visible {
            display: block;
        }

        .thumbnail-preview canvas {
            display: block;
            width: 160px !important;
            height: 90px !important;
            border: 3px solid var(--mx-white);
            border-radius: 6px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.9);
            background: #000;
        }

        .thumbnail-preview .thumbnail-time {
            display: block;
            margin-top: 5px;
            text-align: center;
            background: rgba(0,0,0,0.95);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 12px;
            color: var(--mx-white);
        }

        .main-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .left-controls, .right-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .screen-mode-container {
            display: inline-flex;
            gap: 4px;
            align-items: center;
            margin-right: 8px;
        }

        .play-pause-btn {
            background: var(--mx-primary);
            border: none;
            color: var(--mx-white);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
        }

        .play-pause-btn:hover {
            background: var(--mx-secondary);
        }

        .volume-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .volume-filled {
            height: 100%;
            background: var(--mx-primary);
            border-radius: 2px;
            transition: width 0.1s ease;
        }

        .volume-thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: var(--mx-primary);
            border: 2px solid var(--mx-white);
            border-radius: 50%;
            cursor: grab;
            opacity: 1;
            transition: opacity 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .volume-thumb:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .volume-thumb.dragging {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.3);
        }

        .volume-slider:hover .volume-thumb {
            opacity: 1;
        }

        /* Gesture Indicators */
        .gesture-indicator {
            position: absolute;
            top: 80%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: var(--mx-white);
            padding: 20px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .gesture-indicator.visible {
            opacity: 1;
        }

        /* Loading Spinner */
        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid var(--mx-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }

        .loading-spinner.active {
            display: block;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Floating lock button shown while locked */
        .lock-floating-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 3000;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.45);
        }

        .lock-floating-btn.is-hidden {
            display: none;
        }

        .lock-floating-btn i {
            pointer-events: none;
            font-size: 18px;
        }

        /* Hide native browser subtitles (only show custom container) */
        video::cue {
            opacity: 0 !important;
            visibility: hidden !important;
            display: none !important;
        }

        /* Subtitle Container */
        /* Subtitle vertical offsets: adjust bottoms to move captions */
        .subtitle-container {
            position: fixed !important;
            bottom: 60px !important; /* non-fullscreen offset */
            left: 50% !important;
            transform: translateX(-50%) !important;
            width: auto !important;
            max-width: 75% !important;
            text-align: center !important;
            pointer-events: none !important;
            z-index: 2147483647 !important; /* Max z-index to ensure visibility */
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            filter: none;
        }

        /* Fullscreen subtitle positioning */
        :fullscreen .subtitle-container,
        :-webkit-full-screen .subtitle-container {
            position: fixed !important;
            bottom: 15px !important; /* fullscreen offset */
            left: 50% !important;
            transform: translateX(-50%) !important;
            z-index: 2147483647 !important;
            max-width: 85% !important;
        }

        .subtitle {
            display: inline-block;
            background: transparent;
            color: #ffffff;
            padding: 4px 8px;
            border-radius: 0;
            font-size: 22px;
            font-weight: 700;
            line-height: 1.4;
            letter-spacing: 0.2px;
            text-shadow: 
                0 0 8px rgba(0, 0, 0, 1),
                0 0 12px rgba(0, 0, 0, 1),
                2px 2px 4px rgba(0, 0, 0, 0.9),
                -2px -2px 4px rgba(0, 0, 0, 0.9),
                2px -2px 4px rgba(0, 0, 0, 0.9),
                -2px 2px 4px rgba(0, 0, 0, 0.9),
                0 2px 8px rgba(0, 0, 0, 0.95);
            margin: 4px;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            animation: subtitleFadeIn 0.3s ease-out;
            word-spacing: 0.05em;
            max-width: 80%;
        }
        
        @keyframes subtitleFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Subtitle hover effect for multiple lines */
        .subtitle + .subtitle {
            margin-top: 8px;
        }

        /* Ensure subtitle container is visible */
        .subtitle-container:empty::before {
            content: "";
            display: block;
            height: 1px;
        }

        /* Mobile subtitle adjustments */
        @media (max-width: 768px) {
            .subtitle-container {
                bottom: 50px !important; /* mobile offset */
                max-width: 85% !important;
            }
            
            .subtitle {
                font-size: 18px;
                padding: 3px 6px;
            }
            
            :fullscreen .subtitle-container,
            :-webkit-full-screen .subtitle-container {
                bottom: 15px !important; /* fullscreen mobile offset */
            }
        }
        
        /* Landscape mode adjustments */
        @media (orientation: landscape) {
            .subtitle-container {
                bottom: 15px !important; /* landscape offset */
            }
            
            .subtitle {
                font-size: 20px;
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .video-title {
                font-size: 14px;
                margin: 0 10px;
            }
            
            .volume-slider {
                width: 60px;
            }
            
            .control-btn, .back-btn {
                width: 35px;
                height: 35px;
            }
            
            .play-pause-btn {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
        }

        /* Tap Overlay Styles */
        .tap-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            pointer-events: none;
            z-index: 200;
            background: none !important;
            -webkit-tap-highlight-color: transparent;
        }

        .tap-overlay.visible {
            display: flex;
        }

        .tap-zone {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tap-indicator {
            pointer-events: all;
            cursor: pointer;
            background: transparent;
            color: white;
            padding: 15px 20px;
            border-radius: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s ease;
        }

        .tap-overlay.visible .tap-indicator {
            opacity: 1;
            transform: scale(1);
        }

        .tap-indicator i {
            font-size: 32px;
            margin-bottom: 2px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .tap-indicator span {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .center-zone .tap-indicator {
            background: transparent;
            padding: 20px 25px;
        }

        .center-zone .tap-indicator i {
            font-size: 40px;
        }

        /* Gesture Feedback Styles */
        .gesture-feedback {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            white-space: nowrap;
            z-index: 300;
        }

        .gesture-feedback.visible {
            opacity: 1;
            bottom: -50px;
        }

        .left-feedback {
            background: rgba(244, 67, 54, 0.9);
        }

        .center-feedback {
            background: var(--mx-primary);
        }

        .right-feedback {
            background: rgba(76, 175, 80, 0.9);
        }
                /* Subtitle offsets (secondary block, tweak as needed) */
                .subtitle-container {
                    position: fixed;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 90%;
                    max-width: 800px;
                    text-align: center;
                    pointer-events: none;
                    z-index: 5000; /* Always above overlays and controls */
                    display: block !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    border-radius: 8px;
                    bottom: 60px; /* non-fullscreen offset */
                }

                /* Only apply dynamic positioning in fullscreen */
                video:fullscreen ~ .subtitle-container,
                video:-webkit-full-screen ~ .subtitle-container {
                    bottom: 10px !important; /* fullscreen offset */
                }
                video:fullscreen ~ .subtitle-container.mode-stretch,
                video:-webkit-full-screen ~ .subtitle-container.mode-stretch {
                    bottom: 10px !important; /* fullscreen stretch offset */
                }
                video:fullscreen ~ .subtitle-container.mode-contain,
                video:-webkit-full-screen ~ .subtitle-container.mode-contain {
                    bottom: 10px !important; /* fullscreen contain offset */
                }
                @media (orientation: landscape) {
                    video:fullscreen ~ .subtitle-container,
                    video:-webkit-full-screen ~ .subtitle-container {
                        bottom: 10px !important; /* fullscreen landscape offset */
                    }
                }

                .video-subtitles {
                    position: fixed;
                    left: 50%;
                    bottom: 50px;
                    transform: translateX(-50%);
                    max-width: 90%;
                    font-size: 22.5px;
                    font-weight: bold;
                    color: white;
                    padding: 10px 20px;
                    text-align: center;
                    line-height: 1.4;
                    white-space: pre-line;
                    word-break: break-word;
                    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8), 
                                             -1px -1px 3px rgba(0, 0, 0, 0.8),
                                                1px -1px 3px rgba(0, 0, 0, 0.8),
                                             -1px 1px 3px rgba(0, 0, 0, 0.8);
                    -webkit-text-stroke: 0.5px rgba(0, 0, 0, 0.7);
                    font-family: Arial, sans-serif;
                    pointer-events: none;
                    z-index: 9999;
                    background-color: rgba(0, 0, 0, 0.1);
                    border-radius: 8px;
                    backdrop-filter: blur(2px);
                    opacity: 1 !important;
                    display: block !important;
                    transition: opacity 0.2s ease, transform 0.2s ease, bottom 0.2s ease;
                    will-change: transform, opacity, bottom;
                    box-sizing: border-box;
                }

                .video-subtitles.mode-cover {
                    bottom: 10%;
                }
                .video-subtitles.mode-stretch {
                    bottom: 10%;
                }
                .video-subtitles.mode-contain {
                    bottom: 30px;
                }
                @media (orientation: landscape) {
                    .video-subtitles {
                        bottom: 10% !important;
                        font-size: 20px;
                    }
                }
    </style>
</head>
<body>
        <script>
            try {
                localStorage.setItem('lastPlayerUsed', 'player2');
            } catch (_) {}
        </script>
        <style>
            /* Keep subtitles visible whenever CC is on, regardless of control auto-hide */
            body.subtitles-on #subtitleContainer,
            body.subtitles-on #subtitleContainer * {
                display: block !important;
                opacity: 1 !important;
                visibility: visible !important;
                pointer-events: none !important;
                z-index: 2147483647 !important;
                position: fixed !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                bottom: 60px !important; /* adjust CC-on offset */
                animation: none !important;
                transition: none !important;
            }
            
            body.subtitles-on #subtitleContainer * {
                position: relative !important;
            }
            
            /* Force subtitles to always be on top and never inherit parent opacity */
            #subtitleContainer {
                isolation: isolate !important;
                will-change: auto !important;
            }
            
            /* Prevent controls overlay from affecting subtitle container */
            .controls-overlay ~ #subtitleContainer {
                display: block !important;
                opacity: 1 !important;
            }
        </style>
    <div class="video-container">
        <video id="videoPlayer" preload="metadata" autoplay></video>
        
        <!-- Loading Spinner -->
        <div class="loading-spinner" id="loadingSpinner"></div>
        
        <!-- Gesture Indicator -->
        <div class="gesture-indicator" id="gestureIndicator"></div>
        
        <!-- Controls Overlay -->
        <div class="controls-overlay" id="controlsOverlay">
            <!-- Top Controls -->
            <div class="top-controls">
                <button class="back-btn" onclick="goBack()">
                    <i class="fa-solid fa-house"></i>
                </button>
                <div class="video-title" id="videoTitle">Loading...</div>
                <div class="top-right-controls">
                    <button class="control-btn" onclick="toggleSubtitle()" title="Toggle Subtitles">
                        <i class="fas fa-closed-captioning"></i>
                    </button>
                    <button class="control-btn" id="lockButton" onclick="toggleLock()" title="Lock/Unlock Controls">
                        <i class="fas fa-lock" id="lockIcon"></i>
                    </button>
                    <!-- Provider: NontonGo (Player 2 fixed) -->
                    <div style="position:relative; display:inline-block; margin-left:10px;">
                      <div style="font-size:13px; color:#fff; padding:6px 10px; background:rgba(30,30,30,0.5); border-radius:6px;">Provider: <strong>NontonGo</strong></div>
                    </div>
                </div>
            </div>
            
            <!-- Bottom Controls -->
            <div class="bottom-controls">
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar">
                        <div class="progress-buffered" id="progressBuffered"></div>
                        <div class="progress-filled" id="progressFilled">
                            <div class="progress-thumb"></div>
                        </div>
                        <div class="thumbnail-preview" id="thumbnailPreview">
                            <canvas id="thumbnailCanvas"></canvas>
                            <div class="thumbnail-time" id="thumbnailTime">00:00</div>
                        </div>
                    </div>
                </div>
                
                <div class="time-display">
                    <span id="currentTime">00:00</span>
                    <span id="duration">00:00</span>
                </div>
                
                <div class="main-controls">
                    <div class="left-controls">
                        <button class="control-btn" onclick="togglePlayback(-10)" title="Rewind 10s">
                            <i class="fas fa-rotate-left"></i>
                        </button>
                        <button class="play-pause-btn" id="playPauseBtn" onclick="togglePlayPause()" title="Play/Pause">
                            <i class="fas fa-play"></i>
                        </button>
                        <button class="control-btn" onclick="togglePlayback(10)" title="Forward 10s">
                            <i class="fas fa-rotate-right"></i>
                        </button>
                    </div>
                    
                    <div class="right-controls">
                        <div class="screen-mode-container" style="display:inline-flex;gap:4px;align-items:center;margin-right:8px;">
                            <button class="control-btn" id="screenModeToggle" data-tooltip="Stretch" title="Stretch">
                                <i class="fas fa-expand-arrows-alt" id="screenModeIcon"></i>
                            </button>
                        </div>
                        <div class="volume-container">
                            <button class="control-btn" onclick="toggleMute()" title="Mute/Unmute">
                                <i class="fas fa-volume-up" id="volumeIcon"></i>
                            </button>
                            <div class="volume-slider" id="volumeSlider" title="Volume">
                                <div class="volume-filled" id="volumeFilled"></div>
                                <div class="volume-thumb" id="volumeThumb"></div>
                            </div>
                        </div>
                        <button class="control-btn" id="languageBtn" data-tooltip="Audio Language" style="display:none;" title="Audio Language">
                            <i class="fas fa-language"></i>
                        </button>
                        <button class="control-btn" id="qualityBtn" data-tooltip="Quality" style="display:none;" title="Quality">
                            <i class="fas fa-cog"></i>
                        </button>
                        <button class="control-btn" onclick="toggleFullscreen()" title="Fullscreen">
                            <i class="fas fa-expand"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Floating unlock button (visible only when locked) -->
        <button class="lock-floating-btn is-hidden" id="lockFloatingButton" onclick="toggleLock()" title="Unlock Controls">
            <i class="fas fa-lock-open"></i>
        </button>
        
        <!-- Tap Overlay for Controls -->
        <div class="tap-overlay" id="tapOverlay">
            <div class="tap-zone left-zone" data-action="rewind">
                <div class="tap-indicator" onclick="handleTapZoneClick('rewind')">
                    <i class="fas fa-rotate-left"></i>
                    <span>-10s</span>
                </div>
                <div class="gesture-feedback left-feedback" id="leftFeedback">-10s</div>
            </div>
            <div class="tap-zone center-zone" data-action="playpause">
                <div class="tap-indicator" onclick="handleTapZoneClick('playpause')">
                    <i class="fas fa-play" id="centerPlayIcon"></i>
                    <span id="centerPlayText">Play</span>
                </div>
                <div class="gesture-feedback center-feedback" id="centerFeedback">Play/Pause</div>
            </div>
            <div class="tap-zone right-zone" data-action="forward">
                <div class="tap-indicator" onclick="handleTapZoneClick('forward')">
                    <i class="fas fa-rotate-right"></i>
                    <span>+10s</span>
                </div>
                <div class="gesture-feedback right-feedback" id="rightFeedback">+10s</div>
            </div>
        </div>
    </div>
    
    <!-- Subtitle Container (Outside video-container to avoid inheritance) -->
    <div class="subtitle-container" id="subtitleContainer"></div>

    <!-- Language Selection Menu -->
    <div id="languageMenu" style="display: none; position: fixed; background: rgba(30, 32, 36, 0.95); border-radius: 12px; padding: 15px; min-width: 150px; z-index: 999999; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
        <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
            <i class="fas fa-language"></i>
            <span>Audio Language</span>
        </div>
        <div id="languageOptions">
            <!-- Language options will be populated dynamically -->
        </div>
    </div>

    <!-- Quality Selection Menu -->
    <div id="qualityMenu" style="display: none; position: fixed; background: rgba(30, 32, 36, 0.95); border-radius: 12px; padding: 15px; min-width: 150px; z-index: 999999; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
        <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
            <i class="fas fa-cog"></i>
            <span>Quality</span>
        </div>
        <div id="qualityOptions">
            <!-- Quality options will be populated dynamically -->
        </div>
    </div>

    <script>

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const title = urlParams.get('title') || 'Unknown Movie';

        // Dev helper (safe no-op if not provided by other debug tooling)
        if (typeof window.appendDev !== 'function') {
            window.appendDev = function(msg, level){
                try { if (level === 'warn') console.warn('[DEV]', msg); else if (level === 'error') console.error('[DEV]', msg); else console.log('[DEV]', msg); } catch(e) {}
            };
        }
        const year = urlParams.get('year') || '';
        const movieId = urlParams.get('movieId') || '';

        // Video elements
        const video = document.getElementById('videoPlayer');
        const videoTitle = document.getElementById('videoTitle');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const progressBar = document.getElementById('progressBar');
        const progressFilled = document.getElementById('progressFilled');
        const progressBuffered = document.getElementById('progressBuffered');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeFilled = document.getElementById('volumeFilled');
        const volumeIcon = document.getElementById('volumeIcon');
        const controlsOverlay = document.getElementById('controlsOverlay');
        const tapOverlay = document.getElementById('tapOverlay');
        const gestureIndicator = document.getElementById('gestureIndicator');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const subtitleContainer = document.getElementById('subtitleContainer');
        const lockButton = document.getElementById('lockButton');
        const lockIcon = document.getElementById('lockIcon');
        const lockFloatingButton = document.getElementById('lockFloatingButton');
        const thumbnailPreview = document.getElementById('thumbnailPreview');
        const thumbnailCanvas = document.getElementById('thumbnailCanvas');
        const thumbnailTime = document.getElementById('thumbnailTime');
        const thumbnailCtx = thumbnailCanvas.getContext('2d');
        const centerPlayIcon = document.getElementById('centerPlayIcon');
        const centerPlayText = document.getElementById('centerPlayText');

        // Set canvas size
        thumbnailCanvas.width = 160;
        thumbnailCanvas.height = 90;

        // Variables
        let isPlaying = false;
        let isDragging = false;
        let isLocked = false;
        let isVolumeGesturing = false;
        let isBrightnessGesturing = false;
        let isSeeking = false;
        let subtitlesEnabled = false;
        let playbackSpeed = 1;
        let currentBrightness = 1;
        let initialBrightness = 1;
        let initialVolume = 1;
        let isMuted = false;
        let tapOverlayVisible = false;
        let controlsTimeout;
        let longPressTimer;
        let doubleTapTimer;
        let gestureIndicatorTimeout;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let gestureStartX = 0;
        let gestureStartY = 0;
        let lastTapTime = 0;
        let tapCount = 0;

        // Screen mode global variables
        let screenModeBtn, screenModeIcon;
        const modes = [
            { fit: 'cover', icon: 'fa-expand-arrows-alt', label: 'Cover' },
            { fit: 'fill', icon: 'fa-arrows-alt-h', label: 'Stretch' },
            { fit: 'contain', icon: 'fa-compress', label: 'Contain' }
        ];
        let currentScreenMode = 2; // Start with "Contain" mode (index 2)

        // Set video title
        videoTitle.textContent = title;

        // Get video source
        let videoSrc = urlParams.get('src') || urlParams.get('video') || '';
        let sourceType = urlParams.get('type') || 'mp4';

        // Auto-load NontonGo embed on Player 2 - simplified flow (NontonGo only)
        (function initNontonGoAuto(){
            try {
                const tmdbId = urlParams.get('movieId') || urlParams.get('tmdbId') || urlParams.get('id');
                const mediaType = urlParams.get('mediaType') || ((urlParams.get('season') && urlParams.get('episode')) ? 'tv' : 'movie');
                const season = urlParams.get('season');
                const episode = urlParams.get('episode');
                if (tmdbId) {
                    // Delay slightly to allow UI to initialize
                    setTimeout(()=>{
                        try { openNontonGoEmbed(tmdbId, mediaType, season, episode); } catch(e){ console.warn('openNontonGoEmbed failed', e); }
                    }, 200);
                } else {
                    console.warn('initNontonGoAuto: No TMDB ID present, waiting for manual invocation');
                }
            } catch (e) { console.warn('initNontonGoAuto failed', e); }
        })();

        // Check movie database for the video source
        const normalizedTitle = title.toLowerCase().trim();
        // Ensure movieDatabase exists (can be populated from elsewhere)
        const movieDatabase = window.movieDatabase || {};
        console.log('Looking for movie:', normalizedTitle);
        console.log('Available movies:', Object.keys(movieDatabase));
        
        if (!videoSrc && movieDatabase[normalizedTitle]) {
            const movieData = movieDatabase[normalizedTitle];
            videoSrc = movieData.src;
            sourceType = movieData.type;
            console.log('Found movie data:', movieData);
            console.log('Movie has subtitles:', !!movieData.subtitles);
        } else {
            console.log('Movie not found in database, using URL parameters');
        }

        // Initialize screen mode functionality
        function initScreenMode() {
            console.log('initScreenMode() called');
            screenModeBtn = document.getElementById('screenModeToggle');
            screenModeIcon = document.getElementById('screenModeIcon');
            
            console.log('screenModeBtn:', screenModeBtn);
            console.log('screenModeIcon:', screenModeIcon);
            console.log('video element:', video);
            
            if (!screenModeBtn || !screenModeIcon) {
                console.warn('Screen mode elements not found');
                return;
            }

            // Screen mode function
            function updateScreenMode() {
                console.log('updateScreenMode() called, currentScreenMode:', currentScreenMode);
                console.log('Setting object-fit to:', modes[currentScreenMode].fit);
                
                // Force video to fill entire screen aggressively
                video.style.setProperty('object-fit', modes[currentScreenMode].fit, 'important');
                video.style.setProperty('position', 'fixed', 'important');
                video.style.setProperty('top', '0', 'important');
                video.style.setProperty('left', '0', 'important');
                video.style.setProperty('right', '0', 'important');
                video.style.setProperty('bottom', '0', 'important');
                video.style.setProperty('width', '100vw', 'important');
                video.style.setProperty('height', '100vh', 'important');
                video.style.setProperty('min-width', '100vw', 'important');
                video.style.setProperty('min-height', '100vh', 'important');
                video.style.setProperty('max-width', '100vw', 'important');
                video.style.setProperty('max-height', '100vh', 'important');
                video.style.setProperty('margin', '0', 'important');
                video.style.setProperty('padding', '0', 'important');
                video.style.setProperty('border', 'none', 'important');
                video.style.setProperty('transform', 'none', 'important');
                
                screenModeIcon.className = 'fas ' + modes[currentScreenMode].icon;
                screenModeBtn.setAttribute('data-tooltip', modes[currentScreenMode].label);
                screenModeBtn.setAttribute('title', modes[currentScreenMode].label);
                console.log('Screen mode changed to:', modes[currentScreenMode].label, 'object-fit:', modes[currentScreenMode].fit);
                console.log('Current video style.objectFit:', video.style.objectFit);
                
                // Force a reflow to ensure styles are applied
                video.offsetHeight;
                
                // Additional force - remove any conflicting styles
                setTimeout(() => {
                    video.style.setProperty('left', '0', 'important');
                    video.style.setProperty('width', '100vw', 'important');
                    video.offsetHeight;
                }, 10);
            }

            // Add screen mode event listener
            screenModeBtn.addEventListener('click', function (e) {
                console.log('Screen mode button clicked! Event:', e);
                console.log('Button element:', screenModeBtn);
                console.log('Current mode before:', currentScreenMode);
                currentScreenMode = (currentScreenMode + 1) % modes.length;
                console.log('Current mode after:', currentScreenMode);
                updateScreenMode();
                
                // Force preserve screen mode immediately
                setTimeout(preserveScreenMode, 10);
            });

            // Also add mousedown event as backup
            screenModeBtn.addEventListener('mousedown', function (e) {
                console.log('Screen mode button mousedown!');
            });

            // Also add touchstart for mobile
            screenModeBtn.addEventListener('touchstart', function (e) {
                console.log('Screen mode button touchstart!');
            });

            // Initialize with default mode
            updateScreenMode();
            console.log('Screen mode initialized');
        }

        // Function to preserve screen mode (call this after video operations)
        function preserveScreenMode() {
            if (screenModeBtn && screenModeIcon && video) {
                // Force video to fill entire screen aggressively
                video.style.setProperty('object-fit', modes[currentScreenMode].fit, 'important');
                video.style.setProperty('position', 'fixed', 'important');
                video.style.setProperty('top', '0', 'important');
                video.style.setProperty('left', '0', 'important');
                video.style.setProperty('right', '0', 'important');
                video.style.setProperty('bottom', '0', 'important');
                video.style.setProperty('width', '100vw', 'important');
                video.style.setProperty('height', '100vh', 'important');
                video.style.setProperty('min-width', '100vw', 'important');
                video.style.setProperty('min-height', '100vh', 'important');
                video.style.setProperty('max-width', '100vw', 'important');
                video.style.setProperty('max-height', '100vh', 'important');
                video.style.setProperty('margin', '0', 'important');
                video.style.setProperty('padding', '0', 'important');
                video.style.setProperty('border', 'none', 'important');
                video.style.setProperty('transform', 'none', 'important');
                
                screenModeIcon.className = 'fas ' + modes[currentScreenMode].icon;
                screenModeBtn.setAttribute('data-tooltip', modes[currentScreenMode].label);
                screenModeBtn.setAttribute('title', modes[currentScreenMode].label);
                console.log('Screen mode preserved:', modes[currentScreenMode].label);
                
                // Force a reflow to ensure styles are applied
                video.offsetHeight;
                
                // Additional force - remove any conflicting styles
                setTimeout(() => {
                    video.style.setProperty('left', '0', 'important');
                    video.style.setProperty('width', '100vw', 'important');
                    video.offsetHeight;
                }, 10);
            }
        }

        // Force video to fill entire screen
        function forceVideoFullScreen() {
            console.log('Forcing video to full screen');
            
            // Force video container to fill screen
            const container = document.querySelector('.video-container');
            if (container) {
                container.style.cssText = 'position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; width: 100vw !important; height: 100vh !important; min-width: 100vw !important; min-height: 100vh !important; max-width: 100vw !important; max-height: 100vh !important; margin: 0 !important; padding: 0 !important; border: none !important; border-radius: 0 !important; background: #000 !important; overflow: hidden !important; transform: none !important;';
            }
            
            // Force video to fill screen
            var currentFit = modes[currentScreenMode].fit;
            video.style.cssText = 'position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; width: 100vw !important; height: 100vh !important; min-width: 100vw !important; min-height: 100vh !important; max-width: 100vw !important; max-height: 100vh !important; margin: 0 !important; padding: 0 !important; border: none !important; border-radius: 0 !important; background: #000 !important; object-fit: ' + currentFit + ' !important; object-position: center center !important; transform: none !important;';
            
            // Force reflow
            video.offsetHeight;
        }

        // Initialize video
        async function initVideo() {
            if (videoSrc) {
                // Remove any existing <track> elements
                const oldTracks = video.querySelectorAll('track');
                oldTracks.forEach(track => track.remove());

                // Decide playback method based on sourceType or URL
                const isHls = (String(sourceType).toLowerCase() === 'hls') || /\.m3u8(\?.*)?$/.test(videoSrc);
                video.crossOrigin = 'anonymous';

                if (isHls) {
                    console.log('📺 Initializing HLS playback (player-2)...');
                    if (window.Hls && Hls.isSupported()) {
                        const hls = new Hls({
                            maxBufferLength: 30,
                            maxMaxBufferLength: 60,
                            lowLatencyMode: true
                        });
                        hls.loadSource(videoSrc);
                        hls.attachMedia(video);
                        hls.on(Hls.Events.MANIFEST_PARSED, function () {
                            console.log('✓ HLS manifest parsed successfully (player-2)');
                            
                            // Set highest quality by default
                            if (hls.levels.length > 0) {
                                const highestLevel = hls.levels.length - 1;
                                hls.currentLevel = highestLevel;
                                console.log('✓ Set to highest quality:', hls.levels[highestLevel].height + 'p');
                            }
                            
                            // Set English audio track by default if available
                            if (hls.audioTracks && hls.audioTracks.length > 0) {
                                console.log('📻 Available audio tracks:', hls.audioTracks.map(t => t.name || t.lang));
                                // Try to find English track
                                const englishTrack = hls.audioTracks.findIndex(track => {
                                    const name = (track.name || track.lang || '').toLowerCase();
                                    return name.includes('eng') || name.includes('english');
                                });
                                if (englishTrack !== -1) {
                                    hls.audioTrack = englishTrack;
                                    console.log('✓ Selected English audio track:', hls.audioTracks[englishTrack].name || hls.audioTracks[englishTrack].lang);
                                } else {
                                    console.log('⚠ English audio track not found, using default:', hls.audioTracks[hls.audioTrack]?.name || hls.audioTracks[hls.audioTrack]?.lang);
                                }
                            }
                            
                            const playPromise = video.play();
                            if (playPromise) playPromise.catch(err => console.warn('Autoplay blocked:', err));
                        });
                        hls.on(Hls.Events.ERROR, function (event, data) {
                            console.error('❌ HLS error (player-2):', data.type, data.details || data);
                        });
                        
                        // Store globally
                        window.__hlsInstance2 = hls;
                        window.playerHls = hls;
                    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                        // Safari native HLS
                        video.src = videoSrc;
                        video.addEventListener('loadedmetadata', () => {
                            const playPromise = video.play();
                            if (playPromise) playPromise.catch(err => console.warn('Autoplay blocked:', err));
                        });
                    } else {
                        console.warn('HLS not supported (player-2), falling back to direct src');
                        video.src = videoSrc;
                    }
                } else {
                    // MP4 or other direct sources
                    video.src = videoSrc;
                    video.type = `video/${sourceType}`;
                }

                // Wait for video to load
                video.addEventListener('loadedmetadata', () => {
                    console.log('Video loaded metadata');
                    
                    // Force video to fill screen completely
                    forceVideoFullScreen();
                });

                video.addEventListener('canplay', () => {
                    console.log('Video can play');
                    
                    // Force video to fill screen completely again
                    forceVideoFullScreen();
                    
                    // Initialize screen mode functionality after video is ready
                    initScreenMode();
                });

                // Force video to fill screen on resize
                window.addEventListener('resize', forceVideoFullScreen);
                
                // Force video to fill screen on orientation change
                window.addEventListener('orientationchange', forceVideoFullScreen);

                // Initialize subtitle container first
                initSubtitleContainer();

                // Set up subtitle track listeners after video loads
                video.addEventListener('loadedmetadata', () => {
                    setupSubtitleTracks();
                });
            } else {
                videoTitle.textContent = 'No video source available';
                showError('No video source available');
            }
        }

        // Robust subtitle loader with CORS proxy and blob URL support
        async function loadSubtitlesWithProxy(subtitleArray) {
            if (!subtitleArray || subtitleArray.length === 0) {
                console.log('No subtitles to load');
                return;
            }
            // Remove all existing <track> elements
            const existingTracks = video.querySelectorAll('track');
            existingTracks.forEach(track => track.remove());

            let trackAdded = false;
            let fetchError = false;
            for (let i = 0; i < subtitleArray.length; i++) {
                const subtitle = subtitleArray[i];
                const isRemoteUrl = subtitle.src.startsWith('http://') || subtitle.src.startsWith('https://');
                let subtitleUrl = subtitle.src;
                if (isRemoteUrl) {
                    subtitleUrl = await fetchSubtitleAsBlob(subtitle.src);
                    if (!subtitleUrl) {
                        console.error('Subtitle fetch failed for:', subtitle.src);
                        fetchError = true;
                        continue;
                    }
                }
                const track = document.createElement('track');
                track.kind = 'subtitles';
                track.label = subtitle.label || `Subtitle ${i + 1}`;
                track.srclang = subtitle.srclang || 'en';
                track.src = subtitleUrl;
                if (subtitle.default) track.default = true;
                // Add to video
                video.appendChild(track);
                trackAdded = true;
                // On load, set mode to hidden and attach cuechange
                track.addEventListener('load', function () {
                    try {
                        if (track.track) {
                            track.track.mode = 'hidden';
                            track.track.addEventListener('cuechange', handleCueChange);
                        }
                    } catch (e) { console.warn('Error setting subtitle track mode:', e); }
                });
                // Add error handler for debugging
                track.addEventListener('error', function (e) {
                    console.error('✗ Error loading subtitle track:', this.label, this.src, e);
                });
            }
            // If all fetches failed, show error and add fallback
            if (fetchError && !trackAdded) {
                subtitleContainer.innerHTML = '<div class="subtitle">Subtitle file could not be loaded (CORS or network error). Using fallback.</div>';
                createFallbackSubtitle();
                return;
            }
            // After a short delay, show the first subtitle track if enabled
            setTimeout(() => {
                const textTracks = video.textTracks;
                let found = false;
                for (let j = 0; j < textTracks.length; j++) {
                    if (textTracks[j].kind === 'subtitles') {
                        textTracks[j].mode = subtitlesEnabled ? 'showing' : 'hidden';
                        found = true;
                    }
                }
                if (!found && subtitlesEnabled && trackAdded) {
                    subtitleContainer.innerHTML = '<div class="subtitle">No subtitles found or failed to load. Using fallback.' +
                        '<br>Check browser console for [Subtitle Debug] logs.</div>';
                    createFallbackSubtitle();
                }
            }, 2000);
        }

        // Fetch remote subtitle and convert to blob URL (with CORS proxy fallback)
        async function fetchSubtitleAsBlob(url) {
            try {
                console.log('Fetching remote subtitle:', url);

                const proxyCandidates = [];
                let isCrossOrigin = false;

                try {
                    isCrossOrigin = new URL(url, window.location.href).origin !== window.location.origin;
                } catch (e) {
                    isCrossOrigin = true; // Assume cross-origin if URL parsing fails
                }

                // 1. If same origin, try direct first (fastest)
                if (!isCrossOrigin) {
                    proxyCandidates.push({ url: url, name: 'Direct (Local)' });
                }

                // 2. Add robust CORS proxies
                proxyCandidates.push({ url: `https://corsproxy.io/?${encodeURIComponent(url)}`, name: 'corsproxy.io' });
                proxyCandidates.push({ url: `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`, name: 'codetabs.com' });
                proxyCandidates.push({ url: `https://thingproxy.freeboard.io/fetch/${url}`, name: 'thingproxy' });
                proxyCandidates.push({ url: `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`, name: 'allorigins.win' });

                let lastError = null;

                for (let i = 0; i < proxyCandidates.length; i++) {
                    const candidate = proxyCandidates[i];
                    try {
                        console.log(`Trying method ${i + 1}/${proxyCandidates.length}: ${candidate.name}`);
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 15000);
                        try {
                            const response = await fetch(candidate.url, {
                                signal: controller.signal,
                                mode: 'cors',
                                cache: 'default'
                            });
                            clearTimeout(timeoutId);
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }
                            const text = await response.text();
                            if (!text.includes('WEBVTT') && !text.includes('1\n00:')) {
                                if (text.includes('<!DOCTYPE') || text.includes('<html')) {
                                    throw new Error('Received HTML instead of VTT');
                                }
                            }
                            const blob = new Blob([text], { type: 'text/vtt' });
                            const blobUrl = URL.createObjectURL(blob);
                            console.log(`✓ Subtitle loaded successfully via ${candidate.name}`);
                            return blobUrl;
                        } catch (fetchErr) {
                            clearTimeout(timeoutId);
                            throw fetchErr;
                        }
                    } catch (err) {
                        lastError = err;
                        console.warn(`${i + 1}. Failed (${candidate.name}):`, err.name === 'AbortError' ? 'Timeout' : err.message);
                        continue;
                    }
                }
                console.warn('All proxy methods failed. Subtitles unavailable.');
                throw lastError || new Error('All subtitle loading methods failed');
            } catch (error) {
                console.error('Could not load subtitle:', error.message);
                return null;
            }
        }

        function forceSubtitleVisibility() {
            if (!subtitleContainer) return;
            document.body.classList.toggle('subtitles-on', !!subtitlesEnabled);

            const displayValue = subtitlesEnabled ? 'block' : 'none';
            const opacityValue = subtitlesEnabled ? '1' : '0';

            // Determine if mobile or desktop - check both screen width and height
            // Mobile devices typically have max-height around 900-1000px or touch support
            const isMobileDevice = window.innerWidth <= 768 || window.innerHeight <= 1024;
            const bottomPosition = isMobileDevice ? '20px' : '150px';

            subtitleContainer.style.setProperty('display', displayValue, 'important');
            subtitleContainer.style.setProperty('opacity', opacityValue, 'important');
            subtitleContainer.style.setProperty('visibility', subtitlesEnabled ? 'visible' : 'hidden', 'important');
            subtitleContainer.style.setProperty('pointer-events', 'none', 'important');
            subtitleContainer.style.setProperty('z-index', '2147483647', 'important');
            subtitleContainer.style.setProperty('position', 'fixed', 'important');
            subtitleContainer.style.setProperty('left', '50%', 'important');
            subtitleContainer.style.setProperty('transform', 'translateX(-50%)', 'important');
            subtitleContainer.style.setProperty('bottom', bottomPosition, 'important');
            
            // Use requestAnimationFrame to ensure styles persist
            requestAnimationFrame(() => {
                if (subtitlesEnabled && subtitleContainer) {
                    subtitleContainer.style.setProperty('display', 'block', 'important');
                    subtitleContainer.style.setProperty('opacity', '1', 'important');
                    subtitleContainer.style.setProperty('visibility', 'visible', 'important');
                }
            });
        }

        // Initialize subtitle container
        function initSubtitleContainer() {
            if (!subtitleContainer) {
                subtitleContainer = document.getElementById('subtitleContainer');
            }
            // Subtitle container is now in body (not inside video-container) to avoid opacity inheritance
            forceSubtitleVisibility();
            
            // Check if current movie has subtitles
            const currentMovie = movieDatabase[normalizedTitle];
            if (subtitlesEnabled && currentMovie && currentMovie.subtitles) {
                subtitleContainer.innerHTML = '<div class="subtitle"></div>';
            } else if (subtitlesEnabled) {
                subtitleContainer.innerHTML = '<div class="subtitle">No subtitles available for this movie</div>';
            }
            
            // Set up MutationObserver to watch for ANY changes to subtitle container
            const observer = new MutationObserver(() => {
                if (subtitlesEnabled && subtitleContainer) {
                    const computed = window.getComputedStyle(subtitleContainer);
                    if (computed.display === 'none' || computed.opacity === '0' || computed.visibility === 'hidden') {
                        console.log('Subtitle container was hidden, restoring visibility');
                        forceSubtitleVisibility();
                    }
                }
            });
            
            if (subtitleContainer) {
                observer.observe(subtitleContainer, {
                    attributes: true,
                    attributeFilter: ['style', 'class'],
                    attributeOldValue: true
                });
            }
            
            // Also set up continuous interval as backup
            setInterval(() => {
                if (subtitlesEnabled && subtitleContainer) {
                    const computed = window.getComputedStyle(subtitleContainer);
                    if (computed.display === 'none' || computed.opacity === '0' || computed.visibility === 'hidden') {
                        forceSubtitleVisibility();
                    }
                }
            }, 50);
        }

        // Setup subtitle tracks after video loads
        function setupSubtitleTracks() {
            const tracks = video.textTracks;
            for (let i = 0; i < tracks.length; i++) {
                if (tracks[i].kind === 'subtitles') {
                    tracks[i].mode = 'hidden'; // Always start hidden
                    tracks[i].addEventListener('cuechange', handleCueChange);
                }
            }
        }

        // Load subtitles
        // (No longer needed: subtitles are added in initVideo before video.load())

        // Create fallback subtitle when CORS blocks external files
        function createFallbackSubtitle() {
            console.log('Creating fallback subtitle due to CORS/network issues');
            
            // Create a simple VTT content as data URL
            const vttContent = `WEBVTT

00:00:00.000 --> 00:00:03.000
Subtitle loading failed due to CORS restrictions

00:00:05.000 --> 00:00:08.000
This is a fallback subtitle

00:00:10.000 --> 00:00:13.000
External subtitle files are blocked by browser security

00:00:15.000 --> 00:00:18.000
CC button works but external files need CORS headers

00:00:20.000 --> 00:00:23.000
Subtitle system is functioning correctly

00:00:25.000 --> 00:00:28.000
Try hosting subtitles on same server as video`;
            
            const dataUrl = 'data:text/vtt;base64,' + btoa(vttContent);
            
            const track = document.createElement('track');
            track.kind = 'subtitles';
            track.label = 'Fallback English';
            track.srclang = 'en';
            track.src = dataUrl;
            track.default = true;
            video.appendChild(track);
            
            console.log('Added fallback subtitle track');
            
            // Set up track event listeners
            track.addEventListener('load', () => {
                console.log('Fallback subtitle track loaded successfully');
                track.mode = subtitlesEnabled ? 'showing' : 'hidden';
            });
        }

        // Handle subtitle cue changes
        function handleCueChange(e) {
            const track = e.target;
            const cues = track.activeCues;
            subtitleContainer.innerHTML = '';
            forceSubtitleVisibility();
            
            console.log('Cue change triggered, active cues:', cues ? cues.length : 0);
            
            if (cues && cues.length > 0) {
                Array.from(cues).forEach(cue => {
                    const subtitleDiv = document.createElement('div');
                    subtitleDiv.className = 'subtitle';
                    subtitleDiv.textContent = cue.text;
                    subtitleContainer.appendChild(subtitleDiv);
                    console.log('Subtitle text:', cue.text);
                });
            }
        }

        // Toggle subtitles
        function toggleSubtitle() {
            subtitlesEnabled = !subtitlesEnabled;
            // Initialize container if needed
            initSubtitleContainer();
            // Always reload subtitles when toggling ON
            if (subtitlesEnabled) {
                // Log normalizedTitle and all movieDatabase keys
                console.log('[Subtitle Debug] normalizedTitle:', normalizedTitle);
                console.log('[Subtitle Debug] movieDatabase keys:', Object.keys(movieDatabase));
                // Try to find the best match for the title
                let foundKey = null;
                const norm = s => s && s.toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim();
                const normTitle = norm(normalizedTitle);
                for (const key of Object.keys(movieDatabase)) {
                    if (norm(key) === normTitle) {
                        foundKey = key;
                        break;
                    }
                }
                if (foundKey && movieDatabase[foundKey].subtitles) {
                    console.log('[Subtitle Debug] toggleSubtitle() loading subtitles for', foundKey);
                    loadSubtitlesWithProxy(movieDatabase[foundKey].subtitles);
                } else {
                    console.log('[Subtitle Debug] toggleSubtitle() called, but no subtitles found for', normalizedTitle, 'or', foundKey);
                }
            } else {
                // Hide all subtitle tracks
                const tracks = video.textTracks;
                for (let i = 0; i < tracks.length; i++) {
                    if (tracks[i].kind === 'subtitles') {
                        tracks[i].mode = 'hidden';
                    }
                }
            }
            forceSubtitleVisibility();
            showGestureIndicator(subtitlesEnabled ? 'CC ON' : 'CC OFF');
        }

        // Play/Pause toggle
        function togglePlayPause() {
            if (isPlaying) {
                video.pause();
                isPlaying = false;
            } else {
                video.play();
                isPlaying = true;
            }
            updatePlayPauseButton();
            updateCenterPlayButton();
        }

        function updatePlayPauseButton() {
            const icon = playPauseBtn.querySelector('i');
            icon.className = isPlaying ? 'fas fa-pause' : 'fas fa-play';
        }

        function updateCenterPlayButton() {
            centerPlayIcon.className = isPlaying ? 'fas fa-pause' : 'fas fa-play';
            centerPlayText.textContent = isPlaying ? 'Pause' : 'Play';
        }

        // Progress bar
        function updateProgress() {
            const progress = (video.currentTime / video.duration) * 100;
            progressFilled.style.width = progress + '%';
            currentTimeEl.textContent = formatTime(video.currentTime);
            durationEl.textContent = formatTime(video.duration);
        }

        function updateBuffered() {
            if (video.buffered.length > 0) {
                const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                const bufferedProgress = (bufferedEnd / video.duration) * 100;
                progressBuffered.style.width = bufferedProgress + '%';
            }
        }

        // Enhanced seek functionality
        let wasPlayingBeforeSeek = false;
        function startSeek(e) {
            if (!video.duration) return;
            isSeeking = true;
            wasPlayingBeforeSeek = !video.paused; // Remember if video was playing
            updateSeekPosition(e);
            // Don't pause - let video continue playing while seeking
        }

        function updateSeekPosition(e) {
            if (!isSeeking || !video.duration) return;
            
            const rect = progressBar.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const newTime = pos * video.duration;
            
            // Update progress bar immediately for smooth feedback
            progressFilled.style.width = (pos * 100) + '%';
            currentTimeEl.textContent = formatTime(newTime);
            
            // Show time preview
            showGestureIndicator(formatTime(newTime));
        }

        function endSeek(e) {
            if (!isSeeking) return;
            
            const rect = progressBar.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const newTime = pos * video.duration;
            
            // Check if video.duration is valid and newTime is finite
            if (video.duration && !isNaN(video.duration) && isFinite(newTime)) {
                video.currentTime = newTime;
            }
            
            isSeeking = false;
            
            // Resume video if it was playing before seeking
            if (wasPlayingBeforeSeek && video.paused) {
                video.play().catch(err => console.log('Play after seek failed:', err));
            }
            
            hideGestureIndicator();
            
            // Auto-hide controls after seeking
            showControls();
        }

        // Thumbnail preview on hover - timestamp only (CORS-friendly)
        progressBar.addEventListener('mousemove', function(e) {
            if (!video.duration || isSeeking) return;
            
            const rect = progressBar.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const previewTime = pos * video.duration;
            
            // Position and show timestamp preview
            thumbnailPreview.style.left = (pos * 100) + '%';
            thumbnailTime.textContent = formatTime(previewTime);
            thumbnailPreview.classList.add('visible');
            
            // Hide canvas since we can't capture frames due to CORS
            thumbnailCanvas.style.display = 'none';
        });

        progressBar.addEventListener('mouseleave', function() {
            thumbnailPreview.classList.remove('visible');
        });

        // Enhanced seek event listeners (desktop)
        progressBar.addEventListener('mousedown', startSeek, { passive: false });
        document.addEventListener('mousemove', updateSeekPosition, { passive: false });
        document.addEventListener('mouseup', endSeek, { passive: false });

        // Touch support for mobile (fix: allow drag and tap seek)
        progressBar.addEventListener('touchstart', function(e) {
            if (!video.duration) return;
            isSeeking = true;
            const touch = e.touches[0];
            const rect = progressBar.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
            const newTime = pos * video.duration;
            video.currentTime = newTime;
            updateSeekPosition({ clientX: touch.clientX });
            e.preventDefault();
        }, { passive: false });

        progressBar.addEventListener('touchmove', function(e) {
            if (!isSeeking || !video.duration) return;
            const touch = e.touches[0];
            updateSeekPosition({ clientX: touch.clientX });
            e.preventDefault();
        }, { passive: false });

        progressBar.addEventListener('touchend', function(e) {
            if (!isSeeking) return;
            const touch = (e.changedTouches && e.changedTouches[0]) || (e.touches && e.touches[0]);
            if (touch) {
                updateSeekPosition({ clientX: touch.clientX });
            }
            isSeeking = false;
            if (wasPlayingBeforeSeek && video.paused) {
                video.play().catch(err => console.log('Play after seek failed:', err));
            }
            hideGestureIndicator();
            
            // Auto-hide controls after seeking
            showControls();
            
            e.preventDefault();
        }, { passive: false });

        // Volume control
        function updateVolume() {
            const volume = video.volume;
            volumeFilled.style.width = (volume * 100) + '%';
            
            if (volume === 0 || isMuted) {
                volumeIcon.className = 'fas fa-volume-mute';
            } else if (volume < 0.5) {
                volumeIcon.className = 'fas fa-volume-down';
            } else {
                volumeIcon.className = 'fas fa-volume-up';
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            video.muted = isMuted;
            updateVolume();
        }

        // Draggable Volume Slider
        const volumeThumb = document.getElementById('volumeThumb');
        let isDraggingVolume = false;

        function updateVolumeSlider() {
            const volume = video.volume;
            const percentage = volume * 100;
            volumeFilled.style.width = percentage + '%';
            volumeThumb.style.left = percentage + '%';
        }

        function setVolumeFromPosition(x) {
            const rect = volumeSlider.getBoundingClientRect();
            const percentage = Math.max(0, Math.min(100, ((x - rect.left) / rect.width) * 100));
            const volume = percentage / 100;
            
            video.volume = volume;
            video.muted = false;
            isMuted = false;
            updateVolume();
            updateVolumeSlider();
        }

        // Volume slider click
        volumeSlider.addEventListener('click', (e) => {
            setVolumeFromPosition(e.clientX);
        });

        // Volume thumb drag events
        volumeThumb.addEventListener('mousedown', (e) => {
            isDraggingVolume = true;
            volumeThumb.classList.add('dragging');
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingVolume) {
                setVolumeFromPosition(e.clientX);
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingVolume) {
                isDraggingVolume = false;
                volumeThumb.classList.remove('dragging');
            }
        });

        // Touch events for mobile
        volumeThumb.addEventListener('touchstart', (e) => {
            isDraggingVolume = true;
            volumeThumb.classList.add('dragging');
            e.preventDefault();
        });

        document.addEventListener('touchmove', (e) => {
            if (isDraggingVolume) {
                const touch = e.touches[0];
                setVolumeFromPosition(touch.clientX);
            }
        });

        document.addEventListener('touchend', () => {
            if (isDraggingVolume) {
                isDraggingVolume = false;
                volumeThumb.classList.remove('dragging');
            }
        });

        // Update volume slider when volume changes
        video.addEventListener('volumechange', updateVolumeSlider);

        // Initialize volume slider
        updateVolumeSlider();

        function setVolume(e) {
            const rect = volumeSlider.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            video.volume = Math.max(0, Math.min(1, pos));
            updateVolume();
        }

        volumeSlider.addEventListener('mousedown', setVolume);
        document.addEventListener('mousemove', (e) => {
            if (e.buttons === 1 && volumeSlider.contains(e.target)) {
                setVolume(e);
            }
        });

        // Controls visibility
        function showControls() {
            if (isLocked) return;
            controlsOverlay.classList.add('visible');
            clearTimeout(controlsTimeout);
            controlsTimeout = setTimeout(() => {
                controlsOverlay.classList.remove('visible');
                forceSubtitleVisibility();
            }, 3000);
            forceSubtitleVisibility();
        }

        function hideControls(force = false) {
            if (isLocked && !force) return;
            controlsOverlay.classList.remove('visible');
            forceSubtitleVisibility();
        }

        // Show tap overlay
        function showTapOverlay() {
            console.log('showTapOverlay called');
            if (isLocked) {
                console.log('Screen is locked, not showing overlay');
                return;
            }
            console.log('Adding visible class to tap overlay');
            tapOverlay.classList.add('visible');
            controlsOverlay.classList.add('visible');
            tapOverlayVisible = true;
            updateCenterPlayButton();
            forceSubtitleVisibility();
            
            // Clear existing timeout and set new one
            clearTimeout(controlsTimeout);
            controlsTimeout = setTimeout(() => {
                hideTapOverlay();
            }, 3000);
        }

        // Hide tap overlay
        function hideTapOverlay() {
            tapOverlay.classList.remove('visible');
            controlsOverlay.classList.remove('visible');
            tapOverlayVisible = false;
            forceSubtitleVisibility();
        }

        // Toggle tap overlay
        function toggleTapOverlay() {
            console.log('toggleTapOverlay called, current state:', tapOverlayVisible);
            if (tapOverlayVisible) {
                hideTapOverlay();
            } else {
                showTapOverlay();
            }
        }

        // Handle tap zone clicks
        function handleTapZoneClick(action) {
            // Reset the auto-hide timer when user interacts
            clearTimeout(controlsTimeout);
            controlsTimeout = setTimeout(() => {
                hideTapOverlay();
            }, 3000);
            
            switch(action) {
                case 'rewind':
                    video.currentTime = Math.max(0, video.currentTime - 10);
                    showTapFeedback('leftFeedback', '-10s');
                    // Preserve screen mode after skipping
                    setTimeout(preserveScreenMode, 50);
                    break;
                case 'playpause':
                    togglePlayPause();
                    showTapFeedback('centerFeedback', isPlaying ? 'Pause' : 'Play');
                    break;
                case 'forward':
                    video.currentTime = Math.min(video.duration, video.currentTime + 10);
                    showTapFeedback('rightFeedback', '+10s');
                    // Preserve screen mode after skipping
                    setTimeout(preserveScreenMode, 50);
                    break;
            }
        }

        // Show tap feedback below buttons
        function showTapFeedback(elementId, text) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = text;
                element.classList.add('visible');
                setTimeout(() => {
                    element.classList.remove('visible');
                }, 1500);
            }
        }

        // Enhanced Touch gestures (MX Player style)
        // Gesture tap logic: double/triple tap for skip, center double tap for fullscreen
        let tapZone = null;
        let tapSequence = [];
        let tapTimer = null;
        function handleTouchStart(e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchStartTime = Date.now();
            gestureStartX = touchStartX;
            gestureStartY = touchStartY;

            // Clear any existing timers
            clearTimeout(longPressTimer);
            clearTimeout(doubleTapTimer);

            // Start long press timer
            longPressTimer = setTimeout(() => {
                if (!isLocked) {
                    showGestureIndicator('🔒 Long Press - Lock Screen');
                    toggleLock();
                }
            }, 500);

            // Determine tap zone: left, center, right
            const screenWidth = window.innerWidth;
            if (touchStartX < screenWidth * 0.3) {
                tapZone = 'left';
            } else if (touchStartX > screenWidth * 0.7) {
                tapZone = 'right';
            } else {
                tapZone = 'center';
            }

            // Tap sequence logic
            tapSequence.push(tapZone);
            if (tapTimer) clearTimeout(tapTimer);
            tapTimer = setTimeout(() => {
                // Count taps in each zone
                const leftTaps = tapSequence.filter(z => z === 'left').length;
                const rightTaps = tapSequence.filter(z => z === 'right').length;
                const centerTaps = tapSequence.filter(z => z === 'center').length;
                if (leftTaps === 2) {
                    video.currentTime = Math.max(0, video.currentTime - 10);
                    showGestureIndicator('⏪ -10s');
                } else if (leftTaps >= 3) {
                    video.currentTime = Math.max(0, video.currentTime - 30);
                    showGestureIndicator('⏪ -30s');
                } else if (rightTaps === 2) {
                    video.currentTime = Math.min(video.duration, video.currentTime + 10);
                    showGestureIndicator('⏩ +10s');
                } else if (rightTaps >= 3) {
                    video.currentTime = Math.min(video.duration, video.currentTime + 30);
                    showGestureIndicator('⏩ +30s');
                } else if (centerTaps === 2) {
                    toggleFullscreen();
                    showGestureIndicator('📱 Fullscreen');
                } else if (centerTaps === 1) {
                    togglePlayPause();
                }
                tapSequence = [];
            }, 350);
        }

        function handleTouchMove(e) {
            if (isLocked) return;
            
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const deltaX = currentX - gestureStartX;
            const deltaY = currentY - gestureStartY;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            // Cancel long press if finger moved
            if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                clearTimeout(longPressTimer);
            }
            
            // Determine gesture type based on starting position
            if (!isSeeking && !isVolumeGesturing && !isBrightnessGesturing) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Horizontal gesture - seeking
                    if (Math.abs(deltaX) > 30) {
                        isSeeking = true;
                        initialVolume = video.volume;
                        showGestureIndicator('⏩ Seeking...');
                    }
                } else {
                    // Vertical gesture
                    if (gestureStartX < screenWidth / 3) {
                        // Left side - brightness
                        isBrightnessGesturing = true;
                        showGestureIndicator('🔆 Brightness');
                    } else if (gestureStartX > screenWidth * 2 / 3) {
                        // Right side - volume
                        isVolumeGesturing = true;
                        initialVolume = video.volume;
                        showGestureIndicator('🔊 Volume');
                    }
                }
            }
            
            // Handle ongoing gestures
            if (isSeeking) {
                const seekAmount = (deltaX / screenWidth) * video.duration;
                const newTime = Math.max(0, Math.min(video.duration, video.currentTime + seekAmount));
                video.currentTime = newTime;
                showGestureIndicator(formatTime(newTime));
            } else if (isVolumeGesturing) {
                const volumeChange = -(deltaY / screenHeight);
                const newVolume = Math.max(0, Math.min(1, initialVolume + volumeChange));
                video.volume = newVolume;
                showGestureIndicator('🔊 ' + Math.round(newVolume * 100) + '%');
            } else if (isBrightnessGesturing) {
                const brightnessChange = -(deltaY / screenHeight);
                currentBrightness = Math.max(0, Math.min(1, initialBrightness + brightnessChange));
                applyBrightness(currentBrightness);
                showGestureIndicator('🔆 ' + Math.round(currentBrightness * 100) + '%');
            }
        }

        function handleTouchEnd(e) {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const deltaTime = Date.now() - touchStartTime;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            // Clear timers
            clearTimeout(longPressTimer);
            clearTimeout(doubleTapTimer);
            
            // Reset gesture states
            if (isSeeking) {
                showGestureIndicator('⏩ Seek Complete');
                isSeeking = false;
            } else if (isVolumeGesturing) {
                isVolumeGesturing = false;
            } else if (isBrightnessGesturing) {
                isBrightnessGesturing = false;
            }
            
            // Handle single tap (if not a swipe and not double tap)
            if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10 && deltaTime < 200 && tapCount === 1) {
                doubleTapTimer = setTimeout(() => {
                    handleSingleTap(touchStartX, touchStartY, screenWidth);
                    tapCount = 0;
                }, 300);
            }
            
            // Handle swipe gestures
            if (Math.abs(deltaX) > 50 && Math.abs(deltaX) > Math.abs(deltaY) && deltaTime < 500) {
                handleSwipe(deltaX, touchStartX, screenWidth);
            }
        }

        function handleSingleTap(x, y, screenWidth) {
            if (isLocked) {
                showGestureIndicator('🔓 Screen Unlocked');
                isLocked = false;
                showControls();
                return;
            }
            
            // Tap zones for different actions
            if (x < screenWidth * 0.3) {
                // Left side - rewind 10 seconds
                video.currentTime = Math.max(0, video.currentTime - 10);
                showGestureIndicator('⏪ -10s');
                // Preserve screen mode after skipping
                setTimeout(preserveScreenMode, 50);
            } else if (x > screenWidth * 0.7) {
                // Right side - forward 10 seconds
                video.currentTime = Math.min(video.duration, video.currentTime + 10);
                showGestureIndicator('⏩ +10s');
                // Preserve screen mode after skipping
                setTimeout(preserveScreenMode, 50);
            } else {
                // Center - play/pause
                togglePlayPause();
            }
        }

        function handleDoubleTap() {
            if (isLocked) return;
            
            // Double tap center to toggle fullscreen
            toggleFullscreen();
            showGestureIndicator('📱 Fullscreen');
        }

        function handleSwipe(deltaX, startX, screenWidth) {
            if (isLocked) return;
            
            // Horizontal swipe for seeking (already handled in touchMove)
            // Placeholder: no extra swipe action needed
        }

        function applyBrightness(brightness) {
            // Apply brightness filter to video
            video.style.filter = `brightness(${brightness})`;
            // Show gesture indicator
        }

        function showGestureIndicator(text) {
            gestureIndicator.textContent = text;
            gestureIndicator.style.opacity = '1';
            clearTimeout(gestureIndicatorTimeout);
            gestureIndicatorTimeout = setTimeout(() => {
                gestureIndicator.style.opacity = '0';
            }, 1500);
        }

        // Hide gesture indicator
        function hideGestureIndicator() {
            gestureIndicator.style.opacity = '0';
            clearTimeout(gestureIndicatorTimeout);
        }

        // Lock controls
        function toggleLock() {
            isLocked = !isLocked;

            if (isLocked) {
                hideControls(true);
                tapOverlay.classList.remove('visible');
                lockFloatingButton.classList.remove('is-hidden');
                lockIcon.classList.remove('fa-lock-open');
                lockIcon.classList.add('fa-lock');
                lockFloatingButton.querySelector('i').classList.remove('fa-lock');
                lockFloatingButton.querySelector('i').classList.add('fa-lock-open');
                showGestureIndicator('🔒 Screen Locked');
            } else {
                lockFloatingButton.classList.add('is-hidden');
                lockIcon.classList.remove('fa-lock');
                lockIcon.classList.add('fa-lock-open');
                showControls();
                showGestureIndicator('🔓 Screen Unlocked');
            }
        }

        function togglePlayback(offsetSeconds) {
            const offset = Number(offsetSeconds);
            if (!Number.isFinite(offset) || !video.duration) {
                return;
            }

            const nextTime = Math.max(0, Math.min(video.duration, video.currentTime + offset));
            video.currentTime = nextTime;

            const directionLabel = offset >= 0 ? `⏩ +${Math.abs(offset)}s` : `⏪ -${Math.abs(offset)}s`;
            showGestureIndicator(directionLabel);

            // Preserve screen mode after skipping
            setTimeout(preserveScreenMode, 50);
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    // If in portrait, try to force landscape
                    if (window.screen.orientation && window.screen.orientation.lock) {
                        if (window.matchMedia('(orientation: portrait)').matches) {
                            window.screen.orientation.lock('landscape').catch(() => {});
                        }
                    }
                    // No DOM moves needed; subtitles stay fixed to viewport
                });
            } else {
                document.exitFullscreen();
                // Optionally unlock orientation on exit
                if (window.screen.orientation && window.screen.orientation.unlock) {
                    window.screen.orientation.unlock();
                }
            }
        }

        // Listen for fullscreen changes (no subtitle DOM shuffling needed now)
        document.addEventListener('fullscreenchange', () => {
            // subtitles remain in body with fixed positioning
            forceSubtitleVisibility();
        });

        // Also listen for webkit fullscreen changes
        document.addEventListener('webkitfullscreenchange', () => {
            // subtitles remain in body with fixed positioning
            forceSubtitleVisibility();
        });

        // Ensure subtitles stay visible after any resize/orientation change
        window.addEventListener('resize', forceSubtitleVisibility);
        window.addEventListener('orientationchange', forceSubtitleVisibility);

        function goBack() {
            window.location.href = 'index.html';
        }

        // Utility functions
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            } else {
                return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
        }

        function showError(message) {
            videoTitle.textContent = 'Error: ' + message;
        }

        // Video event listeners
        video.addEventListener('play', () => {
            isPlaying = true;
            updatePlayPauseButton();
            updateCenterPlayButton();
            hideTapOverlay();
        });
        video.addEventListener('pause', () => {
            isPlaying = false;
            updatePlayPauseButton();
            updateCenterPlayButton();
        });
        video.addEventListener('timeupdate', updateProgress);
        video.addEventListener('progress', updateBuffered);
        video.addEventListener('volumechange', updateVolume);
        video.addEventListener('waiting', () => loadingSpinner.classList.add('active'));
        video.addEventListener('canplay', () => loadingSpinner.classList.remove('active'));
        video.addEventListener('seeked', () => {
            // Preserve screen mode after seeking/seeking completes
            setTimeout(preserveScreenMode, 50);
        });
        video.addEventListener('ended', () => {
            isPlaying = false;
            updatePlayPauseButton();
            updateCenterPlayButton();
        });

        // Touch event listeners
        video.addEventListener('touchstart', handleTouchStart);
        video.addEventListener('touchend', handleTouchEnd);

        // Mouse/touch events for controls
        video.addEventListener('click', (e) => {
            if (!isLocked) {
                console.log('Video clicked, showing tap overlay');
                toggleTapOverlay();
            }
        });

        controlsOverlay.addEventListener('click', (e) => {
            if (e.target === controlsOverlay || e.target.closest('.bottom-controls')) {
                showControls();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlayPause();
                    break;
                case 'ArrowRight':
                    video.currentTime += 10;
                    break;
                case 'ArrowLeft':
                    video.currentTime -= 10;
                    break;
                case 'ArrowUp':
                    video.volume = Math.min(1, video.volume + 0.1);
                    break;
                case 'ArrowDown':
                    video.volume = Math.max(0, video.volume - 0.1);
                    break;
                case 'f':
                    toggleFullscreen();
                    break;
                case 'm':
                    toggleMute();
                    break;
                case 'Escape':
                    hideTapOverlay();
                    break;
                case 'Enter':
                    toggleTapOverlay();
                    break;
            }
        });

        // Setup language selector
        function setupLanguageSelector() {
            const urlParams = new URLSearchParams(window.location.search);
            const imdbId = urlParams.get('imdbId');
            const streamKey = urlParams.get('streamKey');
            let currentLang = urlParams.get('currentLang');
            const availableLangsParam = urlParams.get('availableLangs');
            let availableLanguages = [];
            
            if (availableLangsParam) {
                try {
                    availableLanguages = JSON.parse(decodeURIComponent(availableLangsParam));
                    console.log('[Language] Available languages:', availableLanguages);
                } catch (e) {
                    console.error('[Language] Error parsing available languages:', e);
                }
            }
            
            // Default to English if available languages exist but no current language is set
            if (availableLanguages.length > 0 && !currentLang) {
                // Check if English is available
                if (availableLanguages.includes('English')) {
                    console.log('[Language] No language specified, defaulting to English');
                    currentLang = 'English';
                    // Update URL to include English as currentLang
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set('currentLang', 'English');
                    window.history.replaceState({}, '', newUrl.toString());
                } else if (availableLanguages.length > 0) {
                    // If English not available, use first available language
                    currentLang = availableLanguages[0];
                    console.log('[Language] English not available, defaulting to:', currentLang);
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set('currentLang', currentLang);
                    window.history.replaceState({}, '', newUrl.toString());
                }
            }
            
            // Setup language menu
            if (availableLanguages.length > 0 && imdbId && streamKey) {
                const languageBtn = document.getElementById('languageBtn');
                const languageMenu = document.getElementById('languageMenu');
                const languageOptions = document.getElementById('languageOptions');
                
                if (!languageBtn || !languageMenu || !languageOptions) {
                    console.error('[Language] Language UI elements not found');
                    return;
                }
                
                console.log('[Language] Setting up selector with', availableLanguages.length, 'languages');
                
                // Show language button
                languageBtn.style.display = 'inline-block';
                
                // Check if original language is missing and show indicator
                const languageInfoParam = new URLSearchParams(window.location.search).get('languageInfo');
                if (languageInfoParam) {
                    try {
                        const langInfo = JSON.parse(decodeURIComponent(languageInfoParam));
                        if (langInfo.missingOriginal && langInfo.original) {
                            // Add tooltip or title to show original language missing
                            languageBtn.title = `⚠ Original ${langInfo.original} not available`;
                            languageBtn.setAttribute('data-tooltip-original-missing', `Original ${langInfo.original} not available`);
                            console.log('[Language] ⚠ Original language', langInfo.original, 'not available. Available:', langInfo.available);
                        }
                    } catch (e) {
                        console.log('[Language] Could not parse languageInfo');
                    }
                }
                
                // Toggle menu on button click
                languageBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = languageMenu.style.display === 'block';
                    
                    console.log('[Language] Button clicked, menu visible:', isVisible);
                    
                    if (!isVisible) {
                        const rect = languageBtn.getBoundingClientRect();
                        languageMenu.style.display = 'block';
                        languageMenu.style.left = `${rect.left - 150}px`;
                        languageMenu.style.bottom = `${window.innerHeight - rect.top + 10}px`;
                        console.log('[Language] Menu opened at', rect.left - 150, window.innerHeight - rect.top + 10);
                    } else {
                        languageMenu.style.display = 'none';
                    }
                });
                
                // Close menu on click outside
                document.addEventListener('click', (e) => {
                    if (!languageMenu.contains(e.target) && e.target !== languageBtn && !languageBtn.contains(e.target)) {
                        languageMenu.style.display = 'none';
                    }
                });
                
                // Populate language options
                languageOptions.innerHTML = ''; // Clear existing options
                availableLanguages.forEach(lang => {
                    const option = document.createElement('div');
                    option.style.cssText = 'padding: 10px 15px; cursor: pointer; color: #fff; font-size: 14px; border-radius: 6px; transition: background 0.2s;';
                    if (lang === currentLang) {
                        option.style.background = 'rgba(255, 255, 255, 0.25)';
                        option.style.fontWeight = '600';
                        option.innerHTML = `${lang} <i class="fas fa-check" style="float: right;"></i>`;
                    } else {
                        option.textContent = lang;
                    }
                    
                    option.addEventListener('mouseenter', () => {
                        if (lang !== currentLang) {
                            option.style.background = 'rgba(255, 255, 255, 0.1)';
                        }
                    });
                    option.addEventListener('mouseleave', () => {
                        if (lang !== currentLang) {
                            option.style.background = 'transparent';
                        }
                    });
                    
                    option.addEventListener('click', async () => {
                        if (lang === currentLang) {
                            console.log('[Language] Already on', lang);
                            return;
                        }
                        
                        console.log('[Language] Switching to', lang);
                        const originalText = option.textContent;
                        option.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Loading...';
                        
                        try {
                            if (typeof window.resolveStreamForLanguage !== 'function') {
                                console.error('[Language] resolveStreamForLanguage function not found');
                                option.textContent = originalText;
                                return;
                            }
                            
                            const result = await window.resolveStreamForLanguage(imdbId, lang, streamKey);
                            console.log('[Language] Resolve result:', result);
                            
                            if (result.success && result.src) {
                                const video = document.getElementById('videoPlayer');
                                if (!video) {
                                    console.error('[Language] Video element not found');
                                    option.textContent = originalText;
                                    return;
                                }
                                
                                const currentTime = video.currentTime;
                                const wasPlaying = !video.paused;
                                
                                console.log('[Language] Current time:', currentTime, 'Was playing:', wasPlaying);
                                
                                // Pause video first
                                video.pause();
                                
                                // Destroy existing HLS instance completely
                                if (window.playerHls) {
                                    console.log('[Language] Destroying existing HLS instance');
                                    try {
                                        window.playerHls.detachMedia();
                                        window.playerHls.destroy();
                                    } catch (e) {
                                        console.log('[Language] Error destroying HLS:', e);
                                    }
                                    window.playerHls = null;
                                }
                                
                                // Aggressively clear all media state
                                video.removeAttribute('src');
                                video.src = '';
                                video.load();
                                
                                // Wait longer for complete buffer flush
                                await new Promise(resolve => setTimeout(resolve, 200));
                                
                                // Initialize new HLS source with error recovery
                                if (Hls.isSupported()) {
                                    console.log('[Language] Initializing HLS with new source');
                                    window.playerHls = new Hls({
                                        debug: false,
                                        enableWorker: true,
                                        lowLatencyMode: false,
                                        backBufferLength: 90,
                                        maxBufferLength: 30,
                                        maxMaxBufferLength: 60,
                                        maxBufferSize: 60 * 1000 * 1000,
                                        maxBufferHole: 0.5,
                                        // Auto-recover from buffer errors
                                        autoStartLoad: true,
                                        startPosition: -1,
                                        capLevelToPlayerSize: false
                                    });
                                    
                                    // Add error recovery handler
                                    window.playerHls.on(Hls.Events.ERROR, function(event, data) {
                                        if (data.fatal) {
                                            switch (data.type) {
                                                case Hls.ErrorTypes.MEDIA_ERROR:
                                                    console.log('[Language] Recovering from media error');
                                                    window.playerHls.recoverMediaError();
                                                    break;
                                                case Hls.ErrorTypes.NETWORK_ERROR:
                                                    console.log('[Language] Network error, reloading');
                                                    window.playerHls.startLoad();
                                                    break;
                                                default:
                                                    console.error('[Language] Fatal error, cannot recover');
                                                    break;
                                            }
                                        } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                                            // Non-fatal media errors - try to recover
                                            console.log('[Language] Non-fatal media error, recovering');
                                            window.playerHls.recoverMediaError();
                                        }
                                    });
                                    
                                    window.playerHls.loadSource(result.src);
                                    window.playerHls.attachMedia(video);
                                    window.playerHls.on(Hls.Events.MANIFEST_PARSED, function() {
                                        console.log('[Language] Manifest parsed, seeking to', currentTime);
                                        
                                        // Set highest quality by default
                                        if (window.playerHls.levels.length > 0) {
                                            const highestLevel = window.playerHls.levels.length - 1;
                                            window.playerHls.currentLevel = highestLevel;
                                            console.log('[Language] Set to highest quality:', window.playerHls.levels[highestLevel].height + 'p');
                                        }
                                        
                                        video.currentTime = currentTime;
                                        if (wasPlaying) {
                                            video.play().catch(e => console.log('[Language] Autoplay prevented:', e));
                                        }
                                        
                                        // Re-setup quality selector with new stream
                                        setTimeout(() => setupQualitySelector(), 500);
                                    });
                                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                                    console.log('[Language] Using native HLS support');
                                    video.src = result.src;
                                    video.addEventListener('loadedmetadata', () => {
                                        video.currentTime = currentTime;
                                        if (wasPlaying) {
                                            video.play().catch(e => console.log('[Language] Autoplay prevented:', e));
                                        }
                                    }, { once: true });
                                }
                                
                                // Update UI
                                languageOptions.querySelectorAll('div').forEach(opt => {
                                    opt.style.background = 'transparent';
                                    opt.style.fontWeight = 'normal';
                                    const text = opt.textContent.replace(' ✓', '').trim();
                                    opt.textContent = text;
                                });
                                option.style.background = 'rgba(255, 255, 255, 0.25)';
                                option.style.fontWeight = '600';
                                option.innerHTML = `${lang} <i class="fas fa-check" style="float: right;"></i>`;
                                
                                languageMenu.style.display = 'none';
                                console.log('[Language] ✓ Switched to:', lang);
                            } else {
                                console.error('[Language] Failed to resolve stream for:', lang, result);
                                option.textContent = originalText;
                                alert('Failed to switch language. Please try again.');
                            }
                        } catch (error) {
                            console.error('[Language] Error switching language:', error);
                            option.textContent = originalText;
                            alert('Error switching language: ' + error.message);
                        }
                    });
                    
                    languageOptions.appendChild(option);
                });
                
                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!languageMenu.contains(e.target) && !languageBtn.contains(e.target)) {
                        languageMenu.style.display = 'none';
                    }
                });
                
                console.log('[Language] Setup complete, button visible');
            }
        }
        
        // Setup quality selector (independent function)
        function setupQualitySelector() {
            const qualityBtn = document.getElementById('qualityBtn');
            const qualityMenu = document.getElementById('qualityMenu');
            const qualityOptions = document.getElementById('qualityOptions');
            
            if (!qualityBtn || !qualityMenu || !qualityOptions) {
                console.log('[Quality] Quality UI elements not found');
                return;
            }
            
            const hls = window.playerHls || window.__hlsInstance2;
                
                if (!hls || !hls.levels || hls.levels.length === 0) {
                    console.log('[Quality] No quality levels available');
                    return;
                }
                
                console.log('[Quality] Setting up selector with', hls.levels.length, 'quality levels');
                
                // Show quality button
                qualityBtn.style.display = 'inline-block';
                
                // Toggle menu on button click
                qualityBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = qualityMenu.style.display === 'block';
                    
                    console.log('[Quality] Button clicked, menu visible:', isVisible);
                    
                    if (isVisible) {
                        qualityMenu.style.display = 'none';
                    } else {
                        // Hide language menu if open
                        const languageMenu = document.getElementById('languageMenu');
                        if (languageMenu) languageMenu.style.display = 'none';
                        
                        // Position menu near button
                        const rect = qualityBtn.getBoundingClientRect();
                        qualityMenu.style.bottom = (window.innerHeight - rect.top + 10) + 'px';
                        qualityMenu.style.right = (window.innerWidth - rect.right) + 'px';
                        qualityMenu.style.display = 'block';
                        
                        console.log('[Quality] Menu opened at', rect.left, rect.bottom);
                    }
                });
                
                // Populate quality options
                qualityOptions.innerHTML = '';
                
                // Add Auto option
                const autoOption = document.createElement('div');
                autoOption.style.cssText = 'padding: 10px 15px; cursor: pointer; color: #fff; font-size: 14px; border-radius: 8px; transition: all 0.2s;';
                autoOption.textContent = 'Auto';
                autoOption.addEventListener('mouseenter', () => autoOption.style.background = 'rgba(255, 255, 255, 0.15)');
                autoOption.addEventListener('mouseleave', () => {
                    if (hls.currentLevel === -1) {
                        autoOption.style.background = 'rgba(255, 255, 255, 0.25)';
                    } else {
                        autoOption.style.background = 'transparent';
                    }
                });
                autoOption.addEventListener('click', () => {
                    console.log('[Quality] Switching to Auto');
                    hls.currentLevel = -1;
                    
                    // Update UI
                    qualityOptions.querySelectorAll('div').forEach(opt => {
                        opt.style.background = 'transparent';
                        opt.style.fontWeight = 'normal';
                        const text = opt.textContent.replace(' ✓', '').trim();
                        opt.textContent = text;
                    });
                    autoOption.style.background = 'rgba(255, 255, 255, 0.25)';
                    autoOption.style.fontWeight = '600';
                    autoOption.innerHTML = `Auto <i class="fas fa-check" style="float: right;"></i>`;
                    
                    qualityMenu.style.display = 'none';
                    console.log('[Quality] ✓ Switched to Auto');
                });
                
                if (hls.currentLevel === -1) {
                    autoOption.style.background = 'rgba(255, 255, 255, 0.25)';
                    autoOption.style.fontWeight = '600';
                    autoOption.innerHTML = `Auto <i class="fas fa-check" style="float: right;"></i>`;
                }
                
                qualityOptions.appendChild(autoOption);
                
                // Add quality level options (sorted highest to lowest)
                const sortedLevels = hls.levels
                    .map((level, index) => ({ level, index }))
                    .sort((a, b) => b.level.height - a.level.height);
                
                sortedLevels.forEach(({ level, index }) => {
                    const option = document.createElement('div');
                    const qualityLabel = level.height ? `${level.height}p` : `${Math.round(level.bitrate / 1000)}kbps`;
                    
                    option.style.cssText = 'padding: 10px 15px; cursor: pointer; color: #fff; font-size: 14px; border-radius: 8px; transition: all 0.2s;';
                    option.textContent = qualityLabel;
                    option.addEventListener('mouseenter', () => option.style.background = 'rgba(255, 255, 255, 0.15)');
                    option.addEventListener('mouseleave', () => {
                        if (hls.currentLevel === index) {
                            option.style.background = 'rgba(255, 255, 255, 0.25)';
                        } else {
                            option.style.background = 'transparent';
                        }
                    });
                    option.addEventListener('click', () => {
                        console.log('[Quality] Switching to', qualityLabel);
                        hls.currentLevel = index;
                        
                        // Update UI
                        qualityOptions.querySelectorAll('div').forEach(opt => {
                            opt.style.background = 'transparent';
                            opt.style.fontWeight = 'normal';
                            const text = opt.textContent.replace(' ✓', '').trim();
                            opt.textContent = text;
                        });
                        option.style.background = 'rgba(255, 255, 255, 0.25)';
                        option.style.fontWeight = '600';
                        option.innerHTML = `${qualityLabel} <i class="fas fa-check" style="float: right;"></i>`;
                        
                        qualityMenu.style.display = 'none';
                        console.log('[Quality] ✓ Switched to', qualityLabel);
                    });
                    
                    // Mark current quality
                    if (hls.currentLevel === index) {
                        option.style.background = 'rgba(255, 255, 255, 0.25)';
                        option.style.fontWeight = '600';
                        option.innerHTML = `${qualityLabel} <i class="fas fa-check" style="float: right;"></i>`;
                    }
                    
                    qualityOptions.appendChild(option);
                });
                
                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!qualityMenu.contains(e.target) && !qualityBtn.contains(e.target)) {
                        qualityMenu.style.display = 'none';
                    }
                });
                
                console.log('[Quality] Setup complete, button visible');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing...');
            
            // Setup language selector
            setupLanguageSelector();
            
            // Test if screen mode button exists
            const testBtn = document.getElementById('screenModeToggle');
            console.log('Screen mode button found on DOM load:', testBtn);
            
            // Check if tap overlay exists
            if (!tapOverlay) {
                console.error('Tap overlay element not found!');
            } else {
                console.log('Tap overlay element found:', tapOverlay);
            }
            
            initVideo();
            
            // Setup quality selector when HLS is ready (independent initialization)
            setTimeout(() => {
                if (window.playerHls || window.__hlsInstance2) {
                    setupQualitySelector();
                } else {
                    // Try again after another delay
                    setTimeout(() => {
                        if (window.playerHls || window.__hlsInstance2) {
                            setupQualitySelector();
                        }
                    }, 1500);
                }
            }, 500);
            
            // Show controls immediately so screen mode button is clickable
            showControls();
            
            // Force controls to stay visible initially
            setTimeout(() => {
                const controlsOverlay = document.getElementById('controlsOverlay');
                if (controlsOverlay) {
                    controlsOverlay.classList.add('visible');
                    console.log('Controls forced visible');
                }
            }, 100);
        });

        // NontonGo helper for Player 2 - build embed URLs and open proxied cleaned iframe
        window.openNontonGoEmbed = function(tmdbId, mediaType = 'movie', season = null, episode = null) {
            try {
                if (!tmdbId) { console.warn('openNontonGoEmbed: tmdbId required'); return; }
                let embedUrl = '';
                if (mediaType === 'tv' && season && episode) embedUrl = `https://www.NontonGo.win/embed/tv/${tmdbId}/${season}/${episode}`;
                else if (mediaType === 'tv') embedUrl = `https://www.NontonGo.win/embed/tv/?id=${tmdbId}&s=${season || ''}&e=${episode || ''}`;
                else embedUrl = `https://www.NontonGo.win/embed/movie/${tmdbId}`;

                const prox = `/api/proxy/video?url=${encodeURIComponent(embedUrl)}&provider=nontongo&clean=1&autoplay=1`;
                console.log('openNontonGoEmbed: Loading proxied embed:', prox);
                appendDev('Open NontonGo embed: ' + embedUrl);

                const container = document.querySelector('.video-container') || document.body;
                if (!container) { console.error('openNontonGoEmbed: container not found'); return; }

                // Hide native video element
                try { const vid = document.getElementById('videoPlayer') || document.getElementById('video'); if (vid) { vid.style.display = 'none'; } } catch(e) {}

                const existing = container.querySelector('#stream-iframe');
                if (existing) existing.remove();
                const iframe = document.createElement('iframe');
                iframe.id = 'stream-iframe';
                iframe.src = prox;
                iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = 'none'; iframe.style.position = 'absolute'; iframe.style.top = '0'; iframe.style.left = '0';
                iframe.style.zIndex = '2147483646'; iframe.style.background = '#000'; iframe.style.display = 'block';
                iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen';
                iframe.setAttribute('allowfullscreen', ''); iframe.setAttribute('webkitallowfullscreen', ''); iframe.setAttribute('mozallowfullscreen', '');
                // Ensure native video is hidden behind iframe
                try { const vid = document.getElementById('videoPlayer') || document.getElementById('video'); if (vid) { vid.style.display = 'none'; vid.style.zIndex = '0'; } } catch(e) {}
                container.appendChild(iframe);

                // Small helper: try a set of proxy endpoints and return first OK
                async function findWorkingProxy(embedUrl){
                    const candidates = [
                        `/api/proxy/video?url=${encodeURIComponent(embedUrl)}&provider=nontongo&clean=1&autoplay=1`,
                        `${location.origin}/api/proxy/video?url=${encodeURIComponent(embedUrl)}&provider=nontongo&clean=1&autoplay=1`,
                        `http://127.0.0.1:5502/api/proxy/video?url=${encodeURIComponent(embedUrl)}&provider=nontongo&clean=1&autoplay=1`,
                        `http://localhost:5502/api/proxy/video?url=${encodeURIComponent(embedUrl)}&provider=nontongo&clean=1&autoplay=1`,
                        `http://127.0.0.1:3001/api/proxy/video?url=${encodeURIComponent(embedUrl)}&provider=nontongo&clean=1&autoplay=1`,
                        `http://localhost:3001/api/proxy/video?url=${encodeURIComponent(embedUrl)}&provider=nontongo&clean=1&autoplay=1`
                    ];
                    for(const c of candidates){
                        try{
                            appendDev('Testing proxy candidate: ' + c);
                            const r = await fetch(c, { method: 'GET', cache: 'no-store' });
                            if (r && r.ok) { appendDev('Proxy candidate OK: ' + c); return c; }
                            appendDev('Proxy candidate non-ok (' + (r && r.status) + '): ' + c, 'warn');
                        }catch(e){ appendDev('Proxy candidate failed: ' + (e && e.message ? e.message : e) + ' -> ' + c, 'warn'); }
                    }
                    return null;
                }

                // Attempt to trigger playback inside the embed (postMessage + same-origin tries)
                setTimeout(() => {
                    try { iframe.contentWindow && iframe.contentWindow.postMessage({ type: 'cinema_play' }, '*'); } catch(e) { }
                    try {
                        const doc = iframe.contentDocument || (iframe.contentWindow && iframe.contentWindow.document);
                        if (doc) {
                            const v = doc.querySelector('video');
                            if (v) { try { v.muted = true; v.play().catch(()=>{}); } catch(e) {} }
                            const btn = doc.querySelector('button.play, .play-button, .btn-play, #play');
                            if (btn) try { btn.click(); } catch(e) {}
                        }
                    } catch(e) { }
                }, 500);

                // In parallel: probe the proxied cleaned embed HTML for direct streams (m3u8/mp4) or nested iframe and switch to them if found
                (async function(){
                    try {
                        appendDev('Probing proxied cleaned embed for direct streams...');

                        // Try to find a working proxy endpoint first (handles different dev host/ports)
                        const workingProxy = await findWorkingProxy(embedUrl);
                        if (!workingProxy) {
                            appendDev('No working proxy found - falling back to remote embed: ' + embedUrl, 'warn');
                            try { iframe.src = embedUrl; } catch (e) { console.warn('Fallback set iframe.src failed', e); }
                            return;
                        }

                        appendDev('Using proxy for probe: ' + workingProxy);
                        try { iframe.src = workingProxy; iframe.style.zIndex = '2147483646'; iframe.style.background = '#000'; iframe.style.display = 'block'; const vid = document.getElementById('videoPlayer') || document.getElementById('video'); if (vid) { vid.style.display = 'none'; vid.style.zIndex = '0'; } } catch(e) { console.warn('Setting iframe src to working proxy failed', e); }
                        const probeResp = await fetch(workingProxy, { cache: 'no-store' });
                        if (!probeResp.ok) {
                            appendDev('Probe returned non-ok: ' + probeResp.status, 'warn');
                            appendDev('Falling back to remote embed: ' + embedUrl, 'warn');
                            try { iframe.src = embedUrl; } catch (e) { console.warn('Fallback set iframe.src failed', e); }
                            return;
                        }
                        const txt = await probeResp.text();

                        // HLS
                        const m = txt.match(/https?:\/\/[^"'()\s]+\.m3u8[^"'()\s]*/i);
                        if (m && m[0]) {
                            const manifest = m[0];
                            const proxManifest = `/api/hls-proxy?type=manifest&url=${encodeURIComponent(manifest)}&referer=${encodeURIComponent(embedUrl)}`;
                            appendDev && appendDev('Found HLS manifest in cleaned embed: ' + manifest);
                            // switch to HLS playback
                            window.videoSrc = proxManifest;
                            window.sourceType = 'hls';
                            try { initVideo(); } catch(e) { console.warn('initVideo failed after HLS probe', e); }
                            return;
                        }

                        // MP4
                        const mp4 = txt.match(/https?:\/\/[^"'()\s]+\.mp4[^"'()\s]*/i);
                        if (mp4 && mp4[0]) {
                            const file = mp4[0];
                            const proxFile = `/api/proxy/video?url=${encodeURIComponent(file)}&provider=nontongo`;
                            appendDev && appendDev('Found MP4 in cleaned embed: ' + file);
                            window.videoSrc = proxFile;
                            window.sourceType = 'mp4';
                            try { initVideo(); } catch(e) { console.warn('initVideo failed after MP4 probe', e); }
                            return;
                        }

                        // Nested iframe
                        const iframeMatch = txt.match(/<iframe[^>]+src=["']([^"']+)["']/i);
                        if (iframeMatch && iframeMatch[1]) {
                            const nested = iframeMatch[1];
                            const proxNested = nested && nested.startsWith('http') ? `/api/proxy/video?url=${encodeURIComponent(nested)}&provider=nontongo&clean=1&autoplay=1` : nested;
                            appendDev && appendDev('Found nested iframe in cleaned embed: ' + nested + ' -> ' + proxNested);
                            iframe.src = proxNested;
                            return;
                        }

                        appendDev('No direct streams found in cleaned embed');
                        try { iframe.style.display = 'block'; iframe.style.zIndex = '2147483646'; iframe.style.background = '#000'; const vid = document.getElementById('videoPlayer') || document.getElementById('video'); if (vid) { vid.style.display = 'none'; vid.style.zIndex = '0'; } } catch(e) {}
                    } catch (err) {
                        appendDev('Cleaned embed probe error: ' + (err && err.message ? err.message : err), 'error');
                        // On probe exception (proxy unreachable etc) fall back to remote embed and show error
                        try { appendDev('Probe exception — falling back to remote embed: ' + embedUrl, 'warn'); iframe.src = embedUrl; showEmbedError('Embed probe failed — showing remote embed, playback may require interaction'); } catch (e) { console.warn('Fallback set iframe.src failed', e); }
                    }
                })();

                // Remove any start overlay if present
                const startOv = document.getElementById('player2StartOverlay'); if (startOv && startOv.remove) startOv.remove();

            } catch (err) { console.warn('openNontonGoEmbed error:', err); }
        };

        // Show a small overlay with an error message when embed fails
        function showEmbedError(message){
            try{
                let e = document.getElementById('embedErrorOverlay');
                if (!e){
                    e = document.createElement('div');
                    e.id = 'embedErrorOverlay';
                    e.style.cssText = 'position:fixed; left:20px; right:20px; bottom:20px; padding:12px 16px; background:rgba(255,40,40,0.95); color:#fff; border-radius:8px; z-index:2147483647; font-weight:600;';
                    document.body.appendChild(e);
                }
                e.textContent = message;
                setTimeout(()=>{ try{ e.remove(); }catch(e){} }, 8000);
            }catch(e){ console.warn('showEmbedError failed', e); }
        }
    </script>
</body>
</html>