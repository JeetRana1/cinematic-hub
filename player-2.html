<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Watching | StreamVerse</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;700;800&family=Sora:wght@400;500;600;700&display=swap">
    <link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <style>
        :root {
            --accent: #e50914;
            --accent-strong: #ff1f3d;
            --accent-glow: rgba(229, 9, 20, 0.35);
            --ink-strong: #f5f6f8;
            --ink-soft: rgba(245, 246, 248, 0.72);
            --ink-muted: rgba(245, 246, 248, 0.48);
            --surface: #0b0c10;
            --surface-deep: #050607;
            --surface-glass: rgba(13, 14, 19, 0.7);
            --surface-border: rgba(255, 255, 255, 0.08);
            --transition: 220ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Global Reset */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            overflow-x: hidden;
            width: 100%;
            overflow-y: hidden;
        }

        body {
            background: #050607;
            height: 100vh;
            width: 100vw;
            position: relative;
            overflow: hidden;
            margin: 0;
            padding: 0;
            font-family: 'Sora', sans-serif;
            color: var(--ink-strong);
        }

        /* Ensure all children don't cause overflow */
        body>* {
            max-width: 100vw;
            overflow-x: hidden;
        }

        html {
            overflow-x: hidden;
            width: 100%;
            overflow-y: hidden;
            margin: 0;
            padding: 0;
        }

        html,
        body {
            height: 100%;
            max-height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
            touch-action: none;
            margin: 0;
            padding: 0;
        }

        /* Allow content to extend into notch/rounded corners */
        @supports (padding: env(safe-area-inset-left)) {

            html,
            body {
                width: 100vw;
                height: 100vh;
            }

            .player-container,
            .plyr,
            .plyr__video-wrapper,
            video {
                position: fixed;
                top: 0;
                left: calc(0px - env(safe-area-inset-left));
                right: calc(0px - env(safe-area-inset-right));
                bottom: 0;
                width: calc(100vw + env(safe-area-inset-left) + env(safe-area-inset-right));
                height: 100vh;
            }
        }

        /* Loading Screen */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--surface-deep);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loader-logo {
            font-family: 'Outfit', sans-serif;
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 2rem;
            letter-spacing: -1px;
        }

        .loader-logo span {
            color: var(--accent);
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-strong) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.08);
            border-top: 3px solid var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .player-header {
            padding: 1.2rem 2.5rem;
            background: linear-gradient(to bottom, rgba(2, 3, 6, 0.9), rgba(2, 3, 6, 0));
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 2rem;
            pointer-events: none;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .player-header.hidden {
            transform: translateY(-100%);
        }

        .player-header>* {
            pointer-events: auto;
        }

        .back-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--surface-border);
            color: white;
            padding: 0.8rem;
            border-radius: 50%;
            cursor: pointer;
            transition: var(--transition);
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .back-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            transform: scale(1.1);
            box-shadow: 0 0 18px var(--accent-glow);
        }

        .back-btn:active,
        .back-btn:focus-visible {
            background: var(--accent-strong);
            border-color: var(--accent-strong);
            color: #000;
        }

        .player-title-info h2 {
            font-family: 'Outfit', sans-serif;
            font-size: 1.4rem;
            margin: 0;
            font-weight: 700;
            letter-spacing: 0.2px;
            text-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
        }

        .player-title-info p {
            margin: 0;
            font-size: 0.85rem;
            color: var(--ink-muted);
            text-shadow: 0 1px 8px rgba(0, 0, 0, 0.6);
        }

        .player-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: none;
            z-index: 0;
            background: #000;
            overflow: hidden;
        }

        /* Prefer dynamic viewport units on mobile browsers */
        @supports (width: 100dvw) {

            .player-container,
            .plyr,
            .plyr__video-wrapper,
            video {
                width: 100dvw;
                height: 100dvh;
            }
        }

        @media (max-width: 768px) {
            .player-container {
                width: 100vw;
                left: 0;
            }
        }

        /* Plyr Customization */
        .plyr {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            max-width: none;
            --plyr-color-main: var(--accent);
            --plyr-video-background: #000;
            --plyr-menu-background: var(--surface-glass);
            --plyr-menu-color: #fff;
        }

        .plyr--full-ui input[type=range] {
            color: var(--accent);
        }

        .plyr__control--overlaid {
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.18), rgba(255, 255, 255, 0.04));
            border: 1px solid rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(8px);
            transform: scale(1.05);
        }

        .plyr__control--overlaid:hover {
            background: var(--accent);
            border-color: var(--accent);
            box-shadow: 0 0 18px var(--accent-glow);
        }

        .plyr--video .plyr__controls {
            background: linear-gradient(180deg, rgba(4, 6, 9, 0) 0%, rgba(4, 6, 9, 0.65) 45%, rgba(4, 6, 9, 0.88) 100%);
            padding: 18px 24px 22px;
            gap: 10px;
        }

        .plyr--video .plyr__controls .plyr__control {
            border-radius: 12px;
            transition: var(--transition);
        }

        .plyr--video .plyr__controls .plyr__control:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .plyr__progress input[type=range] {
            height: 4px;
        }

        .plyr__progress__buffer,
        .plyr__progress--played {
            border-radius: 999px;
        }

        .plyr__time {
            color: var(--ink-soft);
            font-weight: 500;
        }

        .plyr__volume input[type=range] {
            color: var(--accent);
        }

        /* Hide Plyr native controls (we use custom controls) */
        .plyr__controls,
        .plyr__control--overlaid,
        .plyr__progress,
        .plyr__time,
        .plyr__volume,
        .plyr__menu {
            display: none !important;
        }

        .control-surface {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 0 4vw 2vh;
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transition: opacity var(--transition);
            background: transparent;
        }

        .control-bottom {
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .control-surface.visible {
            opacity: 1;
        }

        .control-center {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: min(80vw, 560px);
            margin: 0 auto;
            flex: 1;
            transform: translateY(4vh);
        }

        .control-center .ctrl-btn:first-child {
            transform: none;
        }

        .control-center .ctrl-btn:last-child {
            transform: none;
        }

        .ctrl-btn {
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(20, 22, 30, 0.6);
            color: var(--ink-strong);
            border-radius: 999px;
            width: 64px;
            height: 64px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 18px;
            cursor: pointer;
            transition: var(--transition);
            backdrop-filter: blur(10px);
        }

        .ctrl-btn span {
            font-size: 14px;
            font-weight: 600;
        }

        .ctrl-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 22px var(--accent-glow);
        }

        .ctrl-btn:active,
        .ctrl-btn:focus-visible {
            background: var(--accent-strong);
            border-color: var(--accent-strong);
            color: #000;
        }

        .play-btn {
            width: 84px;
            height: 84px;
            font-size: 26px;
        }

        .control-bottom {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            pointer-events: auto;
            padding: 0 0.5rem;
        }

        .time-readout {
            display: flex;
            align-items: baseline;
            gap: 0.35rem;
            font-size: 0.9rem;
            color: var(--ink-soft);
            min-width: 90px;
        }

        .time-divider {
            color: var(--ink-muted);
        }

        .seek-bar {
            flex: 1;
            appearance: none;
            height: 5px;
            border-radius: 999px;
            background: linear-gradient(to right, var(--accent) 0%, var(--accent) var(--seek-percent, 0%), rgba(255, 255, 255, 0.15) var(--seek-percent, 0%), rgba(255, 255, 255, 0.15) 100%);
            outline: none;
            cursor: pointer;
            touch-action: none;
        }

        .seek-bar::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
            border: none;
        }

        .seek-bar::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            border: none;
        }

        .control-actions {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .ctrl-icon {
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(20, 22, 30, 0.6);
            color: var(--ink-strong);
            border-radius: 12px;
            width: 44px;
            height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            backdrop-filter: blur(10px);
        }

        .ctrl-icon:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        .ctrl-icon:active,
        .ctrl-icon:focus-visible {
            background: var(--accent-strong);
            border-color: var(--accent-strong);
            color: #000;
        }

        .ui-lock-btn {
            position: fixed;
            top: calc(28px + env(safe-area-inset-top));
            right: calc(52px + env(safe-area-inset-right));
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.22);
            background: rgba(20, 22, 30, 0.72);
            color: var(--ink-strong);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            cursor: pointer;
            z-index: 3000;
            transition: var(--transition);
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .ui-lock-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        .ui-lock-btn:active,
        .ui-lock-btn:focus-visible {
            background: var(--accent-strong);
            border-color: var(--accent-strong);
            color: #000;
        }

        .ui-lock-btn.locked {
            border-color: rgba(229, 9, 20, 0.65);
            box-shadow: 0 0 14px rgba(229, 9, 20, 0.25);
        }

        /* Keep lock button visible in fullscreen (backdrop-filter can render transparent on some browsers) */
        .player-container:fullscreen .ui-lock-btn,
        .player-container:-webkit-full-screen .ui-lock-btn,
        :fullscreen .ui-lock-btn,
        :-webkit-full-screen .ui-lock-btn {
            opacity: 1 !important;
            visibility: visible !important;
            display: inline-flex !important;
            pointer-events: auto !important;
            z-index: 2147483647 !important;
            color: #fff !important;
            background: rgba(12, 14, 20, 0.92) !important;
            border-color: rgba(255, 255, 255, 0.35) !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        body.ui-locked .player-header,
        body.ui-locked .control-surface,
        body.ui-locked #pause-info,
        body.ui-locked .audio-menu,
        body.ui-locked .episode-menu,
        body.ui-locked .quality-menu,
        body.ui-locked .volume-menu,
        body.ui-locked .settings-menu,
        body.ui-locked .speed-menu {
            opacity: 0 !important;
            pointer-events: none !important;
            visibility: hidden !important;
        }

        body.ui-locked .ui-lock-btn {
            opacity: 1 !important;
            visibility: visible !important;
            display: inline-flex !important;
            pointer-events: auto !important;
            z-index: 2147483647 !important;
        }

        .control-surface.hidden {
            opacity: 0;
        }

        .plyr__video-wrapper {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            max-width: none;
        }

        video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: none;
            object-fit: var(--video-fit, cover);
            object-position: center;
        }

        /* Ensure fullscreen fills the entire display (especially mobile landscape) */
        :fullscreen .plyr,
        :fullscreen .plyr__video-wrapper,
        :fullscreen video {
            width: 100% !important;
            height: 100% !important;
            object-fit: var(--video-fit, cover);
            object-position: center center;
        }

        /* Error Message UI */
        .error-message {
            color: #ff6b6b;
            text-align: center;
            display: none;
            z-index: 100;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--surface-glass);
            padding: 2rem 2.25rem;
            border-radius: 20px;
            border: 1px solid var(--surface-border);
            backdrop-filter: blur(20px);
            max-width: 360px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .error-message i {
            font-size: 3rem;
            margin-bottom: 1.5rem;
        }

        /* Custom Menus */
        .audio-menu,
        .episode-menu,
        .quality-menu,
        .volume-menu,
        .settings-menu,
        .speed-menu {
            position: fixed;
            bottom: 80px;
            background: var(--surface-glass);
            border-radius: 12px;
            padding: 10px;
            display: none;
            flex-direction: column;
            width: 280px;
            z-index: 90;
            border: 1px solid var(--surface-border);
            backdrop-filter: blur(20px);
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
            pointer-events: auto;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .audio-menu.active,
        .episode-menu.active,
        .quality-menu.active,
        .volume-menu.active,
        .settings-menu.active,
        .speed-menu.active {
            display: flex;
        }

        .audio-menu {
            right: 20px;
            width: 200px;
        }

        .episode-menu {
            right: 80px;
        }

        .quality-menu {
            right: 140px;
            width: 180px;
            bottom: 96px;
        }

        .volume-menu {
            width: 220px;
        }

        .settings-menu,
        .speed-menu {
            width: 220px;
        }

        .settings-title {
            font-size: 0.85rem;
            color: var(--ink-muted);
            letter-spacing: 0.06em;
            text-transform: uppercase;
            padding: 6px 10px 10px;
        }

        .speed-list {
            display: none;
            flex-direction: column;
            opacity: 0;
            transform: translateY(-6px);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .speed-list.active {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }

        .volume-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 6px 8px;
        }

        .volume-slider {
            flex: 1;
            appearance: none;
            height: 5px;
            border-radius: 999px;
            background: linear-gradient(to right, var(--accent) 0%, var(--accent) var(--vol-percent, 100%), rgba(255, 255, 255, 0.15) var(--vol-percent, 100%), rgba(255, 255, 255, 0.15) 100%);
            outline: none;
            cursor: pointer;
            touch-action: none;
        }

        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
            border: none;
        }

        .volume-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent);
            border: none;
        }

        .volume-toggle {
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(20, 22, 30, 0.6);
            color: var(--ink-strong);
            border-radius: 10px;
            width: 34px;
            height: 34px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            backdrop-filter: blur(10px);
        }

        .volume-toggle:hover,
        .volume-toggle:active,
        .volume-toggle:focus-visible {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        .audio-item,
        .episode-item,
        .quality-item,
        .settings-item,
        .speed-item {
            padding: 12px 15px;
            color: var(--ink-muted);
            cursor: pointer;
            font-size: 0.9rem;
            transition: var(--transition);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }

        .audio-item:hover,
        .episode-item:hover,
        .quality-item:hover,
        .settings-item:hover,
        .speed-item:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            padding-left: 20px;
        }

        .audio-item.selected,
        .episode-item.selected,
        .quality-item.selected,
        .speed-item.selected {
            background: rgba(229, 9, 20, 0.2);
            color: var(--accent);
            font-weight: 600;
            border-left: 3px solid var(--accent);
        }

        .season-title {
            color: var(--accent);
            font-size: 0.8rem;
            margin: 15px 0 8px 10px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Info Overlay on Pause */
        #pause-info {
            position: fixed;
            bottom: clamp(150px, 16vh, 220px);
            left: clamp(20px, 4vw, 60px);
            max-width: min(62vw, 720px);
            z-index: 120;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(8px);
            display: flex;
            align-items: flex-end;
            gap: 18px;
        }

        .plyr--paused~#pause-info {
            opacity: 1;
            transform: translateY(0);
        }

        .pause-poster {
            width: 140px;
            height: 200px;
            border-radius: 12px;
            object-fit: cover;
            box-shadow: 0 22px 44px rgba(0, 0, 0, 0.55);
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.2);
            filter: saturate(1.08) contrast(1.06);
        }

        .pause-content h1 {
            font-family: 'Outfit', sans-serif;
            font-size: clamp(1.8rem, 3.4vw, 3.4rem);
            margin-bottom: 0.5rem;
            letter-spacing: 0.6px;
            text-shadow: 0 12px 32px rgba(0, 0, 0, 0.75);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pause-description {
            font-size: clamp(0.9rem, 1.2vw, 1.05rem);
            color: rgba(255, 255, 255, 0.95);
            line-height: 1.5;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Hide controls overlay */
        .plyr--hide-controls .plyr__controls {
            opacity: 0;
            pointer-events: none;
        }

        .plyr--hide-controls .plyr__control--overlaid {
            opacity: 0;
            pointer-events: none;
        }

        .plyr--hide-controls .plyr__controls button,
        .plyr--hide-controls .plyr__controls input,
        .plyr--hide-controls .plyr__controls progress {
            pointer-events: none;
        }

        /* Smooth transitions for control hiding */
        .plyr__controls {
            transition: opacity 0.3s ease;
        }

        .plyr__control--overlaid {
            transition: opacity 0.3s ease;
        }

        /* Mobile */
        @media (max-width: 768px) {
            .player-title-info {
                display: none;
            }

            .player-header {
                padding: 0.8rem 1rem;
            }

            .back-btn {
                width: 40px;
                height: 40px;
                padding: 0.6rem;
                flex-shrink: 0;
            }

            .episode-menu {
                right: 20px;
                width: calc(100% - 40px);
                bottom: 100px;
            }

            #pause-info {
                left: 16px;
                right: 16px;
                bottom: calc(70px + env(safe-area-inset-bottom));
                max-width: none;
                gap: 14px;
            }

            .pause-content h1 {
                font-size: clamp(1.4rem, 5vw, 2rem);
            }

            .pause-poster {
                width: 96px;
                height: 140px;
            }

            .control-surface {
                padding: 0 4vw calc(2vh + env(safe-area-inset-bottom));
            }

            .control-center {
                width: min(88vw, 420px);
                transform: translateY(2vh);
                gap: 2.2rem;
            }

            .ctrl-btn {
                width: 54px;
                height: 54px;
                font-size: 16px;
            }

            .play-btn {
                width: 72px;
                height: 72px;
                font-size: 22px;
            }

            .control-bottom {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .time-readout {
                min-width: 76px;
                font-size: 0.8rem;
            }

            .seek-bar {
                min-width: 100%;
                order: 3;
            }

            .control-actions {
                flex-wrap: wrap;
                gap: 0.35rem;
                order: 4;
            }

            .ctrl-icon {
                width: 40px;
                height: 40px;
            }
        }

        @media (max-width: 480px) {
            .control-center {
                width: min(92vw, 360px);
                gap: 1.6rem;
            }

            .ctrl-btn {
                width: 48px;
                height: 48px;
            }

            .play-btn {
                width: 64px;
                height: 64px;
            }
        }

        @media (max-width: 480px) and (orientation: portrait) {
            .control-surface {
                padding-bottom: 0;
            }

            .control-center {
                transform: translateY(6vh);
            }

            .control-actions {
                padding-bottom: 0;
                margin-bottom: 0;
            }
        }

        @media (orientation: landscape) and (max-width: 1024px) {
            .control-center {
                transform: translateY(4vh);
            }

            #pause-info {
                left: 50% !important;
                transform: translateX(-50%) !important;
                right: auto !important;
                bottom: calc(60px + env(safe-area-inset-bottom)) !important;
                max-width: min(80vw, 600px) !important;
                text-align: center;
                justify-content: center;
            }

            .pause-poster {
                display: none;
            }
        }

        @media (max-width: 800px) and (max-height: 1100px) {
            .control-center {
                transform: translateY(4vh);
            }
        }
    </style>
</head>

<body>
    <div id="loader">
        <div class="loader-logo"><span class="logo-accent">Cinematic</span>Hub</div>
        <div class="spinner"></div>
    </div>

    <div class="player-header">
        <button class="back-btn" onclick="window.location.href='index.html'">
            <i class="fa-solid fa-arrow-left"></i>
        </button>
        <div class="player-title-info">
            <h2 id="media-title">Loading...</h2>
            <p id="media-meta"></p>
        </div>
    </div>

    <div class="player-container">
        <video id="player" autoplay playsinline></video>
        <div class="control-surface" id="controlSurface">
            <div class="control-center">
                <button class="ctrl-btn" id="skipBackBtn" aria-label="Skip back 10 seconds">
                    <i class="fa-solid fa-rotate-left"></i><span>10</span>
                </button>
                <button class="ctrl-btn play-btn" id="playPauseBtn" aria-label="Play or pause">
                    <i class="fa-solid fa-play"></i>
                </button>
                <button class="ctrl-btn" id="skipFwdBtn" aria-label="Skip forward 10 seconds">
                    <span>10</span><i class="fa-solid fa-rotate-right"></i>
                </button>
            </div>
            <div class="control-bottom">
                <div class="time-readout">
                    <span id="currentTime">0:00</span>
                    <span class="time-divider">/</span>
                    <span id="durationTime">0:00</span>
                </div>
                <input id="seekBar" class="seek-bar" type="range" min="0" max="100" step="0.1" value="0" />
                <div class="control-actions">
                    <button class="ctrl-icon" id="custom-audio-btn" aria-label="Audio">
                        <i class="fa-solid fa-language"></i>
                    </button>
                    <button class="ctrl-icon" id="qualityBtn" aria-label="Quality">
                        <i class="fa-solid fa-signal"></i>
                    </button>
                    <button class="ctrl-icon" id="settingsBtn" aria-label="Settings">
                        <i class="fa-solid fa-gear"></i>
                    </button>
                    <button class="ctrl-icon" id="fitBtn" aria-label="Screen Fit">
                        <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
                    </button>
                    <button class="ctrl-icon" id="muteBtn" aria-label="Mute">
                        <i class="fa-solid fa-volume-high"></i>
                    </button>
                    <button class="ctrl-icon" id="fullscreenBtn" aria-label="Fullscreen">
                        <i class="fa-solid fa-expand"></i>
                    </button>
                </div>
            </div>
        </div>
        <div id="pause-info">
            <img id="pause-poster" class="pause-poster" alt="Poster">
            <div class="pause-content">
                <h1 id="pause-title">Title</h1>
                <p class="pause-description" id="pause-desc">Description</p>
            </div>
        </div>
        <div id="error-msg" class="error-message">
            <i class="fa-solid fa-circle-exclamation"></i>
            <h3>Stream Unavailable</h3>
            <p>Could not retrieve stream from the API server.</p>
        </div>
        <button class="ui-lock-btn" id="uiLockBtn" aria-label="Lock controls">
            <i class="fa-solid fa-lock-open"></i>
        </button>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="public/firebaseConfig.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="auth-firebase.js?v=3"></script>
    <script src="firebase-sync.js"></script>
    <script src="js/continue-watching.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hls.js/1.4.12/hls.min.js"></script>
    <script src="https://cdn.plyr.io/3.7.8/plyr.js"></script>
    <script>
        // Disable page scrolling on load (especially on mobile)
        document.addEventListener('touchmove', function (e) {
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('wheel', function (e) {
            e.preventDefault();
        }, { passive: false });

        const API_KEY = 'f647c22a49beb48e62a859804d39a43f';
        const LOCAL_API_URL = 'https://convinced-nara-personal122-7da52759.koyeb.app/api/v1';
        const ALLOW_IFRAME_FALLBACK = false;

        // Suppress known non-app noise from injected scripts/extensions and transient blob teardown races.
        (function suppressKnownConsoleNoise() {
            const isMfParamsError = (message, source, stack) => {
                const msg = String(message || '');
                const src = String(source || '');
                const st = String(stack || '');
                return msg.includes('Params are not set') && (src.includes('mf.js') || st.includes('mf.js'));
            };

            window.addEventListener('unhandledrejection', (event) => {
                const reason = event && event.reason;
                const message = reason && reason.message ? reason.message : reason;
                const stack = reason && reason.stack ? reason.stack : '';
                if (isMfParamsError(message, '', stack)) {
                    event.preventDefault();
                }
            });

            window.onerror = function (message, source, lineno, colno, error) {
                if (isMfParamsError(message, source, error && error.stack)) {
                    return true;
                }
                return false;
            };

            window.addEventListener('error', (event) => {
                const target = event && event.target;
                if (target && target.tagName === 'VIDEO') {
                    const currentSrc = String(target.currentSrc || '');
                    if (currentSrc.startsWith('blob:')) {
                        event.preventDefault();
                    }
                }
            }, true);
        })();

        const urlParams = new URLSearchParams(window.location.search);
        const id = urlParams.get('id');
        const requestedResumeTime = Number.parseInt(
            urlParams.get('t') || urlParams.get('time') || urlParams.get('start') || '0',
            10
        );
        const initialResumeTime = resolveInitialResumeTime();
        let initialResumeApplied = false;
        const requestedType = (urlParams.get('mediaType') || urlParams.get('type') || 'movie').toLowerCase();
        const type = requestedType === 'tv' || requestedType === 'series' ? 'tv' : 'movie';

        const video = document.getElementById('player');
        const errorMsg = document.getElementById('error-msg');
        const loader = document.getElementById('loader');
        const header = document.querySelector('.player-header');

        let player;
        let globalPlaylist = [];
        let globalKey = '';
        let currentAudioIndex = 0;
        let hls;
        let hideHeaderTimeout;
        let placeholderStream = null;
        let placeholderAnimationId = null;
        let useHlsAudioTracks = false;
        let isTestStream = false;
        let qualityMenuContainer;
        let availableQualities = [];
        let qualityMenuDocListenerAdded = false;
        let qualityBtnListenerAdded = false;
        let selectedQualityLabel = 'Auto';
        let fallbackTestStreamTried = false;
        let manualQualitySelection = false;
        let rebufferEvents = [];
        let temporaryQualityCapTimer = null;
        let isUiLocked = false;
        let volumeMenuContainer;
        let volumeMenuDocListenerAdded = false;
        let volumeSliderEl = null;
        let volumeToggleEl = null;
        let settingsMenuContainer;
        let speedMenuContainer;
        let settingsMenuDocListenerAdded = false;
        let speedMenuDocListenerAdded = false;

        const TEST_MULTI_AUDIO_HLS_SOURCES = [
            'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8',
            'https://bitdash-a.akamaihd.net/content/sintel/hls/playlist.m3u8',
            'https://demo.unified-streaming.com/k8s/features/stable/video/tears-of-steel/tears-of-steel.ism/.m3u8'
        ];
        let currentTestStreamIndex = 0;

        // TV Series State
        let isTv = false;
        let tvData = [];
        let currentSeasonIndex = 0;
        let currentEpisodeIndex = 0;
        let resolvedImdbId = null;

        let audioMenuContainer;
        let audioMenuDocListenerAdded = false;
        let episodeMenuContainer;
        const STREAM_CACHE_STORAGE_KEY = 'cinematichub_stream_cache_v1';
        const STREAM_CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000; // 7 days
        const streamCache = new Map();
        let manifestRecoveryInProgress = false;
        let manifestRecoveryAttempts = 0;

        function getStreamCacheKey(imdbId, trackIndex = 0) {
            return `${imdbId || 'unknown'}::${trackIndex}`;
        }

        function getCurrentTestStream() {
            if (!Array.isArray(TEST_MULTI_AUDIO_HLS_SOURCES) || TEST_MULTI_AUDIO_HLS_SOURCES.length === 0) return '';
            const idx = Math.max(0, Math.min(currentTestStreamIndex, TEST_MULTI_AUDIO_HLS_SOURCES.length - 1));
            return TEST_MULTI_AUDIO_HLS_SOURCES[idx];
        }

        async function fetchImdbId(tmdbId, mediaType = null) {
            try {
                if (!tmdbId) return null;
                const typeHint = mediaType || urlParams.get('mediaType') || type || 'movie';
                const endpoint = typeHint === 'tv' ? 'tv' : 'movie';
                const tmdbUrl = `https://api.themoviedb.org/3/${endpoint}/${encodeURIComponent(tmdbId)}?api_key=${API_KEY}&append_to_response=external_ids`;
                const res = await fetch(tmdbUrl);
                if (!res.ok) return null;
                const data = await res.json();
                return data?.external_ids?.imdb_id || data?.imdb_id || null;
            } catch (_) {
                return null;
            }
        }

        async function playFromLocalApi(imdbId) {
            try {
                console.log(`ðŸŽ¬ Fetching MediaInfo for ${imdbId}...`);
                const infoUrl = `${LOCAL_API_URL}/mediaInfo?id=${encodeURIComponent(imdbId)}`;
                console.log('ðŸ”— MediaInfo URL:', infoUrl);

                const infoRes = await fetch(infoUrl);
                console.log('ðŸ“Š MediaInfo response status:', infoRes.status);
                if (!infoRes.ok) throw new Error(`mediaInfo failed: ${infoRes.status}`);

                const infoJson = await infoRes.json();
                console.log('ðŸ“‹ MediaInfo response:', infoJson);
                const payload = infoJson?.data || infoJson;
                const playlist = Array.isArray(payload?.playlist) ? payload.playlist : [];
                const key = payload?.key || '';

                if (!playlist.length || !key) {
                    throw new Error('Invalid mediaInfo payload');
                }

                globalPlaylist = playlist;
                globalKey = key;
                console.log(`ðŸŽµ Playlist found: ${playlist.length} items`);

                // Prefer English first, otherwise fallback to the first playable item.
                let initialTrackIndex = playlist.findIndex((t) => String(t?.title || '').toLowerCase() === 'english');
                if (initialTrackIndex < 0) initialTrackIndex = playlist.findIndex((t) => typeof t?.file === 'string' && t.file.length > 0);
                if (initialTrackIndex < 0) initialTrackIndex = 0;

                console.log('âš¡ Starting immediate audio track load...');
                await loadAudioTrack(initialTrackIndex);
            } catch (error) {
                console.error('playFromLocalApi failed:', error);
                showError(`Failed to load stream info: ${error.message}`);
            }
        }

        function getConservativeStartupLevel() {
            if (!hls || !Array.isArray(hls.levels) || hls.levels.length === 0) return -1;
            const sorted = hls.levels
                .map((level, index) => ({ index, bitrate: Number(level.bitrate) || 0, height: Number(level.height) || 0 }))
                .sort((a, b) => a.bitrate - b.bitrate);
            const preferred = sorted.find((entry) => entry.bitrate >= 700000 && entry.bitrate <= 1400000);
            if (preferred) return preferred.index;
            const fallback = sorted[Math.min(1, sorted.length - 1)];
            return fallback ? fallback.index : -1;
        }

        function getLowerLevelIndex(currentLevelIndex) {
            if (!hls || !Array.isArray(hls.levels) || hls.levels.length === 0) return -1;
            const current = hls.levels[currentLevelIndex];
            if (!current) return 0;
            const currentBitrate = Number(current.bitrate) || Number.MAX_SAFE_INTEGER;
            let candidate = -1;
            for (let i = 0; i < hls.levels.length; i += 1) {
                const level = hls.levels[i];
                const bitrate = Number(level.bitrate) || 0;
                if (bitrate < currentBitrate) candidate = i;
            }
            return candidate === -1 ? 0 : candidate;
        }

        function applyTemporaryQualityCap() {
            if (!hls || manualQualitySelection || !Array.isArray(hls.levels) || hls.levels.length === 0) return;

            const currentLevel = hls.currentLevel >= 0 ? hls.currentLevel : hls.nextAutoLevel;
            const lowerLevel = getLowerLevelIndex(currentLevel >= 0 ? currentLevel : hls.levels.length - 1);
            if (lowerLevel < 0) return;

            hls.autoLevelCapping = lowerLevel;
            console.log(`âš ï¸ Rebuffer detected - temporary quality cap at ${hls.levels[lowerLevel]?.height || 'low'}p`);

            if (temporaryQualityCapTimer) clearTimeout(temporaryQualityCapTimer);
            temporaryQualityCapTimer = setTimeout(() => {
                if (!hls || manualQualitySelection) return;
                hls.autoLevelCapping = -1;
                console.log('âœ… Removed temporary quality cap, back to full auto range');
            }, 45000);
        }

        function noteRebufferEvent() {
            const now = Date.now();
            rebufferEvents = rebufferEvents.filter((t) => now - t < 45000);
            rebufferEvents.push(now);
            if (rebufferEvents.length >= 2) {
                applyTemporaryQualityCap();
                rebufferEvents = [];
            }
        }

        async function init() {
            if (!id) return;
            if (video) video.controls = false;
            loadPersistedStreamCache();

            // Start loading immediately - don't wait for timeout
            console.log('ðŸš€ Initializing player...');

            try {
                // 1. Get TMDB Info - use parallel loading
                console.log('ðŸ“¡ Fetching TMDB data...');
                const [tmdbRes] = await Promise.all([
                    fetch(`https://api.themoviedb.org/3/${type}/${id}?api_key=${API_KEY}&append_to_response=external_ids`)
                ]);

                const data = await tmdbRes.json();
                const title = data.title || data.name;
                const imdbId = data.external_ids?.imdb_id;
                resolvedImdbId = imdbId || null;
                const posterPath = data.poster_path;

                // Update UI immediately
                document.getElementById('media-title').innerText = title;
                document.title = `Watching: ${title} | Cinematic Hub`;
                document.getElementById('pause-title').innerText = title;
                document.getElementById('pause-desc').innerText = data.overview || '';
                const posterEl = document.getElementById('pause-poster');
                if (posterEl && posterPath) {
                    posterEl.src = `https://image.tmdb.org/t/p/w342${posterPath}`;
                    posterEl.style.display = 'block';
                } else if (posterEl) {
                    posterEl.style.display = 'none';
                }
                document.getElementById('media-meta').innerText = type === 'movie' ? 'Movie' : 'TV Series';

                console.log(`âœ… TMDB data loaded: ${title}, IMDb: ${imdbId}`);

                if (imdbId) {
                    // Start 8Stream loading immediately
                    await playFromLocalApi(imdbId);
                } else {
                    showError('No IMDB ID found for this media.');
                }
            } catch (error) {
                console.error('Error fetching details:', error);
                showError('Failed to load media details.');
            }
        }

        function hideLoader() {
            if (loader) {
                loader.style.opacity = '0';
                setTimeout(() => {
                    if (loader) loader.style.display = 'none';
                }, 300);
            }
        }

        function hideLoaderWhenPlayable() {
            if (!video) return;
            if (video.readyState >= 2) {
                hideLoader();
                forceHideLoader();
            }
        }

        function forceHideLoader() {
            console.log('ðŸ”§ Force hiding loader');
            const loaderElement = document.getElementById('loader');
            if (loaderElement) {
                loaderElement.style.display = 'none';
                loaderElement.style.opacity = '0';
            }
        }

        function stopPlaceholderPlayback() {
            if (placeholderAnimationId) {
                cancelAnimationFrame(placeholderAnimationId);
                placeholderAnimationId = null;
            }
            if (placeholderStream) {
                placeholderStream.getTracks().forEach((track) => track.stop());
                placeholderStream = null;
            }
            if (video && video.srcObject) {
                video.srcObject = null;
            }
        }

        function destroyHlsSafely() {
            if (!hls) return;
            try {
                hls.detachMedia();
            } catch (_) { }
            try {
                if (video) {
                    video.pause();
                    if (typeof video.src === 'string' && video.src.startsWith('blob:')) {
                        video.src = '';
                    }
                    video.srcObject = null;
                }
            } catch (_) { }
            try {
                hls.destroy();
            } catch (_) { }
            hls = null;
        }

        function startPlaceholderPlayback() {
            try {
                stopPlaceholderPlayback();
                destroyHlsSafely();
                useHlsAudioTracks = false;
                isTestStream = false;
                availableQualities = [];
                if (qualityMenuContainer) {
                    qualityMenuContainer.remove();
                    qualityMenuContainer = null;
                }

                const canvas = document.createElement('canvas');
                canvas.width = 1280;
                canvas.height = 720;
                const ctx = canvas.getContext('2d');

                const bars = ['#b30000', '#ff9f1a', '#ffd500', '#2ec4b6', '#1d4ed8', '#6d28d9', '#111827'];
                const start = performance.now();

                const draw = (now) => {
                    const t = (now - start) / 1000;
                    const w = canvas.width / bars.length;
                    for (let i = 0; i < bars.length; i++) {
                        ctx.fillStyle = bars[i];
                        ctx.fillRect(i * w, 0, w, canvas.height);
                    }

                    ctx.fillStyle = 'rgba(0,0,0,0.35)';
                    ctx.fillRect(0, canvas.height - 120, canvas.width, 120);

                    ctx.fillStyle = '#ffffff';
                    ctx.font = '36px Arial, sans-serif';
                    ctx.fillText('Test Video Placeholder', 40, canvas.height - 70);
                    ctx.font = '20px Arial, sans-serif';
                    ctx.fillText(`Time: ${t.toFixed(1)}s`, 40, canvas.height - 35);

                    placeholderAnimationId = requestAnimationFrame(draw);
                };

                placeholderAnimationId = requestAnimationFrame(draw);
                placeholderStream = canvas.captureStream(30);

                video.srcObject = placeholderStream;
                video.muted = true;
                video.play().catch(() => { });

                if (!player) {
                    player = new Plyr(video, {
                        controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'settings', 'fullscreen'],
                        tooltips: { controls: true, seek: true },
                        fullscreen: { iosNative: true },
                        clickToPlay: false
                    });
                }

                errorMsg.style.display = 'none';
                hideLoader();
                forceHideLoader();
                if (player && player.elements && player.elements.container) {
                    player.elements.container.classList.remove('plyr--hide-controls');
                }
                header.classList.remove('hidden');
            } catch (error) {
                console.error('Placeholder failed:', error);
            }
        }

        // Header Auto-hide
        function resetHeaderTimer() {
            if (isUiLocked) {
                header.classList.add('hidden');
                return;
            }
            header.classList.remove('hidden');
            clearTimeout(hideHeaderTimeout);
            hideHeaderTimeout = setTimeout(() => {
                if (player && !player.paused) {
                    header.classList.add('hidden');
                    // Also hide play overlay when autohiding
                    if (player.elements.container) {
                        player.elements.container.classList.add('plyr--hide-controls');
                    }
                }
            }, 5000); // 5 seconds
        }

        document.addEventListener('mousemove', resetHeaderTimer);
        document.addEventListener('touchstart', resetHeaderTimer);

        // Add click-to-show-controls functionality - use direct DOM manipulation
        function showControls() {
            if (isUiLocked) return;
            if (Date.now() < manualHideLockUntilTs) return;
            console.log('ðŸ‘ï¸ Showing controls');

            // Try multiple methods to show controls

            // Method 1: Find plyr container and remove hide class
            const plyrContainer = document.querySelector('.plyr');
            if (plyrContainer) {
                plyrContainer.classList.remove('plyr--hide-controls');
                console.log('âœ… Removed plyr--hide-controls class');
            }

            // Method 2: Directly show controls element
            const controls = document.querySelector('.plyr__controls');
            if (controls) {
                controls.style.opacity = '1';
                controls.style.visibility = 'visible';
                controls.style.display = 'flex';
                console.log('âœ… Showed controls element');
            }

            // Method 3: Show play button only when paused
            const playButton = document.querySelector('.plyr__control--overlaid');
            if (playButton) {
                if (video && video.paused) {
                    playButton.style.opacity = '1';
                    playButton.style.visibility = 'visible';
                    playButton.style.pointerEvents = 'auto';
                    console.log('âœ… Showed play button');
                } else {
                    playButton.style.opacity = '0';
                    playButton.style.visibility = 'hidden';
                    playButton.style.pointerEvents = 'none';
                }
            }

            // Show header
            header.classList.remove('hidden');

            // Reset autohide timer
            resetHeaderTimer();
            showControlsSurface();
        }

        function hideControlsNow() {
            if (isUiLocked) return;
            manualHideLockUntilTs = Date.now() + 450;
            clearTimeout(hideHeaderTimeout);
            clearTimeout(controlsHideTimer);
            header.classList.add('hidden');
            if (controlSurface) controlSurface.classList.remove('visible');
            if (player && player.elements && player.elements.container) {
                player.elements.container.classList.add('plyr--hide-controls');
            }
            if (audioMenuContainer) audioMenuContainer.classList.remove('active');
            if (qualityMenuContainer) qualityMenuContainer.classList.remove('active');
            if (episodeMenuContainer) episodeMenuContainer.classList.remove('active');
            if (volumeMenuContainer) volumeMenuContainer.classList.remove('active');
            if (settingsMenuContainer) settingsMenuContainer.classList.remove('active');
            if (speedMenuContainer) speedMenuContainer.classList.remove('active');
        }

        function shouldIgnoreSurfaceToggleTarget(target) {
            if (!(target instanceof Element)) return false;
            return !!target.closest('.ctrl-btn, .ctrl-icon, #seekBar, .audio-menu, .quality-menu, .episode-menu, .volume-menu, .settings-menu, .speed-menu, .ui-lock-btn, .back-btn, .episode-toggle, .volume-toggle, .settings-toggle');
        }

        function handleSurfaceToggleInteraction(e) {
            if (isUiLocked) return;
            const target = e.target;
            if (shouldIgnoreSurfaceToggleTarget(target)) return;

            const isPlayerSurfaceTap = !!(
                (target instanceof Element && target.closest('.player-container')) ||
                (target instanceof Element && target.closest('.player-header')) ||
                (target instanceof Element && target.closest('#pause-info')) ||
                (target instanceof Element && target.closest('.plyr')) ||
                (target instanceof Element && target.closest('.plyr__video-wrapper')) ||
                (target instanceof Element && target.closest('.plyr__poster')) ||
                (video && (target === video || (target instanceof Element && video.contains(target))))
            );

            if (!isPlayerSurfaceTap) return;

            const now = Date.now();
            if (e.type === 'click' && now < handleSurfaceToggleInteraction.suppressClicksUntilTs) return;
            if (e.type === 'touchstart') {
                handleSurfaceToggleInteraction.lastTouchTs = now;
                handleSurfaceToggleInteraction.suppressClicksUntilTs = now + 1200;
            }
            if ((now - handleSurfaceToggleInteraction.lastToggleTs) < 250) return;
            handleSurfaceToggleInteraction.lastToggleTs = now;

            const isVisible = controlSurface && controlSurface.classList.contains('visible');
            if (isVisible) hideControlsNow();
            else {
                manualHideLockUntilTs = 0;
                showControls();
            }
        }
        handleSurfaceToggleInteraction.lastTouchTs = 0;
        handleSurfaceToggleInteraction.lastToggleTs = 0;
        handleSurfaceToggleInteraction.suppressClicksUntilTs = 0;

        document.addEventListener('touchstart', handleSurfaceToggleInteraction, { passive: true, capture: true });
        document.addEventListener('click', handleSurfaceToggleInteraction, true);

        function loadPersistedStreamCache() {
            try {
                const raw = localStorage.getItem(STREAM_CACHE_STORAGE_KEY);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                const now = Date.now();
                Object.entries(parsed || {}).forEach(([cacheKey, entry]) => {
                    if (!entry || typeof entry.url !== 'string' || typeof entry.expires !== 'number') return;
                    if (entry.expires <= now) return;
                    streamCache.set(cacheKey, entry);
                });
            } catch (error) {
                console.warn('Failed to load persisted stream cache:', error);
            }
        }

        function persistStreamCache() {
            try {
                const now = Date.now();
                const serializable = {};
                streamCache.forEach((entry, cacheKey) => {
                    if (entry && typeof entry.url === 'string' && typeof entry.expires === 'number' && entry.expires > now) {
                        serializable[cacheKey] = entry;
                    }
                });
                localStorage.setItem(STREAM_CACHE_STORAGE_KEY, JSON.stringify(serializable));
            } catch (error) {
                console.warn('Failed to persist stream cache:', error);
            }
        }

        function tryNextTestStream(startTime = 0, shouldPlay = true) {
            if (currentTestStreamIndex + 1 >= TEST_MULTI_AUDIO_HLS_SOURCES.length) return false;
            currentTestStreamIndex += 1;
            const nextSource = getCurrentTestStream();
            console.warn(`Test stream failed, trying fallback source ${currentTestStreamIndex + 1}/${TEST_MULTI_AUDIO_HLS_SOURCES.length}:`, nextSource);
            loadStream(nextSource, startTime, shouldPlay);
            return true;
        }

        // Get cached stream URL
        function getCachedStreamUrl(imdbId, trackIndex = 0) {
            const cacheKey = getStreamCacheKey(imdbId, trackIndex);
            const cached = streamCache.get(cacheKey);

            if (cached && cached.expires > Date.now()) {
                console.log('ðŸ“¦ Using cached stream URL:', cached.url);
                return cached.url;
            }

            if (cached) {
                streamCache.delete(cacheKey);
                persistStreamCache();
            }

            return null;
        }

        // Cache stream URL with expiration
        function cacheStreamUrl(imdbId, url, trackIndex = 0) {
            const cacheKey = getStreamCacheKey(imdbId, trackIndex);
            // Cache for configured TTL
            streamCache.set(cacheKey, {
                url: url,
                expires: Date.now() + STREAM_CACHE_TTL_MS
            });
            console.log('Cached stream URL for ' + Math.round(STREAM_CACHE_TTL_MS / 86400000) + ' day(s)');
            persistStreamCache();
        }

        function clearCachedStreamUrl(imdbId, trackIndex = 0) {
            if (!imdbId) return;
            const cacheKey = getStreamCacheKey(imdbId, trackIndex);
            if (streamCache.has(cacheKey)) {
                streamCache.delete(cacheKey);
                persistStreamCache();
                console.log(`Cleared cached stream URL for ${imdbId} track ${trackIndex}`);
            }
        }

        async function loadAudioTrack(index, options = {}) {
            try {
                if (useHlsAudioTracks && hls && Array.isArray(hls.audioTracks) && hls.audioTracks.length > 0) {
                    currentAudioIndex = Math.max(0, Math.min(index, hls.audioTracks.length - 1));
                    hls.audioTrack = currentAudioIndex;
                    updateAudioMenuUI();
                    console.log('ðŸ”Š Switched HLS audio track:', currentAudioIndex);
                    return;
                }

                isTestStream = false;

                const track = globalPlaylist[index];
                if (!track) return;

                console.log(`Loading audio track ${index}:`, track);

                // Capture current state before switching
                const currentTime = video.currentTime;
                const startTime = (!initialResumeApplied && currentTime < 1 && initialResumeTime > 0)
                    ? initialResumeTime
                    : currentTime;
                const wasPlaying = !video.paused;
                if (!initialResumeApplied && startTime > 0) {
                    initialResumeApplied = true;
                    console.log(`â†ªï¸ Applying resume start time: ${startTime}s`);
                }

                currentAudioIndex = index;
                const file = track.file;
                const key = globalKey;
                const forceRefresh = !!options.forceRefresh;
                if (!forceRefresh) {
                    manifestRecoveryAttempts = 0;
                }

                // Try to get cached stream URL first
                const imdbId = urlParams.get('imdbId') || resolvedImdbId || (await fetchImdbId(urlParams.get('id') || urlParams.get('tmdbId')));
                if (imdbId && !forceRefresh) {
                    const cachedUrl = getCachedStreamUrl(imdbId, index);
                    if (cachedUrl) {
                        console.log('ðŸš€ Using cached stream - instant playback');
                        loadStream(cachedUrl, startTime, wasPlaying);
                        updateAudioMenuUI();
                        return;
                    }
                }

                // Try multiple approaches for the stream request
                let streamUrlFinal = null;

                try {
                    // Method 1: Standard POST request
                    const streamUrl = `${LOCAL_API_URL}/getStream`;
                    const requestBody = JSON.stringify({ file, key });

                    console.log('Stream request URL:', streamUrl);
                    console.log('Stream request body:', requestBody);

                    const streamRes = await fetch(streamUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: requestBody
                    });

                    console.log('Stream response status:', streamRes.status);

                    if (streamRes.ok) {
                        const streamData = await streamRes.json();
                        console.log('Stream response data:', streamData);

                        const finalData = streamData.data || streamData;
                        streamUrlFinal = finalData.link || finalData.url;

                        if (streamUrlFinal && typeof streamUrlFinal === 'string' && streamUrlFinal.startsWith('http')) {
                            console.log('âœ… Stream URL obtained:', streamUrlFinal);

                            // Cache the successful stream URL
                            if (imdbId) {
                                cacheStreamUrl(imdbId, streamUrlFinal, index);
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Method 1 failed:', error);
                }

                // Method 2: Try direct file access if Method 1 fails
                if (!streamUrlFinal) {
                    try {
                        console.log('Trying direct file access...');
                        const directUrl = `${LOCAL_API_URL}/stream/${encodeURIComponent(file)}`;
                        console.log('Direct URL attempt:', directUrl);

                        const directRes = await fetch(directUrl);
                        if (directRes.ok) {
                            // Check if response is JSON or text
                            const contentType = directRes.headers.get('content-type');
                            if (contentType && contentType.includes('application/json')) {
                                const directData = await directRes.json();
                                streamUrlFinal = directData.url || directData.link;
                            } else {
                                // If it's not JSON, check if it's a valid HLS stream
                                const text = await directRes.text();
                                if (text.includes('#EXTM3U')) {
                                    // It's a valid HLS playlist
                                    streamUrlFinal = directUrl;
                                } else {
                                    // Not a valid stream, skip this method
                                    console.log('Direct URL is not a valid HLS stream');
                                }
                            }
                            if (streamUrlFinal) {
                                console.log('âœ… Direct stream URL obtained:', streamUrlFinal);

                                // Cache the successful stream URL
                                if (imdbId) {
                                    cacheStreamUrl(imdbId, streamUrlFinal, index);
                                }
                            }
                        }
                    } catch (error) {
                        console.warn('Direct access failed:', error);
                    }
                }

                // Method 3: Try with different key format
                if (!streamUrlFinal && key) {
                    try {
                        console.log('Trying alternative key format...');
                        const altUrl = `${LOCAL_API_URL}/getStream`;
                        const altBody = JSON.stringify({
                            file: file,
                            key: key.replace(/\$/g, ''),
                            id: file
                        });

                        const altRes = await fetch(altUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: altBody
                        });

                        if (altRes.ok) {
                            const altData = await altRes.json();
                            const finalAltData = altData.data || altData;
                            streamUrlFinal = finalAltData.link || finalAltData.url;
                            console.log('âœ… Alternative stream URL obtained:', streamUrlFinal);

                            // Cache the successful stream URL
                            if (imdbId) {
                                cacheStreamUrl(imdbId, streamUrlFinal, index);
                            }
                        }
                    } catch (error) {
                        console.warn('Alternative method failed:', error);
                    }
                }

                const isHttpUrl = typeof streamUrlFinal === 'string' && streamUrlFinal.startsWith('http');
                if (isHttpUrl) {
                    loadStream(streamUrlFinal, startTime, wasPlaying);
                    updateAudioMenuUI();
                } else {
                    throw new Error('Unable to obtain direct stream URL. 8Stream API may be down.');
                }
            } catch (error) {
                console.error('Error loading audio track:', error);
                showError(`Stream Error: ${error.message}`);
            }
        }

        async function loadStream(source, startTime = 0, shouldPlay = true) {
            console.log("Loading stream:", source);
            stopPlaceholderPlayback();
            manualQualitySelection = false;
            rebufferEvents = [];
            if (temporaryQualityCapTimer) {
                clearTimeout(temporaryQualityCapTimer);
                temporaryQualityCapTimer = null;
            }
            useHlsAudioTracks = false;
            const isTestSource = typeof source === 'string' && TEST_MULTI_AUDIO_HLS_SOURCES.includes(source);
            if (isTestSource) {
                isTestStream = true;
                globalPlaylist = [];
                currentAudioIndex = 0;
            } else {
                isTestStream = false;
            }

            // Check if source is an iframe embed object
            if (source && typeof source === 'object' && source.type === 'iframe') {
                console.log(`ðŸ“º Loading iframe embed from ${source.provider}`);
                destroyHlsSafely();
                loadIframeEmbed(source.url, source.provider);
                return;
            }

            // Original HLS stream loading logic
            try {
                if (Hls.isSupported()) {
                    destroyHlsSafely();

                    hls = new Hls({
                        enableWorker: true,
                        enableSoftwareAES: false,
                        workerPath: null,
                        debug: false,
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60,
                        maxBufferSize: 120 * 1000 * 1000,
                        maxBufferHole: 0.3,
                        lowBufferWatchdogPeriod: 0.2,
                        highBufferWatchdogPeriod: 0.2,
                        nudgeOffset: 0.1,
                        nudgeMaxRetry: 5,
                        maxFragLookUpTolerance: 0.25,
                        liveSyncDurationCount: 3,
                        liveMaxLatencyDurationCount: Infinity,
                        liveDurationInfinity: true,
                        preferManagedMediaSource: true,
                        backBufferLength: 20,
                        startPosition: startTime > 0 ? Math.max(0, startTime - 2) : -1,
                        startLevel: -1,
                        capLevelToPlayerSize: true,
                        autoStartLoad: true,
                        lowLatencyMode: true,
                        fragLoadingTimeOut: 10000,
                        fragLoadingMaxRetry: 2,
                        fragLoadingRetryDelay: 500,
                        fragLoadingMaxRetryTimeout: 5000,
                        manifestLoadingTimeOut: 12000,
                        manifestLoadingMaxRetry: 2,
                        manifestLoadingRetryDelay: 500,
                        manifestLoadingMaxRetryTimeout: 5000,
                        levelLoadingTimeOut: 12000,
                        levelLoadingMaxRetry: 2,
                        levelLoadingRetryDelay: 500,
                        levelLoadingMaxRetryTimeout: 5000,
                        startFragPrefetch: true,
                        maxStarvationDelay: 4,
                        maxLoadingDelay: 4,
                        testBandwidth: true,
                        abrEwmaFastLive: 3.0,
                        abrEwmaSlowLive: 9.0,
                        abrEwmaFastVoD: 4.0,
                        abrEwmaSlowVoD: 14.0,
                        abrEwmaDefaultEstimate: 1500000,
                        abrBandWidthFactor: 0.72,
                        abrBandWidthUpFactor: 0.65,
                        abrBandWidthDownFactor: 0.9
                    });

                    hls.loadSource(source);
                    hls.attachMedia(video);

                    // ... rest of the HLS loading logic remains the same
                    hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {
                        manifestRecoveryInProgress = false;
                        manifestRecoveryAttempts = 0;
                        const maxHeight = Math.max(...hls.levels.map(l => l.height), 0);

                        // Preload settings for faster startup
                        console.log('âœ… Manifest parsed, levels available:', hls.levels.length);
                        console.log('ðŸ“Š Available qualities:', hls.levels.map(l => `${l.height}p (${l.bitrate}bps)`));

                        // Keep loader visible until playback is actually ready

                        const startupLevel = getConservativeStartupLevel();
                        if (startupLevel >= 0) {
                            hls.startLevel = startupLevel;
                            hls.nextLevel = startupLevel;
                            console.log(`ðŸŽ¯ Starting in conservative level: ${hls.levels[startupLevel]?.height || 'auto'}p`);
                        } else {
                            hls.startLevel = -1;
                            hls.currentLevel = -1;
                            console.log('ðŸŽ¯ Starting in Auto ABR mode');
                        }

                        setTimeout(() => {
                            if (!hls || manualQualitySelection) return;
                            hls.startLevel = -1;
                            hls.currentLevel = -1;
                            hls.autoLevelCapping = -1;
                            console.log('ðŸš€ Returning to full Auto ABR range after startup stabilization');
                        }, 25000);

                        if (!player) {
                            player = new Plyr(video, {
                                controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'settings', 'pip', 'airplay', 'fullscreen'],
                                quality: {
                                    default: maxHeight,
                                    options: [0, ...hls.levels.map(l => l.height)],
                                    forced: true,
                                    onChange: (q) => updateQuality(q)
                                },
                                // Enhanced Plyr settings for better performance
                                tooltips: { controls: true, seek: true },
                                captions: { active: false, update: false, language: 'en' },
                                fullscreen: { iosNative: true },
                                storage: { enabled: true, key: 'plyr' },
                                // Faster Plyr initialization
                                autoplay: true,
                                muted: false,
                                volume: 1,
                                clickToPlay: false
                            });

                            setupAudioButton();
                            setupEpisodeButton();
                            // Additional loader hiding events
                            player.on('ready', () => {
                                console.log('Player ready');
                            });

                            player.on('canplay', () => {
                                console.log('Can play');
                                hideLoaderWhenPlayable();
                            });

                            player.on('play', () => {
                                console.log('Playing');
                                const playButton = document.querySelector('.plyr__control--overlaid');
                                if (playButton) {
                                    playButton.style.opacity = '0';
                                    playButton.style.visibility = 'hidden';
                                    playButton.style.pointerEvents = 'none';
                                }
                            });

                            player.on('playing', () => {
                                console.log('Playing successfully');
                                hideLoaderWhenPlayable();
                                // Unmute after successful start
                                setTimeout(() => {
                                    if (video.muted) {
                                        video.muted = false;
                                        console.log('Audio unmuted');
                                    }
                                    // Force hide loader again after unmute
                                    forceHideLoader();
                                }, 500);

                                // Start autohide timer when playing starts
                                resetHeaderTimer();
                            });
                            player.on('pause', () => {
                                if (!video.paused) {
                                    video.pause();
                                }
                                const playButton = document.querySelector('.plyr__control--overlaid');
                                if (playButton) {
                                    playButton.style.opacity = '1';
                                    playButton.style.visibility = 'visible';
                                    playButton.style.pointerEvents = 'auto';
                                }
                                header.classList.remove('hidden');
                                // Show controls when paused
                                if (player.elements.container) {
                                    player.elements.container.classList.remove('plyr--hide-controls');
                                }
                            });
                            player.on('stalled', () => {
                                console.log('â¸ï¸ Playback stalled');
                                noteRebufferEvent();
                            });
                            player.on('waiting', () => {
                                console.log('â³ Waiting for data');
                                noteRebufferEvent();
                            });
                            player.on('seeking', () => console.log('ðŸ” Seeking'));
                            player.on('seeked', () => console.log('âœ… Seek complete'));
                        }

                        if (isTestStream && hls && Array.isArray(hls.audioTracks) && hls.audioTracks.length > 1) {
                            useHlsAudioTracks = true;
                            globalPlaylist = hls.audioTracks.map((track, index) => ({
                                title: track.name || track.lang || `Audio ${index + 1}`
                            }));
                            currentAudioIndex = hls.audioTrack || 0;
                            setupAudioButton();
                        }

                        hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, function () {
                            if (!isTestStream || !hls || !Array.isArray(hls.audioTracks)) return;
                            if (hls.audioTracks.length > 0) {
                                useHlsAudioTracks = true;
                                currentAudioIndex = hls.audioTrack || 0;
                                setupAudioButton();
                                buildAudioMenuItems();
                                updateAudioMenuUI();
                            }
                        });

                        if (hls && Array.isArray(hls.levels)) {
                            const heights = hls.levels.map((l) => l.height).filter(Boolean);
                            availableQualities = Array.from(new Set(heights)).sort((a, b) => a - b);
                            setupQualityMenu();
                        }
                        hls.on(Hls.Events.LEVEL_SWITCHED, function () {
                            if (hls) {
                                if (hls.currentLevel === -1) {
                                    selectedQualityLabel = 'Auto';
                                } else if (hls.levels[hls.currentLevel] && hls.levels[hls.currentLevel].height) {
                                    selectedQualityLabel = `${hls.levels[hls.currentLevel].height}p`;
                                }
                                updateQualityMenuUI(hls.currentLevel === -1 ? -1 : hls.currentLevel);
                            }
                        });

                        // Resume from previous point
                        if (startTime > 0) {
                            video.currentTime = startTime;
                            console.log(`â° Resuming from ${startTime}s`);
                        }

                        // Ultra-fast autoplay - start immediately
                        console.log('ðŸš€ Starting ultra-fast autoplay...');
                        video.muted = false;
                        const playPromise = video.play();

                        if (playPromise !== undefined) {
                            playPromise.then(() => {
                                console.log('ðŸŽ¬ Autoplay successful');
                                hideLoaderWhenPlayable();
                            }).catch(error => {
                                console.warn('âš ï¸ Autoplay blocked, trying muted:', error);
                                // Try muted autoplay immediately
                                video.muted = true;
                                video.play().then(() => {
                                    console.log('Muted autoplay successful');
                                    hideLoaderWhenPlayable();
                                }).catch(e => {
                                    console.error('âŒ Autoplay failed:', e);
                                    hideLoader();
                                });
                            });
                        }

                    });

                    hls.on(Hls.Events.ERROR, function (_, data) {
                        if (!hls || !data || !data.fatal) return;
                        console.warn('HLS fatal error:', data.type, data.details);
                        const isManifestIssue =
                            data.details === Hls.ErrorDetails.MANIFEST_LOAD_ERROR ||
                            data.details === Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
                        if (!isTestStream &&
                            data.type === Hls.ErrorTypes.NETWORK_ERROR &&
                            isManifestIssue) {
                            if (manifestRecoveryInProgress) return;
                            manifestRecoveryInProgress = true;
                            manifestRecoveryAttempts += 1;

                            if (manifestRecoveryAttempts === 1) {
                                const imdbId = urlParams.get('imdbId') || resolvedImdbId;
                                clearCachedStreamUrl(imdbId, currentAudioIndex);
                                console.warn('Retrying with fresh stream URL after manifest issue...');
                                setTimeout(() => {
                                    loadAudioTrack(currentAudioIndex, { forceRefresh: true }).catch((err) => {
                                        console.error('Fresh stream retry failed:', err);
                                        manifestRecoveryInProgress = false;
                                    });
                                }, 50);
                                return;
                            }
                            manifestRecoveryInProgress = false;
                            showError('Stream 2 is unavailable right now. Please try again later.');
                            return;
                        }
                        if (isTestStream && data.type === Hls.ErrorTypes.NETWORK_ERROR && isManifestIssue) {
                            const switched = tryNextTestStream(startTime, shouldPlay);
                            if (switched) return;
                        }
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                {
                                    const isTimeoutError =
                                        data.details === Hls.ErrorDetails.LEVEL_LOAD_TIMEOUT ||
                                        data.details === Hls.ErrorDetails.FRAG_LOAD_TIMEOUT ||
                                        data.details === Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
                                    if (isTimeoutError) {
                                        const currentLevelIndex = hls.currentLevel >= 0 ? hls.currentLevel : hls.nextLevel;
                                        const lowerLevelIndex = getLowerLevelIndex(currentLevelIndex >= 0 ? currentLevelIndex : hls.levels.length - 1);
                                        if (lowerLevelIndex >= 0 && hls.levels && hls.levels[lowerLevelIndex]) {
                                            hls.nextLevel = lowerLevelIndex;
                                            console.log(`âš¡ Timeout recovery: forcing lower level ${hls.levels[lowerLevelIndex].height || 'auto'}p`);
                                        }
                                    }
                                    hls.stopLoad();
                                    hls.startLoad(startTime > 0 ? Math.max(0, startTime - 1) : -1);
                                }
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                hls.recoverMediaError();
                                break;
                            default:
                                destroyHlsSafely();
                                showError('Stream playback failed due to a fatal HLS error.');
                                break;
                        }
                    });

                    // ... rest of the HLS error handling and monitoring
                    return;
                }
            } catch (error) {
                console.error('Error loading stream:', error);
                showError(`Stream loading error: ${error.message}`);
            }
        }

        // Function to load iframe embeds
        function loadIframeEmbed(url, provider) {
            console.log(`ðŸ“º Loading ${provider} iframe embed`);

            // Hide the video player and show iframe
            video.style.display = 'none';
            if (player) player.elements.container.style.display = 'none';

            // Create or update iframe
            let iframe = document.getElementById('embed-iframe');
            if (!iframe) {
                iframe = document.createElement('iframe');
                iframe.id = 'embed-iframe';
                iframe.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    border: none;
                    z-index: 1;
                `;
                document.querySelector('.player-container').appendChild(iframe);
            }

            iframe.src = url;
            iframe.style.display = 'block';

            // Update UI
            document.getElementById('media-meta').innerText = `Streaming via ${provider}`;

            hideLoader();

            console.log(`âœ… ${provider} iframe loaded successfully`);
        }

        function buildAudioMenuItems() {
            if (!audioMenuContainer) return;
            audioMenuContainer.innerHTML = '';

            if (isTestStream && useHlsAudioTracks) {
                if (hls && Array.isArray(hls.audioTracks) && hls.audioTracks.length > 0) {
                    hls.audioTracks.forEach((track, index) => {
                        const item = document.createElement('div');
                        const title = track.name || track.lang || `Audio ${index + 1}`;
                        item.className = `audio-item ${index === currentAudioIndex ? 'selected' : ''}`;
                        item.innerText = title;
                        item.onclick = () => {
                            loadAudioTrack(index);
                            audioMenuContainer.classList.remove('active');
                        };
                        audioMenuContainer.appendChild(item);
                    });
                    return;
                }
            }

            if (globalPlaylist.length === 0) {
                const item = document.createElement('div');
                item.className = 'audio-item selected';
                item.innerText = 'Default Audio';
                audioMenuContainer.appendChild(item);
                return;
            }

            globalPlaylist.forEach((track, index) => {
                const item = document.createElement('div');
                item.className = `audio-item ${index === currentAudioIndex ? 'selected' : ''}`;
                item.innerText = track.title || `Track ${index + 1}`;
                item.onclick = () => {
                    loadAudioTrack(index);
                    audioMenuContainer.classList.remove('active');
                };
                audioMenuContainer.appendChild(item);
            });
        }

        function setupAudioButton() {
            const existingBtn = document.getElementById('custom-audio-btn');

            // Create or reuse the button (use custom control bar)
            let btn = existingBtn;
            if (!btn) {
                btn = document.createElement('button');
                btn.type = 'button';
                btn.id = 'custom-audio-btn';
                btn.className = 'ctrl-icon';
                btn.setAttribute('aria-label', 'Audio');
                btn.innerHTML = '<i class="fa-solid fa-language"></i>';

                const controls = document.querySelector('.control-actions');
                if (controls) {
                    controls.insertBefore(btn, controls.firstChild);
                }
            }

            if (!audioMenuContainer) {
                audioMenuContainer = document.createElement('div');
                audioMenuContainer.className = 'audio-menu';
            }
            buildAudioMenuItems();

            const menuHost = document.querySelector('.player-container') || (player && player.elements && player.elements.container);
            if (menuHost && !audioMenuContainer.parentNode) menuHost.appendChild(audioMenuContainer);

            btn.onclick = (e) => {
                e.stopPropagation();
                const rect = btn.getBoundingClientRect();
                if (audioMenuContainer) {
                    audioMenuContainer.style.position = 'fixed';
                    audioMenuContainer.style.left = `${Math.max(12, rect.left - 140)}px`;
                    audioMenuContainer.style.right = 'auto';
                    audioMenuContainer.style.bottom = `${Math.max(80, window.innerHeight - rect.top + 12)}px`;
                }
                if (settingsMenuContainer) settingsMenuContainer.classList.remove('active');
                const speedList = settingsMenuContainer ? settingsMenuContainer.querySelector('.speed-list') : null;
                if (speedList) speedList.classList.remove('active');
                if (qualityMenuContainer) qualityMenuContainer.classList.remove('active');
                if (episodeMenuContainer) episodeMenuContainer.classList.remove('active');
                if (volumeMenuContainer) volumeMenuContainer.classList.remove('active');
                if (!audioMenuContainer || audioMenuContainer.children.length === 0) {
                    buildAudioMenuItems();
                }
                audioMenuContainer.classList.toggle('active');
            };

            if (!audioMenuDocListenerAdded) {
                document.addEventListener('click', (e) => {
                    const audioBtn = document.getElementById('custom-audio-btn');
                    if (audioMenuContainer && audioMenuContainer.classList.contains('active')) {
                        if (!audioMenuContainer.contains(e.target) && e.target !== audioBtn) {
                            audioMenuContainer.classList.remove('active');
                        }
                    }
                });
                audioMenuDocListenerAdded = true;
            }
        }

        function updateAudioMenuUI() {
            if (!audioMenuContainer) return;
            // Update selection highlighting
            const items = audioMenuContainer.querySelectorAll('.audio-item');
            items.forEach((item, index) => {
                if (index === currentAudioIndex) item.classList.add('selected');
                else item.classList.remove('selected');
            });
        }

        function buildQualityMenuItems() {
            if (!qualityMenuContainer) return;
            qualityMenuContainer.innerHTML = '';

            const addItem = (label, levelIndex, isSelected) => {
                const item = document.createElement('div');
                item.className = `quality-item ${isSelected ? 'selected' : ''}`;
                item.innerText = label;
                item.onclick = () => {
                    if (levelIndex === -1) {
                        updateQuality(0);
                    } else {
                        updateQuality(label.replace('p', ''));
                    }
                };
                qualityMenuContainer.appendChild(item);
            };

            const isAuto = selectedQualityLabel === 'Auto';
            addItem('Auto', -1, isAuto);

            if (!hls || !Array.isArray(hls.levels) || hls.levels.length === 0) {
                addItem('No qualities', -1, false);
                return;
            }

            const levelsByHeight = new Map();
            hls.levels.forEach((lvl, idx) => {
                if (!lvl.height) return;
                const existing = levelsByHeight.get(lvl.height);
                if (existing === undefined || lvl.bitrate > hls.levels[existing].bitrate) {
                    levelsByHeight.set(lvl.height, idx);
                }
            });

            const heights = Array.from(levelsByHeight.keys()).sort((a, b) => a - b);
            heights.forEach((h) => {
                const levelIndex = levelsByHeight.get(h);
                const isSelected = selectedQualityLabel === `${h}p`;
                addItem(`${h}p`, levelIndex, isSelected);
            });
        }

        function setupQualityMenu() {
            const btn = document.getElementById('qualityBtn');
            if (!btn) return;

            if (!qualityMenuContainer) {
                qualityMenuContainer = document.createElement('div');
                qualityMenuContainer.className = 'quality-menu';
            }

            buildQualityMenuItems();

            const menuHost = document.querySelector('.player-container') || (player && player.elements && player.elements.container);
            if (menuHost && !qualityMenuContainer.parentNode) menuHost.appendChild(qualityMenuContainer);

            if (!qualityBtnListenerAdded) {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (settingsMenuContainer) settingsMenuContainer.classList.remove('active');
                    const speedList = settingsMenuContainer ? settingsMenuContainer.querySelector('.speed-list') : null;
                    if (speedList) speedList.classList.remove('active');
                    if (audioMenuContainer) audioMenuContainer.classList.remove('active');
                    if (episodeMenuContainer) episodeMenuContainer.classList.remove('active');
                    if (volumeMenuContainer) volumeMenuContainer.classList.remove('active');
                    buildQualityMenuItems();
                    qualityMenuContainer.classList.toggle('active');
                });
                qualityBtnListenerAdded = true;
            }

            if (!qualityMenuDocListenerAdded) {
                document.addEventListener('click', (e) => {
                    if (qualityMenuContainer && qualityMenuContainer.classList.contains('active')) {
                        if (!qualityMenuContainer.contains(e.target) && e.target !== btn) {
                            qualityMenuContainer.classList.remove('active');
                        }
                    }
                });
                qualityMenuDocListenerAdded = true;
            }
        }

        function updateQualityMenuUI(selectedLevel) {
            if (!qualityMenuContainer) return;
            const items = qualityMenuContainer.querySelectorAll('.quality-item');
            items.forEach((item) => item.classList.remove('selected'));

            if (selectedLevel === -1) {
                if (items[0]) items[0].classList.add('selected');
                return;
            }

            const label = hls && hls.levels[selectedLevel] ? `${hls.levels[selectedLevel].height}p` : '';
            items.forEach((item) => {
                if (item.innerText === label) item.classList.add('selected');
            });
        }

        function updateQuality(newQuality) {
            if (!hls) return;
            if (newQuality === 0 || newQuality === '0') {
                manualQualitySelection = false;
                hls.currentLevel = -1;
                hls.autoLevelCapping = -1;
                selectedQualityLabel = 'Auto';
                updateQualityMenuUI(-1);
                return;
            }

            const height = parseInt(newQuality, 10);
            const levelIndex = hls.levels.findIndex((l) => l.height === height);
            if (levelIndex !== -1) {
                manualQualitySelection = true;
                hls.currentLevel = levelIndex;
                hls.autoLevelCapping = levelIndex;
                selectedQualityLabel = `${height}p`;
                updateQualityMenuUI(levelIndex);
            }
        }

        function updateVolumeUI() {
            if (!muteBtn) return;
            if (video.muted || video.volume === 0) {
                muteBtn.innerHTML = '<i class="fa-solid fa-volume-xmark"></i>';
            } else if (video.volume < 0.5) {
                muteBtn.innerHTML = '<i class="fa-solid fa-volume-low"></i>';
            } else {
                muteBtn.innerHTML = '<i class="fa-solid fa-volume-high"></i>';
            }
        }

        function buildVolumeMenu() {
            if (!volumeMenuContainer) return;
            volumeMenuContainer.innerHTML = '';
            volumeSliderEl = null;
            volumeToggleEl = null;

            const row = document.createElement('div');
            row.className = 'volume-row';

            const toggle = document.createElement('button');
            toggle.className = 'volume-toggle';
            toggle.type = 'button';
            toggle.innerHTML = video.muted || video.volume === 0
                ? '<i class="fa-solid fa-volume-xmark"></i>'
                : '<i class="fa-solid fa-volume-high"></i>';

            toggle.onclick = (e) => {
                e.stopPropagation();
                video.muted = !video.muted;
                if (!video.muted && video.volume === 0) {
                    video.volume = 0.5;
                }
                updateVolumeUI();
                if (volumeSliderEl) {
                    volumeSliderEl.value = String(Math.round((video.muted ? 0 : video.volume) * 100));
                    volumeSliderEl.style.setProperty('--vol-percent', `${volumeSliderEl.value}%`);
                }
                if (volumeToggleEl) {
                    volumeToggleEl.innerHTML = video.muted || video.volume === 0
                        ? '<i class="fa-solid fa-volume-xmark"></i>'
                        : '<i class="fa-solid fa-volume-high"></i>';
                }
            };

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = '0';
            slider.max = '100';
            slider.step = '1';
            slider.value = String(Math.round((video.muted ? 0 : video.volume) * 100));
            slider.className = 'volume-slider';
            slider.style.setProperty('--vol-percent', `${slider.value}%`);

            slider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value, 10);
                video.volume = val / 100;
                video.muted = val === 0;
                slider.style.setProperty('--vol-percent', `${val}%`);
                updateVolumeUI();
            });

            slider.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                slider.setPointerCapture?.(e.pointerId);
                updateVolumeFromClientX(e.clientX, slider);
            });

            slider.addEventListener('pointermove', (e) => {
                if (!slider.hasPointerCapture?.(e.pointerId)) return;
                updateVolumeFromClientX(e.clientX, slider);
            });

            slider.addEventListener('pointerup', (e) => {
                if (slider.hasPointerCapture?.(e.pointerId)) {
                    slider.releasePointerCapture?.(e.pointerId);
                }
            });

            volumeSliderEl = slider;
            volumeToggleEl = toggle;

            row.appendChild(toggle);
            row.appendChild(slider);
            volumeMenuContainer.appendChild(row);
        }

        function setupVolumeMenu() {
            if (!muteBtn) return;
            if (!volumeMenuContainer) {
                volumeMenuContainer = document.createElement('div');
                volumeMenuContainer.className = 'volume-menu';
            }

            buildVolumeMenu();

            const menuHost = document.querySelector('.player-container') || (player && player.elements && player.elements.container);
            if (menuHost && !volumeMenuContainer.parentNode) menuHost.appendChild(volumeMenuContainer);

            muteBtn.onclick = (e) => {
                e.stopPropagation();
                if (audioMenuContainer) audioMenuContainer.classList.remove('active');
                if (qualityMenuContainer) qualityMenuContainer.classList.remove('active');
                if (episodeMenuContainer) episodeMenuContainer.classList.remove('active');
                if (settingsMenuContainer) settingsMenuContainer.classList.remove('active');
                const speedList = settingsMenuContainer ? settingsMenuContainer.querySelector('.speed-list') : null;
                if (speedList) speedList.classList.remove('active');
                const rect = muteBtn.getBoundingClientRect();
                volumeMenuContainer.style.position = 'fixed';
                volumeMenuContainer.style.left = `${Math.max(12, rect.left - 140)}px`;
                volumeMenuContainer.style.right = 'auto';
                volumeMenuContainer.style.bottom = `${Math.max(80, window.innerHeight - rect.top + 12)}px`;
                buildVolumeMenu();
                volumeMenuContainer.classList.toggle('active');
            };

            if (!volumeMenuDocListenerAdded) {
                document.addEventListener('click', (e) => {
                    if (volumeMenuContainer && volumeMenuContainer.classList.contains('active')) {
                        if (!volumeMenuContainer.contains(e.target) && e.target !== muteBtn) {
                            volumeMenuContainer.classList.remove('active');
                        }
                    }
                });
                volumeMenuDocListenerAdded = true;
            }
        }

        function buildSettingsMenu() {
            if (!settingsMenuContainer) return;
            settingsMenuContainer.innerHTML = '';

            const speedToggle = document.createElement('div');
            speedToggle.className = 'settings-item';
            speedToggle.innerHTML = `Playback Speed <span style="opacity:0.6;">â–¼</span>`;
            settingsMenuContainer.appendChild(speedToggle);

            const speedList = document.createElement('div');
            speedList.className = 'speed-list';
            settingsMenuContainer.appendChild(speedList);

            const speeds = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2];
            speeds.forEach((rate) => {
                const item = document.createElement('div');
                item.className = `speed-item ${video.playbackRate === rate ? 'selected' : ''}`;
                item.innerText = `${rate}x`;
                item.onclick = () => {
                    video.playbackRate = rate;
                    buildSettingsMenu();
                    speedList.classList.add('active');
                };
                speedList.appendChild(item);
            });

            speedToggle.onclick = () => {
                if (audioMenuContainer) audioMenuContainer.classList.remove('active');
                if (qualityMenuContainer) qualityMenuContainer.classList.remove('active');
                if (episodeMenuContainer) episodeMenuContainer.classList.remove('active');
                if (volumeMenuContainer) volumeMenuContainer.classList.remove('active');
                speedList.classList.toggle('active');
            };
        }

        function buildSpeedMenu() { }

        function setupSettingsMenu() {
            const settingsBtn = document.getElementById('settingsBtn');
            if (!settingsBtn) return;

            if (!settingsMenuContainer) {
                settingsMenuContainer = document.createElement('div');
                settingsMenuContainer.className = 'settings-menu';
            }
            buildSettingsMenu();

            const menuHost = document.querySelector('.player-container') || (player && player.elements && player.elements.container);
            if (menuHost && !settingsMenuContainer.parentNode) menuHost.appendChild(settingsMenuContainer);

            settingsBtn.onclick = (e) => {
                e.stopPropagation();
                const wasOpen = settingsMenuContainer && settingsMenuContainer.classList.contains('active');
                if (audioMenuContainer) audioMenuContainer.classList.remove('active');
                if (qualityMenuContainer) qualityMenuContainer.classList.remove('active');
                if (episodeMenuContainer) episodeMenuContainer.classList.remove('active');
                if (volumeMenuContainer) volumeMenuContainer.classList.remove('active');
                if (settingsMenuContainer) settingsMenuContainer.classList.remove('active');
                if (wasOpen) return;

                const rect = settingsBtn.getBoundingClientRect();
                settingsMenuContainer.style.position = 'fixed';
                settingsMenuContainer.style.left = `${Math.max(12, rect.left - 140)}px`;
                settingsMenuContainer.style.right = 'auto';
                settingsMenuContainer.style.bottom = `${Math.max(80, window.innerHeight - rect.top + 12)}px`;
                buildSettingsMenu();
                settingsMenuContainer.classList.add('active');
            };

            if (!settingsMenuDocListenerAdded) {
                document.addEventListener('click', (e) => {
                    if (settingsMenuContainer && settingsMenuContainer.classList.contains('active')) {
                        if (!settingsMenuContainer.contains(e.target) && e.target !== settingsBtn) {
                            settingsMenuContainer.classList.remove('active');
                        }
                    }
                });
                settingsMenuDocListenerAdded = true;
            }
        }

        function startTestMultiAudio() {
            try {
                if (errorMsg) errorMsg.style.display = 'none';
                if (player && player.elements && player.elements.container) {
                    player.elements.container.style.display = '';
                }
                if (video) {
                    video.style.display = '';
                    video.muted = true;
                    video.pause();
                    if (typeof video.src === 'string' && video.src.startsWith('blob:')) {
                        video.src = '';
                    }
                    video.srcObject = null;
                }
                if (hls) {
                    destroyHlsSafely();
                }
                globalPlaylist = [];
                currentAudioIndex = 0;
                useHlsAudioTracks = false;
                isTestStream = true;
                currentTestStreamIndex = 0;
                selectedQualityLabel = 'Auto';
                loadStream(getCurrentTestStream(), 0, true);
                hideLoader();
                forceHideLoader();
                showControlsSurface();
            } catch (error) {
                console.error('Failed to start test multi-audio stream:', error);
            }
        }

        function showError(msg) {
            hideLoader();
            const container = document.querySelector('.player-container');
            const plyr = document.querySelector('.plyr');
            if (plyr) plyr.style.display = 'none';
            else video.style.display = 'none';

            errorMsg.style.display = 'block';

            // Check if it's an 8Stream API issue and provide helpful message
            if (msg.includes('500') || msg.includes('8Stream API')) {
                errorMsg.innerHTML = `
                    <i class="fa-solid fa-circle-exclamation"></i>
                    <h3>8Stream API Unavailable</h3>
                    <p>The 8Stream server is experiencing issues (500 Internal Server Error).</p>
                    <p><strong>Solutions:</strong></p>
                    <ul style="text-align: left; margin: 10px 0;">
                        <li>Try again in a few minutes</li>
                        <li>Use Stream 1 (main player) instead</li>
                        <li>Try a different movie/show</li>
                    </ul>
                    <p style="margin-top: 15px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button id="test-multiaudio-btn" style="
                            background: var(--accent);
                            color: white;
                            border: none;
                            padding: 10px 16px;
                            border-radius: 5px;
                            cursor: pointer;
                            font-size: 14px;
                        ">Test Multi-Audio Video</button>
                        <button onclick="window.location.href='index.html'" style="
                            background: rgba(255,255,255,0.1);
                            color: white;
                            border: 1px solid var(--surface-border);
                            padding: 10px 16px;
                            border-radius: 5px;
                            cursor: pointer;
                            font-size: 14px;
                        ">â† Back to Movies</button>
                    </p>
                `;
            } else {
                errorMsg.innerHTML = `
                    <i class="fa-solid fa-circle-exclamation"></i>
                    <h3>Stream Unavailable</h3>
                    <p>${msg}</p>
                    <p style="margin-top: 15px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button id="test-multiaudio-btn" style="
                            background: var(--accent);
                            color: white;
                            border: none;
                            padding: 10px 16px;
                            border-radius: 5px;
                            cursor: pointer;
                            font-size: 14px;
                        ">Test Multi-Audio Video</button>
                        <button onclick="window.location.href='index.html'" style="
                            background: rgba(255,255,255,0.1);
                            color: white;
                            border: 1px solid var(--surface-border);
                            padding: 10px 16px;
                            border-radius: 5px;
                            cursor: pointer;
                            font-size: 14px;
                        ">â† Back to Movies</button>
                    </p>
                `;
            }

            const multiBtn = document.getElementById('test-multiaudio-btn');
            if (multiBtn) {
                multiBtn.onclick = () => startTestMultiAudio();
            }
        }

        function setupEpisodeButton() {
            // Only add if it's a TV series
            if (!isTv) return;

            // Check if already added
            if (document.getElementById('custom-episode-btn')) return;

            // Create Button
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.id = 'custom-episode-btn';
            btn.className = 'plyr__control';
            btn.innerHTML = '<i class="fa-solid fa-list"></i><span class="plyr__sr-only">Episodes</span>';
            btn.style.marginLeft = '10px';

            // Insert before Audio button or Settings
            const controls = player.elements.controls;
            const audioBtn = document.getElementById('custom-audio-btn');

            if (controls) {
                if (audioBtn) {
                    controls.insertBefore(btn, audioBtn);
                } else {
                    controls.appendChild(btn);
                }
            }

            // Create Menu Container
            episodeMenuContainer = document.createElement('div');
            episodeMenuContainer.className = 'episode-menu';

            // Populate Menu (Seasons -> Episodes)
            tvData.forEach((season, sIndex) => {
                // Season Title
                const sTitle = document.createElement('div');
                sTitle.className = 'season-title';
                sTitle.innerText = season.title;
                episodeMenuContainer.appendChild(sTitle);

                // Episodes
                if (season.folder) {
                    season.folder.forEach((episode, eIndex) => {
                        const item = document.createElement('div');
                        item.className = `episode-item`;
                        item.dataset.s = sIndex;
                        item.dataset.e = eIndex;
                        item.innerText = episode.title || `Episode ${eIndex + 1}`;

                        // Highlight current
                        if (sIndex === currentSeasonIndex && eIndex === currentEpisodeIndex) {
                            item.classList.add('selected');
                        }

                        item.onclick = () => {
                            loadEpisode(sIndex, eIndex);
                            episodeMenuContainer.classList.remove('active');
                        };
                        episodeMenuContainer.appendChild(item);
                    });
                }
            });

            // Append menu to player container
            player.elements.container.appendChild(episodeMenuContainer);

            // Toggle logic
            btn.onclick = (e) => {
                e.stopPropagation();
                // Close audio menu if open
                if (audioMenuContainer) audioMenuContainer.classList.remove('active');
                if (qualityMenuContainer) qualityMenuContainer.classList.remove('active');
                if (volumeMenuContainer) volumeMenuContainer.classList.remove('active');
                if (settingsMenuContainer) settingsMenuContainer.classList.remove('active');
                const speedList = settingsMenuContainer ? settingsMenuContainer.querySelector('.speed-list') : null;
                if (speedList) speedList.classList.remove('active');

                episodeMenuContainer.classList.toggle('active');

                // Scroll to selected element 
                const selected = episodeMenuContainer.querySelector('.selected');
                if (selected) {
                    selected.scrollIntoView({ block: 'center' });
                }
            };

            // Close when clicking outside
            document.addEventListener('click', (e) => {
                if (episodeMenuContainer && episodeMenuContainer.classList.contains('active')) {
                    if (!episodeMenuContainer.contains(e.target) && e.target !== btn) {
                        episodeMenuContainer.classList.remove('active');
                    }
                }
            });
        }

        function updateEpisodeMenuUI() {
            if (!episodeMenuContainer) return;
            // Rebuild menu? Or just update classes. 
            // Simpler to just update classes.
            const items = episodeMenuContainer.querySelectorAll('.episode-item');
            items.forEach((item) => {
                const s = parseInt(item.dataset.s);
                const e = parseInt(item.dataset.e);

                if (s === currentSeasonIndex && e === currentEpisodeIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        // Keyboard Controls
        document.addEventListener('keydown', function (e) {
            // Only handle keys when video is focused or no input is focused
            if (document.activeElement.tagName === 'INPUT' ||
                document.activeElement.tagName === 'TEXTAREA' ||
                document.activeElement.contentEditable === 'true') {
                return;
            }

            switch (e.key) {
                case ' ':
                case 'Spacebar':
                    e.preventDefault();
                    if (video.paused) {
                        video.play();
                        console.log('â–¶ï¸ Play (Spacebar)');
                    } else {
                        video.pause();
                        console.log('â¸ï¸ Pause (Spacebar)');
                    }
                    break;

                case 'ArrowLeft':
                    e.preventDefault();
                    video.currentTime = Math.max(0, video.currentTime - 10);
                    console.log('âª Skip back 10s (Left Arrow)');
                    break;

                case 'ArrowRight':
                    e.preventDefault();
                    video.currentTime = Math.min(video.duration, video.currentTime + 10);
                    console.log('â© Skip forward 10s (Right Arrow)');
                    break;

                case 'ArrowUp':
                    e.preventDefault();
                    video.volume = Math.min(1, video.volume + 0.1);
                    if (player) player.volume = video.volume;
                    console.log('ðŸ”Š Volume up (Up Arrow):', Math.round(video.volume * 100) + '%');
                    break;

                case 'ArrowDown':
                    e.preventDefault();
                    video.volume = Math.max(0, video.volume - 0.1);
                    if (player) player.volume = video.volume;
                    console.log('ðŸ”‰ Volume down (Down Arrow):', Math.round(video.volume * 100) + '%');
                    break;

                case 'f':
                case 'F':
                    e.preventDefault();
                    const target = playerContainer || document.documentElement;
                    if (!document.fullscreenElement) {
                        target.requestFullscreen?.();
                    } else {
                        document.exitFullscreen?.();
                    }
                    console.log('ðŸ–¥ï¸ Toggle fullscreen (F)');
                    showControlsSurface();
                    break;

                case 'm':
                case 'M':
                    e.preventDefault();
                    video.muted = !video.muted;
                    if (player) player.muted = video.muted;
                    console.log('ðŸ”‡ Toggle mute (M):', video.muted ? 'muted' : 'unmuted');
                    break;

                case 'c':
                case 'C':
                    e.preventDefault();
                    if (player && player.captions) {
                        const captions = player.captions;
                        const currentTrack = captions.currentTrack;
                        const tracks = captions.tracks;

                        if (tracks.length > 0) {
                            const nextTrackIndex = currentTrack === null ? 0 :
                                (tracks.indexOf(currentTrack) + 1) % tracks.length;
                            captions.currentTrack = tracks[nextTrackIndex];
                            console.log('ðŸ’¬ Toggle captions (C):', tracks[nextTrackIndex] ? 'enabled' : 'disabled');
                        }
                    }
                    break;

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    e.preventDefault();
                    const percent = parseInt(e.key) * 10;
                    video.currentTime = (video.duration * percent) / 100;
                    console.log(`â° Jump to ${percent}% (${Math.round(video.currentTime)}s)`);
                    break;
            }
        });

        init();

        const controlSurface = document.getElementById('controlSurface');
        const playerContainer = document.querySelector('.player-container');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const skipBackBtn = document.getElementById('skipBackBtn');
        const skipFwdBtn = document.getElementById('skipFwdBtn');
        const muteBtn = document.getElementById('muteBtn');
        const fitBtn = document.getElementById('fitBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const uiLockBtn = document.getElementById('uiLockBtn');
        const seekBar = document.getElementById('seekBar');
        const currentTimeEl = document.getElementById('currentTime');
        const durationTimeEl = document.getElementById('durationTime');

        let controlsHideTimer;
        let manualHideLockUntilTs = 0;
        let lastContinueWatchingSaveMs = 0;
        let lastResumeUrlSecond = Number.isFinite(requestedResumeTime) && requestedResumeTime > 0 ? requestedResumeTime : 0;
        let lastResumeUrlSyncMs = 0;

        function closeOverlayMenus() {
            if (audioMenuContainer) audioMenuContainer.classList.remove('active');
            if (qualityMenuContainer) qualityMenuContainer.classList.remove('active');
            if (episodeMenuContainer) episodeMenuContainer.classList.remove('active');
            if (volumeMenuContainer) volumeMenuContainer.classList.remove('active');
            if (settingsMenuContainer) settingsMenuContainer.classList.remove('active');
            if (speedMenuContainer) speedMenuContainer.classList.remove('active');
            const speedList = settingsMenuContainer ? settingsMenuContainer.querySelector('.speed-list') : null;
            if (speedList) speedList.classList.remove('active');
        }

        function updateLockButtonUI() {
            if (!uiLockBtn) return;
            uiLockBtn.classList.toggle('locked', isUiLocked);
            uiLockBtn.setAttribute('aria-label', isUiLocked ? 'Unlock controls' : 'Lock controls');
            uiLockBtn.title = isUiLocked ? 'Unlock controls' : 'Lock controls';
            uiLockBtn.innerHTML = isUiLocked
                ? '<i class="fa-solid fa-lock"></i>'
                : '<i class="fa-solid fa-lock-open"></i>';
        }

        function setUiLockState(locked) {
            isUiLocked = !!locked;
            document.body.classList.toggle('ui-locked', isUiLocked);
            if (isUiLocked) {
                clearTimeout(controlsHideTimer);
                closeOverlayMenus();
                controlSurface.classList.remove('visible');
                header.classList.add('hidden');
                if (player && player.elements && player.elements.container) {
                    player.elements.container.classList.add('plyr--hide-controls');
                }
            } else {
                if (player && player.elements && player.elements.container) {
                    player.elements.container.classList.remove('plyr--hide-controls');
                }
                if (video && video.paused) {
                    controlSurface.classList.add('visible');
                } else {
                    showControlsSurface();
                }
                resetHeaderTimer();
            }
            updateLockButtonUI();
        }

        function formatTime(seconds) {
            if (!isFinite(seconds)) return '0:00';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) {
                return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function getContinueWatchingMovieId() {
            return (
                urlParams.get('movieId') ||
                urlParams.get('id') ||
                urlParams.get('tmdbId') ||
                urlParams.get('imdbId') ||
                'unknown'
            );
        }

        function getContinueWatchingTitle() {
            const domTitle = document.getElementById('media-title')?.innerText?.trim();
            const urlTitle = urlParams.get('title');
            return domTitle || urlTitle || 'Unknown Movie';
        }

        function getContinueWatchingPoster() {
            const urlPoster = urlParams.get('poster');
            const pausePoster = document.getElementById('pause-poster')?.getAttribute('src');
            return urlPoster || pausePoster || '';
        }

        function shouldSkipContinueWatching() {
            if (isTestStream) return true;
            const testHintKeys = ['test', 'isTest', 'testvideo', 'testVideo', 'demo'];
            for (const key of testHintKeys) {
                const value = urlParams.get(key);
                if (!value) continue;
                const normalized = String(value).trim().toLowerCase();
                if (['1', 'true', 'yes', 'on', 'test'].includes(normalized)) return true;
            }
            const titleHint = String(urlParams.get('title') || '').toLowerCase();
            if (titleHint.includes('test video') || titleHint.includes('testvideo')) return true;
            return false;
        }

        function getContinueWatchingStorageKeys() {
            const keys = new Set(['continueWatching', 'continueWatching_guest', 'continueWatching_local']);
            try {
                for (let i = 0; i < localStorage.length; i++) {
                    const k = localStorage.key(i);
                    if (!k) continue;
                    const match = k.match(/^fb_selected_profile_(.+)$/);
                    if (!match) continue;
                    const uid = match[1];
                    keys.add(`continueWatching_${uid}`);
                    const profileId = localStorage.getItem(k);
                    if (profileId) keys.add(`continueWatching_${uid}_${profileId}`);
                }
            } catch (error) {
                console.warn('Failed to resolve continue watching storage keys:', error);
            }
            return Array.from(keys);
        }

        function normalizeMovieKey(value) {
            if (value == null) return '';
            const raw = String(value).trim();
            if (!raw) return '';
            if (/^\d+$/.test(raw)) return raw;
            return raw.toLowerCase().replace(/-+$/, '');
        }

        function resolveInitialResumeTime() {
            const baseResume = Number.isFinite(requestedResumeTime) && requestedResumeTime > 0 ? requestedResumeTime : 0;
            const candidateKeys = new Set();
            const rawCandidates = [
                urlParams.get('movieId'),
                urlParams.get('id'),
                urlParams.get('tmdbId'),
                urlParams.get('imdbId')
            ].filter(Boolean);

            rawCandidates.forEach((value) => {
                const raw = String(value);
                candidateKeys.add(raw);
                const normalized = normalizeMovieKey(raw);
                if (normalized) candidateKeys.add(normalized);
            });

            let savedResume = 0;
            const storageKeys = getContinueWatchingStorageKeys();
            for (const key of storageKeys) {
                try {
                    const raw = localStorage.getItem(key);
                    if (!raw) continue;
                    const parsed = JSON.parse(raw);
                    if (!parsed || typeof parsed !== 'object') continue;

                    for (const [storedKey, entry] of Object.entries(parsed)) {
                        if (!entry || typeof entry !== 'object') continue;

                        const possibleIds = [
                            storedKey,
                            entry.movieId,
                            entry.id,
                            entry.tmdbId,
                            entry.imdbId
                        ].map((v) => String(v || '')).filter(Boolean);

                        let matchesMovie = false;
                        for (const idValue of possibleIds) {
                            const normalized = normalizeMovieKey(idValue);
                            if (candidateKeys.has(idValue) || (normalized && candidateKeys.has(normalized))) {
                                matchesMovie = true;
                                break;
                            }
                        }
                        if (!matchesMovie) continue;

                        const currentTime = Number(entry.currentTime || 0);
                        if (Number.isFinite(currentTime) && currentTime > savedResume) {
                            savedResume = Math.floor(currentTime);
                        }
                    }
                } catch (_) {
                    // Ignore malformed entries for a single key and continue.
                }
            }

            const finalResume = Math.max(baseResume, savedResume);
            if (finalResume > baseResume) {
                console.log(`â†» Refresh resume: using latest saved time ${finalResume}s (URL had ${baseResume}s)`);
            }
            return finalResume;
        }

        function syncResumeParamInUrl(force = false) {
            try {
                if (!video) return;
                const currentTime = Math.floor(Number(video.currentTime || 0));
                if (!Number.isFinite(currentTime) || currentTime <= 0) return;

                const now = Date.now();
                if (!force) {
                    if (currentTime < 30) return;
                    if (currentTime <= lastResumeUrlSecond) return;
                    if ((currentTime - lastResumeUrlSecond) < 5) return;
                    if ((now - lastResumeUrlSyncMs) < 3000) return;
                }

                const params = new URLSearchParams(window.location.search);
                const urlTime = Number.parseInt(params.get('t') || '0', 10);
                if (!force && Number.isFinite(urlTime) && currentTime <= urlTime) return;

                params.set('t', String(currentTime));
                const query = params.toString();
                const nextUrl = `${window.location.pathname}${query ? `?${query}` : ''}${window.location.hash || ''}`;
                window.history.replaceState(window.history.state, '', nextUrl);

                lastResumeUrlSecond = currentTime;
                lastResumeUrlSyncMs = now;
            } catch (error) {
                console.warn('Failed to sync resume time in URL:', error);
            }
        }

        function saveContinueWatchingProgress(force = false) {
            try {
                if (shouldSkipContinueWatching()) return;
                if (!video || !isFinite(video.duration) || video.duration <= 0) return;
                const currentTime = Number(video.currentTime || 0);
                const duration = Number(video.duration || 0);
                if (!isFinite(currentTime) || !isFinite(duration) || duration <= 0) return;

                syncResumeParamInUrl(force);

                const now = Date.now();
                if (!force && now - lastContinueWatchingSaveMs < 10000) return;

                const progress = Math.max(0, Math.min(100, (currentTime / duration) * 100));
                if (!force && (currentTime < 30 || progress < 1)) return;

                const movieId = getContinueWatchingMovieId();
                if (!movieId || movieId === 'unknown') return;

                const entry = {
                    id: movieId,
                    movieId,
                    title: getContinueWatchingTitle(),
                    poster: getContinueWatchingPoster(),
                    posterUrl: getContinueWatchingPoster(),
                    thumbnail: getContinueWatchingPoster(),
                    progress,
                    currentTime,
                    duration,
                    mediaType: urlParams.get('mediaType') || type || 'movie',
                    playerUsed: 'player2',
                    timestamp: now,
                    updatedAt: now
                };

                // Prefer cloud sync so progress appears across ports/domains (e.g., Vercel)
                try {
                    if (window.ContinueWatchingManager?.saveMovieProgress) {
                        window.ContinueWatchingManager.saveMovieProgress(movieId, entry);
                    } else if (window.FirebaseSync?.saveContinueWatching) {
                        window.FirebaseSync.saveContinueWatching(movieId, entry);
                    }
                } catch (cloudError) {
                    console.warn('Failed to save continue watching to cloud:', cloudError);
                }

                const keys = getContinueWatchingStorageKeys();
                keys.forEach((storageKey) => {
                    try {
                        const raw = localStorage.getItem(storageKey);
                        const data = raw ? JSON.parse(raw) : {};
                        data[movieId] = entry;
                        localStorage.setItem(storageKey, JSON.stringify(data));
                    } catch (error) {
                        console.warn(`Failed to save continue watching to ${storageKey}:`, error);
                    }
                });

                lastContinueWatchingSaveMs = now;
                window.dispatchEvent(new CustomEvent('continueWatchingUpdated', { detail: { movieId, progress } }));
            } catch (error) {
                console.warn('Failed to save continue watching progress:', error);
            }
        }

        function showControlsSurface() {
            if (isUiLocked) {
                controlSurface.classList.remove('visible');
                return;
            }
            if (Date.now() < manualHideLockUntilTs) return;
            controlSurface.classList.add('visible');
            clearTimeout(controlsHideTimer);
            controlsHideTimer = setTimeout(() => {
                if (video && !video.paused) {
                    controlSurface.classList.remove('visible');
                    if (audioMenuContainer) audioMenuContainer.classList.remove('active');
                    if (qualityMenuContainer) qualityMenuContainer.classList.remove('active');
                    if (episodeMenuContainer) episodeMenuContainer.classList.remove('active');
                    if (volumeMenuContainer) volumeMenuContainer.classList.remove('active');
                    if (settingsMenuContainer) settingsMenuContainer.classList.remove('active');
                    if (speedMenuContainer) speedMenuContainer.classList.remove('active');
                }
            }, 3000);
        }

        function updateVolumeFromClientX(clientX, slider) {
            if (!slider || !Number.isFinite(clientX)) return;
            const rect = slider.getBoundingClientRect();
            if (!rect || !Number.isFinite(rect.width) || rect.width <= 0) return;
            if (!Number.isFinite(rect.left) || !Number.isFinite(rect.right)) return;
            const clamped = Math.min(rect.right, Math.max(rect.left, clientX));
            const percent = ((clamped - rect.left) / rect.width) * 100;
            if (!Number.isFinite(percent)) return;
            const val = Math.max(0, Math.min(100, percent));
            slider.value = String(Math.round(val));
            slider.style.setProperty('--vol-percent', `${val}%`);
            const volume = val / 100;
            if (!Number.isFinite(volume)) return;
            video.volume = volume;
            video.muted = val === 0;
            updateVolumeUI();
        }

        function setPlayIcon(isPlaying) {
            if (!playPauseBtn) return;
            playPauseBtn.innerHTML = isPlaying
                ? '<i class="fa-solid fa-pause"></i>'
                : '<i class="fa-solid fa-play"></i>';
        }

        function syncTimeUI() {
            currentTimeEl.innerText = formatTime(video.currentTime);
            durationTimeEl.innerText = formatTime(video.duration);
            if (isFinite(video.duration) && video.duration > 0) {
                const percent = (video.currentTime / video.duration) * 100;
                seekBar.value = percent;
                seekBar.style.setProperty('--seek-percent', `${percent}%`);
            }
        }

        if (playPauseBtn) {
            playPauseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (video.paused) video.play();
                else video.pause();
            });
        }

        if (skipBackBtn) {
            skipBackBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                video.currentTime = Math.max(0, video.currentTime - 10);
            });
        }

        if (skipFwdBtn) {
            skipFwdBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (isFinite(video.duration)) {
                    video.currentTime = Math.min(video.duration, video.currentTime + 10);
                } else {
                    video.currentTime += 10;
                }
            });
        }

        if (muteBtn) {
            setupVolumeMenu();
            updateVolumeUI();
        }

        setupSettingsMenu();

        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const target = playerContainer || document.documentElement;
                if (!document.fullscreenElement) {
                    target.requestFullscreen?.();
                } else {
                    document.exitFullscreen?.();
                }
            });
        }

        const fitModes = [
            { value: 'contain', label: 'Contain', icon: 'fa-up-right-and-down-left-from-center' },
            { value: 'cover', label: 'Fill', icon: 'fa-up-right-and-down-left-from-center' },
            { value: 'fill', label: 'Stretch', icon: 'fa-arrows-up-down-left-right' }
        ];
        let fitIndex = 0;

        function applyFitMode() {
            if (!video) return;
            const mode = fitModes[fitIndex];
            document.documentElement.style.setProperty('--video-fit', mode.value);
            if (fitBtn) {
                fitBtn.title = mode.label;
                fitBtn.setAttribute('aria-label', `Screen Fit: ${mode.label}`);
                fitBtn.innerHTML = `<i class="fa-solid ${mode.icon}"></i>`;
            }
        }

        if (fitBtn) {
            applyFitMode();
            fitBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                fitIndex = (fitIndex + 1) % fitModes.length;
                applyFitMode();
                showControlsSurface();
            });
        }

        if (uiLockBtn) {
            updateLockButtonUI();
            uiLockBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                setUiLockState(!isUiLocked);
            });
        }


        if (seekBar) {
            seekBar.addEventListener('input', (e) => {
                const percent = parseFloat(e.target.value || '0') / 100;
                if (isFinite(video.duration)) {
                    video.currentTime = percent * video.duration;
                }
            });

            const updateSeekFromClientX = (clientX) => {
                const rect = seekBar.getBoundingClientRect();
                const clamped = Math.min(rect.right, Math.max(rect.left, clientX));
                const percent = ((clamped - rect.left) / rect.width) * 100;
                seekBar.value = String(percent);
                seekBar.style.setProperty('--seek-percent', `${percent}%`);
                if (isFinite(video.duration)) {
                    video.currentTime = (percent / 100) * video.duration;
                }
            };

            seekBar.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                seekBar.setPointerCapture?.(e.pointerId);
                updateSeekFromClientX(e.clientX);
            });

            seekBar.addEventListener('pointermove', (e) => {
                if (!seekBar.hasPointerCapture?.(e.pointerId)) return;
                updateSeekFromClientX(e.clientX);
            });

            seekBar.addEventListener('pointerup', (e) => {
                if (seekBar.hasPointerCapture?.(e.pointerId)) {
                    seekBar.releasePointerCapture?.(e.pointerId);
                }
            });
        }

        video.addEventListener('timeupdate', () => {
            syncTimeUI();
            syncResumeParamInUrl(false);
            saveContinueWatchingProgress(false);
        });
        video.addEventListener('loadedmetadata', syncTimeUI);
        video.addEventListener('volumechange', () => {
            updateVolumeUI();
            if (volumeSliderEl) {
                const val = Math.round((video.muted ? 0 : video.volume) * 100);
                volumeSliderEl.value = String(val);
                volumeSliderEl.style.setProperty('--vol-percent', `${val}%`);
            }
            if (volumeToggleEl) {
                volumeToggleEl.innerHTML = video.muted || video.volume === 0
                    ? '<i class="fa-solid fa-volume-xmark"></i>'
                    : '<i class="fa-solid fa-volume-high"></i>';
            }
        });
        video.addEventListener('play', () => {
            setPlayIcon(true);
            const poster = document.querySelector('.plyr__poster');
            if (poster) {
                poster.style.opacity = '0';
                poster.style.visibility = 'hidden';
                poster.style.pointerEvents = 'none';
            }
            showControlsSurface();
        });
        video.addEventListener('pause', () => {
            setPlayIcon(false);
            controlSurface.classList.add('visible');
            syncResumeParamInUrl(true);
            saveContinueWatchingProgress(true);
        });

        video.addEventListener('ended', () => {
            syncResumeParamInUrl(true);
            saveContinueWatchingProgress(true);
        });

        document.addEventListener('mousemove', showControlsSurface);
        document.addEventListener('touchstart', () => {
            if (controlSurface && controlSurface.classList.contains('visible')) {
                showControlsSurface();
            }
        });
        document.addEventListener('fullscreenchange', () => {
            showControlsSurface();
            if (video && video.paused) {
                controlSurface.classList.add('visible');
            }
        });

        document.addEventListener('keydown', function (e) {
            if ((e.key === 'f' || e.key === 'F') && video && video.paused) {
                controlSurface.classList.add('visible');
            }
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                syncResumeParamInUrl(true);
                saveContinueWatchingProgress(true);
            }
        });

        window.addEventListener('beforeunload', () => {
            syncResumeParamInUrl(true);
            saveContinueWatchingProgress(true);
        });
    </script>
</body>

</html>

