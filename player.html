<style>
  @media (orientation: portrait) and (max-width: 600px) {
        .time-display {
          font-size: 0.55em !important;
          min-width: 28px !important;
          margin-left: -32px !important;
          margin-right: 2px !important;
          flex-shrink: 0 !important;
          text-align: right !important;
        }
    /* Desktop-like controls for portrait mobile: inline, square, centered, evenly spaced */
    .controls {
      display: flex !important;
      flex-direction: row !important;
      justify-content: center !important;
      align-items: center !important;
      flex-wrap: nowrap !important;
      gap: 2px !important;
      overflow-x: visible !important;
      box-sizing: border-box;
      padding: 0 0.5vw !important;
      min-width: 0 !important;
    }
    .control-btn,
    .skip-btn,
    .play-pause-btn,
    #captionsBtn,
    #settingsBtn,
    #screenModeToggle {
      min-width: 14px !important;
      min-height: 14px !important;
      max-width: 14px !important;
      max-height: 14px !important;
      width: 14px !important;
      height: 14px !important;
      font-size: 0.45em !important;
      border-radius: 3px !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      padding: 0 !important;
      margin: 0 !important;
      box-sizing: border-box !important;
      background: rgba(0,0,0,0.5) !important;
      flex-shrink: 1 !important;
      min-inline-size: 0 !important;
    }
    #screenModeIcon {
      font-size: 0.8em !important;
    }
    #screenModeIcon,
    #settingsBtn i,
    #captionsBtn i,
    .play-pause-btn i {
      font-size: 1.1em !important;
    }
    .right-controls,
    .screen-mode-container {
      gap: 0 !important;
      justify-content: flex-start !important;
      margin-left: -100px !important;
      float: none !important;
    }
    .right-controls {
      float: none !important;
      margin-left: -50px !important;
    }
    .screen-mode-container {
      margin-left: 0px !important;
    }
    .movie-info-overlay {
      display: none !important;
    }

    .skip-btn {
      color: #fff;
      position: relative;
      min-width: 26px !important;
      min-height: 26px !important;
      max-width: 26px !important;
      max-height: 26px !important;
      width: 26px !important;
      height: 26px !important;
      border-radius: 8px !important;
      background: rgba(0,0,0,0.5) !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }

    #video {
      width: 100vw !important;
      max-width: 100vw !important;
      height: 60vh !important;
      max-height: 65vh !important;
      background: #000;
      display: block;
      margin: 0 auto;
      position: relative;
      top: 250px;
    }

    .movie-meta,
    #movieTitle,
    #movieDescription,
    #movieYear,
    #movieRating,
    #movieGenre,
    #movieInfo,
    #movieDetails,
    #movieSubtitle,
    #movieExtra,
    .movie-info-extra,
    .movie-title-extra {
      display: none !important;
    }
  /* ...existing code... */

    .controls-container {
      box-sizing: border-box;
      width: 100vw !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      position: absolute !important;
      z-index: 20 !important;
      padding-bottom: 2vw !important;
      padding-top: 2vw !important;
    }
    .video-container {
      position: relative !important;
    }

    .controls {
      display: flex !important;
      flex-direction: row !important;
      justify-content: space-between !important;
      align-items: center !important;
      flex-wrap: nowrap !important;
      gap: 2vw !important;
      overflow-x: visible !important;
      box-sizing: border-box;
      padding: 0 4vw !important;
      min-width: 0 !important;
    }

    .control-btn,
    .skip-btn {
      min-width: 12vw !important;
      min-height: 12vw !important;
      max-width: 14vw !important;
      max-height: 14vw !important;
      font-size: 1.5em !important;
      padding: 0 !important;
      margin: 0 !important;
      border-radius: 50% !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      box-sizing: border-box !important;
    }

    .right-controls {
      margin-right: 0 !important;
      padding-right: 0 !important;
      gap: 2vw !important;
    }
    .screen-mode-container {
      margin-left: 0 !important;
      gap: 2vw !important;
    }

    #screenModeToggle {
      min-width: 12vw !important;
      min-height: 12vw !important;
      max-width: 14vw !important;
      max-height: 14vw !important;
      padding: 0 !important;
      font-size: 1.5em !important;
      border-radius: 50% !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      touch-action: manipulation;
    }

    #screenModeIcon {
      font-size: 1.2em !important;
    }

    .control-btn,
    .skip-btn {
      min-width: 44px;
      min-height: 44px;
      box-sizing: border-box;
    }
  }

  @media (orientation: portrait) and (max-width: 600px) {
    .movie-info-overlay {
      display: none !important;
    }
  }

  /* Portrait mode improvements for mobile */
  @media (orientation: portrait) and (max-width: 600px) {
    #video {
      width: 100vw !important;
      max-width: 100vw !important;
      height: 60vh !important;
      max-height: 65vh !important;
      background: #000;
      display: block;
      margin: 0 auto;
    }

    .movie-info-overlay {
      margin-top: 8px !important;
      padding-top: 0 !important;
      font-size: 1.1em !important;
    }

    .controls-container {
      padding: 10px !important;
    }
  }

  /* Landscape orientation styles for mobile devices */
  @media (orientation: landscape) and (max-width: 900px) {
            .skip-notification,
            .skip-text {
              display: none !important;
            }
            #video {
              object-fit: cover !important;
            }
        .movie-meta,
        #movieTitle,
        #movieDescription,
        #movieYear,
        #movieRating,
        #movieGenre,
        #movieInfo,
        #movieDetails,
        #movieSubtitle,
        #movieExtra,
        .movie-info-extra,
        .movie-title-extra {
          display: none !important;
        }
    #video {
      width: 100vw !important;
      max-width: 100vw !important;
      height: 80vh !important;
      max-height: 100vh !important;
      background: #000;
      display: block;
      margin: 0 auto;
    }

    .controls {
      gap: 0.2vw !important;
      padding: 0 1vw !important;
    }

    .control-btn,
    .skip-btn {
      min-width: 22px !important;
      min-height: 22px !important;
      font-size: 0.7em !important;
      padding: 0 1px !important;
      margin: 0 !important;
    }

    .right-controls {
      margin-right: 0 !important;
      padding-right: 0 !important;
      gap: 0.2vw !important;
    }

    .screen-mode-container {
      margin-left: 0 !important;
      gap: 2px !important;
    }

    #screenModeToggle {
      min-width: 22px;
      min-height: 22px;
      padding: 2px 3px;
      font-size: 0.7em;
      touch-action: manipulation;
    }

    #screenModeIcon {
      font-size: 0.9em;
    }
  }

  /* Mobile-specific styles for video and screen mode toggle */
  @media (max-width: 600px) {
    .controls {
      gap: 0.2vw !important;
      padding: 0 1vw !important;
    }

    .control-btn,
    .skip-btn {
      min-width: 18px !important;
      min-height: 18px !important;
      font-size: 0.6em !important;
      padding: 0 0.5px !important;
      margin: 0 !important;
    }

    .right-controls {
      margin-right: 0 !important;
      padding-right: 0 !important;
      gap: 0.1vw !important;
    }

    .screen-mode-container {
      margin-left: 0 !important;
      gap: 1px !important;
    }

    #screenModeToggle {
      min-width: 18px;
      min-height: 18px;
      padding: 1px 2px;
      font-size: 0.6em;
      touch-action: manipulation;
    }

    #screenModeIcon {
      font-size: 0.7em;
    }

    #video {
      width: 100vw !important;
      max-width: 100vw !important;
      height: 40vh !important;
      max-height: 60vh !important;
      background: #000;
      display: block;
      margin: 0 auto;
    }
  }

  /* Hide horizontal scrollbar for playback speed submenu (all browsers) */
  #playbackSpeedSubmenu {
    overflow-x: hidden !important;
    max-width: 280px;
  }

  #playbackSpeedSubmenu::-webkit-scrollbar:horizontal {
    display: none !important;
    height: 0 !important;
    overflow-x: hidden !important;
  }

  #playbackSpeedSubmenu {
    scrollbar-width: thin;
    scrollbar-color: #fff #222;
    overflow-x: hidden !important;
  }
</style>
<!DOCTYPE html>
<html lang="en">

<head>
    <script>
      // Force landscape mode on mobile
      document.addEventListener('DOMContentLoaded', function () {
        if (window.screen && window.screen.orientation && /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
          try {
            window.screen.orientation.lock('landscape').catch(function(){});
          } catch (e) {}
        }
      });
    </script>
  <style>
    /* Remove all scrollbars and adjust height for playbackSpeedSubmenu */
    #playbackSpeedSubmenu {
      overflow: visible !important;
      max-height: none !important;
      height: auto !important;
    }

    #playbackSpeedSubmenu::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }
  </style>
  <style>
    /* Hide horizontal scrollbar and prevent horizontal scrolling for playback speed submenu */
    #playbackSpeedSubmenu {
      overflow-x: hidden !important;
      max-width: 260px;
    }

    #playbackSpeedSubmenu::-webkit-scrollbar:horizontal {
      display: none !important;
      height: 0 !important;
    }

    #playbackSpeedSubmenu {
      scrollbar-width: thin;
      scrollbar-color: #fff #222;
    }

    #playbackSpeedSubmenu {
      max-width: 100vw;
      min-width: 0;
      white-space: normal !important;
    }
  </style>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title id="pageTitle">Loading...</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Netflix+Sans:wght@300;400;500;700&display=swap">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link rel="stylesheet" href="css/subtitles.css">
  <script src="ui.js"></script>
  <!-- Firebase compat SDKs + Auth helpers for per-profile continue-watching scoping -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="public/firebaseConfig.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <script src="auth-firebase.js?v=3"></script>
  <!-- Continue Watching Scripts -->
  <script src="js/continue-watching.js"></script>
  <script src="js/continue-watching-ui.js"></script>

  <!-- Initialize ContinueWatchingUI early -->
  <script>
    // Initialize continue watching UI
    window.continueWatchingUI = null;
    window.continueWatchingUIReady = false;

    // Function to initialize the ContinueWatchingUI
    function initContinueWatchingUI() {
      if (window.ContinueWatchingUI && !window.continueWatchingUI) {
        try {
          window.continueWatchingUI = new ContinueWatchingUI();
          console.log('ContinueWatchingUI initialized:', !!window.continueWatchingUI);
          window.continueWatchingUIReady = true;

          // Dispatch an event that the UI is ready
          const event = new Event('ContinueWatchingUIInitialized');
          document.dispatchEvent(event);

          return true;
        } catch (error) {
          console.error('Error initializing ContinueWatchingUI:', error);
          return false;
        }
      }
      return false;
    }

    // Try to initialize immediately
    if (!initContinueWatchingUI()) {
      // If not ready, set up a listener for when ContinueWatchingUI is available
      const checkUI = setInterval(() => {
        if (initContinueWatchingUI()) {
          clearInterval(checkUI);
        }
      }, 100);
    }
  </script>

  <!-- Player resume logic: prompts to resume on refresh or fresh load -->
  <script src="js/player-continue-watching.js"></script>

  <!-- Explicit tracking initialization -->
  <script>
    // Ensure tracking starts immediately when video is ready
    (function () {
      'use strict';

      console.log('[Tracking] Initializing explicit video tracking...');

      // Wait for DOM and video element
      function initializeTracking() {
        const video = document.getElementById('video');
        if (!video) {
          console.warn('[Tracking] Video element not found, retrying...');
          setTimeout(initializeTracking, 100);
          return;
        }

        // Get movie data from URL
        const urlParams = new URLSearchParams(window.location.search);
        const movieId = urlParams.get('movieId') || urlParams.get('id') || `movie_${Date.now()}`;
        const title = urlParams.get('title') || 'Unknown Movie';
        const poster = urlParams.get('poster') || urlParams.get('thumbnail') || '';

        const movieData = {
          movieId: movieId,
          title: title,
          posterUrl: poster,
          thumbnail: poster
        };

        console.log('[Tracking] Movie data:', movieData);

        // Wait for ContinueWatchingManager
        function startTracking() {
          if (!window.ContinueWatchingManager) {
            console.warn('[Tracking] Manager not ready, waiting...');
            setTimeout(startTracking, 100);
            return;
          }

          console.log('[Tracking] ✅ ContinueWatchingManager found!');

          // Initialize tracking when video metadata loads
          const initOnReady = () => {
            if (video.readyState >= 1 && video.duration > 0) {
              console.log('[Tracking] ✅ Video ready, starting tracking');
              console.log('[Tracking] Duration:', video.duration, 'seconds');

              try {
                window.ContinueWatchingManager.initializeVideoTracking(video, movieData);
                console.log('[Tracking] ✅ Tracking initialized successfully');
              } catch (e) {
                console.error('[Tracking] ❌ Error initializing tracking:', e);
              }
            } else {
              console.log('[Tracking] Video not ready yet, waiting... (readyState:', video.readyState, ')');
            }
          };

          // Try now
          initOnReady();

          // Also listen for events
          video.addEventListener('loadedmetadata', () => {
            console.log('[Tracking] loadedmetadata event fired');
            initOnReady();
          }, { once: true });

          video.addEventListener('canplay', () => {
            console.log('[Tracking] canplay event fired');
            initOnReady();
          }, { once: true });

          // Force check after 2 seconds
          setTimeout(() => {
            console.log('[Tracking] Force check after 2s');
            initOnReady();
          }, 2000);
        }

        startTracking();
      }

      // Start initialization
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeTracking);
      } else {
        initializeTracking();
      }
    })();
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const urlParams = new URLSearchParams(window.location.search);
      const movieTitle = urlParams.get('title') || 'Movie';
      document.title = movieTitle;

      // --- Gesture Controls for Landscape ---
      const video = document.getElementById('video');
      const videoContainer = document.getElementById('videoContainer');
      let lastTap = 0;
      let tapTimeout = null;

      function isLandscape() {
        return window.matchMedia('(orientation: landscape)').matches;
      }

      function showSkipNotification(type) {
        const skipNotification = document.getElementById('skipNotification');
        const skipText = document.getElementById('skipText');
        const skipIcon = skipNotification.querySelector('i');
        // Track cumulative skip
        if (!showSkipNotification.skipAmount) showSkipNotification.skipAmount = 0;
        if (!showSkipNotification.timeout) showSkipNotification.timeout = null;

        // If a new skip happens before previous notification hides, accumulate
        if (showSkipNotification.timeout) {
          clearTimeout(showSkipNotification.timeout);
        }

        if (type === 'forward') {
          showSkipNotification.skipAmount += 10;
          skipNotification.classList.add('visible', 'forward');
          skipText.textContent = `+${showSkipNotification.skipAmount}s`;
          skipIcon.classList.remove('fa-backward');
          skipIcon.classList.add('fa-forward');
          skipNotification.style.left = '';
          skipNotification.style.right = '15%';
        } else {
          showSkipNotification.skipAmount -= 10;
          skipNotification.classList.add('visible', 'backward');
          skipText.textContent = `${showSkipNotification.skipAmount}s`;
          skipIcon.classList.remove('fa-forward');
          skipIcon.classList.add('fa-backward');
          skipNotification.style.right = '';
          skipNotification.style.left = '15%';
        }

        showSkipNotification.timeout = setTimeout(() => {
          skipNotification.classList.remove('visible', 'forward', 'backward');
          skipNotification.style.left = '';
          skipNotification.style.right = '';
          showSkipNotification.skipAmount = 0;
          showSkipNotification.timeout = null;
        }, 600);
      }

      function handleGesture(e) {
        if (!isLandscape()) return;
        if (!video) return;

        // Disable gestures if any dropdown/settings panel is open
        const settingsMenu = document.getElementById('settingsMenu');
        const playbackSpeedSubmenu = document.getElementById('playbackSpeedSubmenu');
        const subtitleSettings = document.getElementById('subtitleSettings');
        // If tap is inside any open menu, ignore gesture
        // Prevent gestures if clicking inside any open menu (normal or fullscreen)
        const menusToCheck = [settingsMenu, playbackSpeedSubmenu, subtitleSettings];
        // Also check for fullscreen subtitle settings panel
        let fullscreenPanels = [];
        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
          fullscreenPanels = Array.from(document.querySelectorAll('.settings-panel'));
        }
        for (const menu of [...menusToCheck, ...fullscreenPanels]) {
          if (menu && menu.style.display !== 'none' && menu.style.display !== '') {
            // Disable gestures for the entire panel area (fullscreen and non-fullscreen)
            if (menu.classList.contains('settings-panel')) {
              const rect = menu.getBoundingClientRect();
              let x, y;
              if (e.type.startsWith('touch')) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
              } else {
                x = e.clientX;
                y = e.clientY;
              }
              if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) return;
            } else {
              if (menu.contains(e.target)) return;
            }
          }
        }

        // Exclude controls and top bar
        const controls = document.getElementById('controlsContainer');
        const backBtn = document.getElementById('backButton');
        let target = e.target;
        if (controls && (controls.contains(target) || target === controls)) return;
        if (backBtn && (backBtn.contains(target) || target === backBtn)) return;
        let y;
        if (e.type.startsWith('touch')) {
          y = e.touches[0].clientY;
        } else {
          y = e.clientY;
        }
        if (y < 80) return;

        // Only respond to touch/click on video area
        let x;
        if (e.type.startsWith('touch')) {
          x = e.touches[0].clientX;
        } else {
          x = e.clientX;
        }
        const width = video.offsetWidth;
        const now = Date.now();

        if (!handleGesture.tapCount) handleGesture.tapCount = 0;
        if (!handleGesture.lastTapTime) handleGesture.lastTapTime = 0;

        // Reset tap count if too much time has passed
        if (now - handleGesture.lastTapTime > 400) {
          handleGesture.tapCount = 0;
        }
        handleGesture.tapCount++;
        handleGesture.lastTapTime = now;

        if (tapTimeout) clearTimeout(tapTimeout);

        // Triple tap triggers skip
        if (handleGesture.tapCount === 4) {
          if (x > width * 0.6) {
            video.currentTime = Math.min(video.duration, video.currentTime + 10);
            showSkipNotification('forward');
          } else if (x < width * 0.4) {
            video.currentTime = Math.max(0, video.currentTime - 10);
            showSkipNotification('backward');
          }
          handleGesture.tapCount = 0;
        } else if (handleGesture.tapCount === 1) {
          // Single tap toggles play/pause immediately
          tapTimeout = setTimeout(() => {
            if (handleGesture.tapCount === 1) {
              if (video.paused) {
                video.play();
              } else {
                video.pause();
              }
              const overlay = document.getElementById('playPauseOverlay');
              if (overlay) {
                const icon = overlay.querySelector('i');
                if (video.paused) {
                  icon.className = 'fas fa-play';
                } else {
                  icon.className = 'fas fa-pause';
                }
                overlay.classList.add('visible');
                setTimeout(() => overlay.classList.remove('visible'), 400);
              }
            }
            handleGesture.tapCount = 1;
          }, 20);
        }
      }

      // Attach listeners only in landscape mode
      function attachGestureListeners() {
        if (!video) return;
        // Remove previous listeners
        videoContainer.removeEventListener('touchstart', handleGesture);
        videoContainer.removeEventListener('mousedown', handleGesture);
        if (isLandscape()) {
          videoContainer.addEventListener('touchstart', handleGesture);
          videoContainer.addEventListener('mousedown', handleGesture);
        }
      }

      // Re-attach on orientation change
      window.addEventListener('resize', attachGestureListeners);
      window.addEventListener('orientationchange', attachGestureListeners);
      attachGestureListeners();
    });
  </script>
  <style>
    :root {
      --netflix-red: #e50914;
      --netflix-black: #141414;
      --netflix-dark-gray: #2f2f2f;
      --netflix-light-gray: #808080;
      --netflix-white: #ffffff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Netflix Sans', Arial, sans-serif;
      background-color: #000;
      color: var(--netflix-white);
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin: 0;
      padding: 0;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(229, 9, 20, 0.7);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(229, 9, 20, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(229, 9, 20, 0);
      }
    }

    @keyframes glow {
      0% {
        border-color: rgba(255, 255, 255, 0.15);
      }

      50% {
        border-color: rgba(229, 9, 20, 0.8);
      }

      100% {
        border-color: rgba(255, 255, 255, 0.15);
      }
    }

    .back-button {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(30, 32, 36, 0.7);
      color: white;
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      border: 1.5px solid rgba(255, 255, 255, 0.18);
    }

    .back-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .back-button:hover {
      background: rgba(40, 42, 46, 0.85);
      transform: scale(1.08);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .back-button:hover::before {
      opacity: 1;
    }

    .back-button:active {
      transform: scale(0.95);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.1s ease;
    }

    .back-button:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
    }

    .back-button i {
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .back-button:hover i {
      transform: translateX(-2px) scale(1.1);
    }

    .back-button:active i {
      transform: translateX(-1px) scale(0.95);
    }

    /* Tooltip for back button */
    @media (min-width: 769px) {
      .back-button::after {
        content: attr(aria-label);
        position: absolute;
        top: calc(100% + 12px);
        left: 50%;
        transform: translateX(-50%) translateY(-10px);
        background: rgba(20, 22, 35, 0.98);
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 500;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 10000;
        max-width: 120px;
        text-align: center;
      }

      .back-button:hover::after {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(0);
      }
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .back-button {
        width: 42px;
        height: 42px;
        font-size: 16px;
        top: 15px;
        left: 15px;
      }
    }

    .video-container {
      position: relative;
      width: 100vw;
      height: 90vh;
      border-radius: 12px;
      overflow: hidden;
      max-width: 100vw;
      border: 2px solid rgba(255, 255, 255, 0.2);
      background-color: #000;
      overflow: hidden;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      margin-right: auto;
      margin-left: 0;
    }

    @media (max-width: 768px),
    (max-height: 500px),
    (pointer: coarse) {

      html,
      body {
        margin: 0 !important;
        padding: 0 !important;
        width: 100svw !important;
        height: 100svh !important;
        overflow: hidden !important;
        background: #000 !important;
      }

      .video-container {
        position: fixed !important;
        inset: 0 !important;
        /* Expand into safe areas to avoid side gutters on iOS */
        margin-left: calc(-1 * env(safe-area-inset-left, 0px)) !important;
        margin-right: calc(-1 * env(safe-area-inset-right, 0px)) !important;
        width: calc(100svw + env(safe-area-inset-left, 0px) + env(safe-area-inset-right, 0px)) !important;
        width: calc(100vw + env(safe-area-inset-left, 0px) + env(safe-area-inset-right, 0px)) !important;
        height: 100svh !important;
        height: 100dvh !important;
        max-width: none !important;
        max-height: none !important;
        border: none !important;
        border-radius: 0 !important;
        box-shadow: none !important;
        background: #000 !important;
        transform: translateZ(0);
      }

      /* Non-fullscreen override: avoid shifting left; use true viewport width */
      body:not(.pseudo-fullscreen) .video-container,
      .video-container:not(:fullscreen) {
        margin-left: 0 !important;
        margin-right: 0 !important;
        width: 100svw !important;
        left: 0 !important;
        right: 0 !important;
        border: none !important;
        border-radius: 0 !important;
        box-shadow: none !important;
      }

      /* In landscape non-fullscreen, apply tiny overscan to hide sub-pixel gutters */
      @media (orientation: landscape) {

        body:not(.pseudo-fullscreen) .video-container,
        .video-container:not(:fullscreen) {
          left: -4px !important;
          right: -4px !important;
          width: calc(70svw + 380px) !important;
        }
      }

      /* Default (non-fullscreen) on mobile: show full frame */
      #video {
        object-fit: contain;
        display: block;
        background: #000;
      }
    }

    /* In fullscreen/pseudo-fullscreen, fill the screen (crop edges) */
    :fullscreen #video,
    :-webkit-full-screen #video,
    :-moz-full-screen #video,
    body.pseudo-fullscreen #video {
      object-fit: cover;
    }

    #video {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }


    .controls-container {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
      padding: 20px;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 10;
      overflow: visible;
    }

    .controls-container.visible {
      opacity: 1;
    }

    .controls {
      overflow: visible;
    }

    .left-controls,
    .right-controls {
      overflow: visible;
    }

    .progress-container {
      width: 100%;
      height: 4px;
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      margin: 15px 0;
      overflow: hidden;
      cursor: pointer;
    }

    .progress-bar {
      height: 100%;
      background-color: var(--netflix-red);
      width: 0%;
      position: relative;
      transition: width 0.1s linear;
    }

    .progress-buffer {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.3);
      width: 0%;
    }

    .time-display {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      color: var(--netflix-white);
      font-weight: 500;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6);
      margin-left: 15px;
    }

    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .left-controls,
    .right-controls {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .control-btn {
      background: none;
      border: none;
      color: var(--netflix-white);
      font-size: 20px;
      cursor: pointer;
      padding: 5px;
      outline: none;
      transition: transform 0.2s;
      position: relative;
    }

    .control-btn:active {
      transform: scale(0.9);
    }

    /* Tooltip styles for control buttons */
    @media (min-width: 769px) {
      .control-btn::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: calc(100% + 12px);
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background: rgba(20, 22, 35, 0.98);
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 500;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 10000;
        max-width: 120px;
        text-align: center;
      }

      .control-btn::before {
        content: '';
        position: absolute;
        bottom: calc(100% + 6px);
        left: 50%;
        transform: translateX(-50%);
        border-width: 6px;
        border-style: solid;
        border-color: rgba(20, 22, 35, 0.98) transparent transparent transparent;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
        z-index: 10000;
      }

      .control-btn:hover::after {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(0);
      }

      .control-btn:hover::before {
        opacity: 1;
        visibility: visible;
      }
    }

    .skip-btn {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: 1.5px solid rgba(255, 255, 255, 0.25);
      color: white;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: visible;
    }

    .skip-btn .glow-effect {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at center, rgba(255, 255, 255, 0.15), transparent 70%);
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      border-radius: 50%;
    }

    .skip-btn:hover {
      transform: scale(1.12);
      border-color: rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.08);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.15),
        0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .skip-btn:hover .glow-effect {
      opacity: 1;
    }

    .skip-btn:active {
      transform: scale(0.92);
      background: rgba(255, 255, 255, 0.12);
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.2),
        0 2px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.1s ease;
    }

    .skip-btn i {
      font-size: 15px !important;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      z-index: 1;
    }

    .skip-btn:hover i {
      transform: scale(1.15);
    }

    .skip-btn:active i {
      transform: scale(0.9);
    }

    .skip-btn span {
      display: none;
    }

    @media (min-width: 769px) {
      .skip-btn::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: calc(100% + 18px);
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background: rgba(20, 22, 35, 0.98);
        color: white;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 11px;
        font-weight: 500;
        white-space: nowrap;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 10000;
        max-width: 120px;
        text-align: center;
      }

      .skip-btn::before {
        content: '';
        position: absolute;
        bottom: calc(100% + 12px);
        left: 50%;
        transform: translateX(-50%);
        border-width: 6px;
        border-style: solid;
        border-color: rgba(20, 22, 35, 0.98) transparent transparent transparent;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none;
        z-index: 10000;
      }

      .skip-btn:hover::after {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(0);
      }

      .skip-btn:hover::before {
        opacity: 1;
        visibility: visible;
      }
    }

    @media (max-width: 768px) {
      .skip-btn {
        width: 38px;
        height: 38px;
      }

      .skip-btn i {
        font-size: 14px !important;
      }
    }

    .volume-container {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .volume-slider {
      width: 0;
      opacity: 0;
      transition: all 0.3s ease;
      background: rgba(0, 0, 0, 0.7);
      height: 30px;
      border-radius: 15px;
      padding: 0 10px;
      display: flex;
      align-items: center;
    }

    .volume-container:hover .volume-slider {
      width: 100px;
      opacity: 1;
    }

    .volume-slider input[type="range"] {
      width: 100%;
      height: 3px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--netflix-light-gray);
      outline: none;
      border-radius: 3px;
    }

    .volume-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--netflix-white);
      cursor: pointer;
    }

    .scrubber {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
    }

    .scrubber .scrubber-line {
      position: absolute;
      top: 0;
      left: 50%;
      width: 2px;
      height: 100%;
      background-color: var(--netflix-red);
      display: none;
    }

    .scrubber .scrubber-time {
      position: absolute;
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      display: none;
    }

    .scrubber.active .scrubber-line,
    .scrubber.active .scrubber-time {
      display: block;
    }

    .play-pause-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 8;
    }

    .play-pause-overlay.visible {
      opacity: 1;
    }

    .play-pause-icon {
      font-size: 80px;
      color: white;
      text-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
    }

    .volume-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--netflix-white);
      cursor: pointer;
    }

    .scrubber {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
    }

    .scrubber .scrubber-line {
      position: absolute;
      top: 0;
      left: 50%;
      width: 2px;
      height: 100%;
      background-color: var(--netflix-red);
      display: none;
    }

    .scrubber .scrubber-time {
      position: absolute;
      top: -30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      display: none;
    }

    .scrubber.active .scrubber-line,
    .scrubber.active .scrubber-time {
      display: block;
    }

    .play-pause-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 8;
    }

    .play-pause-overlay.visible {
      opacity: 1;
    }

    .play-pause-icon {
      font-size: 80px;
      color: white;
      text-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      opacity: 0.9;
    }

    @media (max-width: 768px) {
      .control-btn {
        font-size: 18px;
      }

      .volume-container:hover .volume-slider {
        width: 80px;
      }

      .settings-content {
        padding: 15px 20px 20px;
      }

      .setting-group {
        margin-bottom: 15px;
      }

      .setting-group label {
        display: block;
        margin-bottom: 6px;
        font-size: 14px;
        color: #b3b3b3;
      }

      .settings-panel {
        transform: translate(-50%, -50%);
        background: rgba(20, 20, 20, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        width: 90%;
        max-width: 400px;
        max-height: 80vh;
        overflow-y: auto;
        z-index: 2147483647;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        color: white;
        font-family: 'Netflix Sans', Arial, sans-serif;
        animation: fadeIn 0.3s ease;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -45%);
      }

      to {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .settings-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 500;
    }

    .close-settings {
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .close-settings:hover {
      opacity: 1;
    }

    .settings-content {
      padding: 15px 20px 20px;
    }

    .setting-group {
      margin-bottom: 15px;
    }

    .setting-group label {
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
      color: #b3b3b3;
    }

    .setting-group select,
    .setting-group input[type="range"],
    .setting-group input[type="color"] {
      width: 100%;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: white;
      font-family: inherit;
      font-size: 14px;
      margin-bottom: 5px;
    }

    .setting-group input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      /* Standard property */
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      padding: 0;
      margin: 10px 0;
    }

    .setting-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #e50914;
      border-radius: 50%;
      cursor: pointer;
    }

    .setting-group input[type="color"] {
      height: 36px;
      padding: 2px;
      cursor: pointer;
    }

    .setting-group input[type="checkbox"] {
      margin-right: 8px;
    }

    #subtitleSizeValue,
    #subtitleBgOpacityValue {
      display: inline-block;
      min-width: 40px;
      text-align: right;
      font-size: 13px;
      color: #b3b3b3;
    }

    /* Fullscreen adjustments */
    :fullscreen .settings-panel,
    :-webkit-full-screen .settings-panel,
    :-moz-full-screen .settings-panel {
      position: fixed !important;
      z-index: 2147483647 !important;
    }

    /* Subtitle Notification */
    .subtitle-notification {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 8px 20px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
    }

    .subtitle-notification.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }

    .subtitle-notification i {
      font-size: 16px;
    }

    /* Skip notification */
    .skip-notification {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      z-index: 100000;
      opacity: 0;
      pointer-events: none;
    }

    .skip-notification.visible {
      opacity: 1;
    }

    .skip-notification.forward {
      right: 15%;
      left: auto;
    }

    .skip-notification.backward {
      left: 15%;
      right: auto;
    }

    .skip-notification i {
      font-size: 48px;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
    }

    .skip-notification .skip-text {
      font-size: 40px;
      font-weight: 700;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
    }

    /* Native video subtitles are hidden in favor of custom display */
    video::cue {
      display: none !important;
    }

    /* Custom subtitle container */
    .video-subtitles {
      position: fixed;
      bottom: 18.9%;
      left: 50%;
      transform: translateX(-50%);
      max-width: 90%;
      font-size: 26.5px;
      color: white;
      padding: 10px 20px;
      border-radius: 14px;
      text-align: center;
      line-height: 1.4;
      white-space: pre-line;
      word-break: break-word;
      text-shadow: 1px 1px 2px black,
        -1px -1px 2px black,
        1px -1px 2px black,
        -1px 1px 2px black;
      -webkit-text-stroke: 0.5px rgba(0, 0, 0, 0.7);
      font-family: Arial, sans-serif;
      pointer-events: none;
      z-index: 2147483647;
      will-change: transform, opacity;
      transition: opacity 0.2s ease;
    }


    /* --- Enhanced Player Features --- */
    .video-loading-spinner {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 48px;
      height: 48px;
      margin: -24px 0 0 -24px;
      border: 4px solid rgba(255, 255, 255, 0.18);
      border-top: 4px solid #3290ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 1000;
      pointer-events: none;
    }

    @keyframes spin {
      100% {
        transform: rotate(360deg);
      }
    }

    .skip-intro-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      z-index: 1001;
      padding: 0.5em 1.2em;
      background: #3290ff;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.18);
      display: none;
    }

    .skip-intro-btn:hover {
      background: #2673c9;
    }

    .skip-intro-btn:active {
      transform: scale(0.95);
    }

    /* Settings menu styles */
    .settings-menu,
    .settings-submenu {
      position: fixed !important;
      bottom: 120px !important;
      right: 20px !important;
      transform: none !important;
      background: rgba(20, 20, 20, 0.95) !important;
      color: #fff !important;
      border-radius: 8px !important;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5) !important;
      padding: 0 !important;
      min-width: 240px !important;
      z-index: 999999 !important;
      display: none;
      flex-direction: column !important;
      font-size: 1.05em !important;
      overflow: visible !important;
      transition: all 0.3s ease !important;
      opacity: 1 !important;
      visibility: visible !important;
      pointer-events: auto !important;
    }

    .settings-item {
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      width: 100%;
    }

    .settings-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      transition: background-color 0.2s;
    }

    .settings-item:hover .settings-header {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .current-value {
      margin-right: 8px;
      opacity: 0.7;
      font-size: 0.9em;
    }

    .settings-submenu {
      display: none;
    }

    .submenu-header {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background-color: rgba(0, 0, 0, 0.3);
      font-weight: 600;
    }

    .submenu-header button {
      background: none;
      border: none;
      color: white;
      margin-right: 12px;
      cursor: pointer;
      padding: 4px;
    }

    .submenu-options {
      max-height: 300px;
      overflow-y: auto;
    }

    .submenu-option {
      padding: 12px 16px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .submenu-option:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .submenu-option.selected {
      background-color: rgba(255, 255, 255, 0.1);
      position: relative;
    }

    .submenu-option.selected::after {
      content: "✓";
      position: absolute;
      right: 16px;
      color: #e50914;
    }

    /* Fullscreen video container - fill entire screen without black spots */
    :fullscreen .video-container,
    :-webkit-full-screen .video-container,
    :-moz-full-screen .video-container,
    .fullscreen .video-container {
      width: 100vw !important;
      height: 100vh !important;
      max-width: 100vw !important;
      max-height: 100vh !important;
      border-radius: 0 !important;
      border: none !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    :fullscreen body,
    :-webkit-full-screen body,
    :-moz-full-screen body,
    .fullscreen body {
      padding: 0 !important;
      margin: 0 !important;
    }

    /* Fullscreen support for menus - using the same approach as custom subtitles */
    :fullscreen .settings-menu,
    :fullscreen .settings-submenu,
    :-webkit-full-screen .settings-menu,
    :-webkit-full-screen .settings-submenu,
    :-moz-full-screen .settings-menu,
    :-moz-full-screen .settings-submenu,
    .fullscreen .settings-menu,
    .fullscreen .settings-submenu {
      position: fixed !important;
      bottom: 300px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      z-index: 2147483647 !important;
      /* Maximum z-index value */
    }

    /* Additional fullscreen support for specific browsers */
    .video-container:fullscreen .settings-menu,
    .video-container:fullscreen .settings-submenu,
    .video-container:-webkit-full-screen .settings-menu,
    .video-container:-webkit-full-screen .settings-submenu,
    .video-container:-moz-full-screen .settings-menu,
    .video-container:-moz-full-screen .settings-submenu {
      position: fixed !important;
      bottom: 300px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      z-index: 2147483647 !important;
    }

    /* Pseudo-fullscreen mode (CSS-only fallback when Fullscreen API fails) */
    body.pseudo-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100vw;
      height: 100vh;
      margin: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      z-index: 9999;
    }

    body.pseudo-fullscreen .back-button {
      display: none;
    }

    body.pseudo-fullscreen .video-container {
      width: 100vw !important;
      height: 100vh !important;
      max-width: 100vw !important;
      border: none !important;
      border-radius: 0 !important;
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      z-index: 9998;
    }

    body.pseudo-fullscreen .controls-container,
    body.pseudo-fullscreen .play-pause-overlay {
      z-index: 9999 !important;
    }

    /* Close button removed */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: none;
      }
    }
  </style>

<body>
  <!-- Add allowfullscreen attribute to the video container -->
  <div class="video-container" id="videoContainer" allowfullscreen>
    <button id="backButton" class="back-button" aria-label="Back">
      <i class="fas fa-arrow-left"></i>
    </button>
    <video id="video" playsinline>
      <source src="" type="video/mp4">
      <!-- If you have a subtitle file, set the src below. Otherwise, remove the <track> to avoid errors. -->
      <!-- Example: <track kind="subtitles" srclang="en" label="English" src="subtitles/lokah-en.vtt" default> -->
    </video>

    <!-- Movie Info Overlay -->
    <div class="movie-info-overlay">
      <h1 id="movieTitle"></h1>
      <div class="movie-meta">
        <span id="movieYear"></span>
        <span id="movieRating"></span>
        <span id="movieDuration"></span>
      </div>
      <p id="movieDescription"></p>
    </div>

    <div class="play-pause-overlay" id="playPauseOverlay">
      <div class="play-pause-icon">
        <i class="fas fa-pause"></i>
      </div>
    </div>

    <!-- Skip notification -->
    <div class="skip-notification" id="skipNotification">
      <i class="fas fa-forward"></i>
      <div class="skip-text" id="skipText">+10s</div>
    </div>

    <div class="double-tap-indicator" id="rewindIndicator">
      <i class="fas fa-backward"></i>
      <span>10s</span>
    </div>

    <div class="double-tap-indicator right" id="forwardIndicator">
      <span>10s</span>
      <i class="fas fa-forward"></i>
    </div>

    <div class="scrubber" id="scrubber">
      <div class="scrubber-line"></div>
      <div class="scrubber-time">00:00</div>
    </div>

    <div class="controls-container" id="controlsContainer">
      <div class="progress-container" id="progressContainer">
        <div class="progress-bar" id="progressBar">
          <div class="progress-buffer" id="progressBuffer"></div>
        </div>
      </div>
      <div class="controls">
        <div class="left-controls">
          <button class="control-btn" id="playPauseBtn" data-tooltip="Play/Pause">
            <i class="fas fa-play"></i>
          </button>
          <button class="skip-btn" id="skipBackwardBtn" data-tooltip="Rewind 10s">
            <i class="fas fa-backward"></i>
          </button>
          <button class="skip-btn" id="skipForwardBtn" data-tooltip="Forward 10s">
            <i class="fas fa-forward"></i>
          </button>
          <div class="volume-container">
            <button class="control-btn" id="muteBtn" data-tooltip="Mute/Unmute">
              <i class="fas fa-volume-up"></i>
            </button>
            <div class="volume-slider">
              <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
            </div>
          </div>
          <div class="time-display">
            <span id="timeDisplay">0:00 / 0:00</span>
          </div>
        </div>
        <div class="right-controls">
          <div class="screen-mode-container" style="display:inline-flex;gap:4px;align-items:center;margin-left:8px;">
            <button class="control-btn" id="screenModeToggle" data-tooltip="Stretch" title="Stretch">
              <i class="fas fa-expand-arrows-alt" id="screenModeIcon"></i>
            </button>
          </div>
          <button class="control-btn" id="subtitleBtn" data-tooltip="Subtitles">
            <i class="fas fa-closed-captioning"></i>
          </button>
          <button class="control-btn" id="settingsBtn" data-tooltip="Settings">
            <i class="fas fa-cog"></i>
          </button>
          <button class="control-btn" id="fullscreenBtn" data-tooltip="Fullscreen">
            <i class="fas fa-expand"></i>
          </button>
        </div>
      </div>
    </div>

    <button class="skip-intro-btn" id="skipIntroBtn" style="display:none;">Skip Intro</button>
  </div>

  <style>
    /* Modern settings menu styles */
    #settingsMenu {
      position: fixed;
      display: none;
      flex-direction: column;
      background: rgba(30, 32, 36, 0.7);
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      opacity: 0;
      transform: translateY(-10px) scale(0.98);
      transition: opacity 0.2s ease, transform 0.2s ease;
      backdrop-filter: blur(12px);
      border: 1.5px solid rgba(255, 255, 255, 0.18);
      min-width: 180px;
      max-width: 220px;
      padding: 18px 0 10px 0;
      z-index: 2147483647;
      font-family: 'Segoe UI', 'Netflix Sans', Arial, sans-serif;
      font-size: 16px;
      color: #fff;
    }

    @keyframes menuFadeIn {
      0% {
        opacity: 0;
        transform: translateY(20px) scale(0.97);
      }

      60% {
        opacity: 0.7;
        transform: translateY(-2px) scale(1.03);
      }

      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    #settingsMenu .settings-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 10px;
      padding: 0 24px;
      color: #fff;
      letter-spacing: 0.02em;
    }

    #settingsMenu .settings-option {
      padding: 12px 24px;
      border: none;
      background: none;
      color: #fff;
      font-size: 16px;
      border-radius: 8px;
      margin: 2px 0;
      cursor: pointer;
      transition: background 0.18s, color 0.18s, transform 0.18s;
    }

    #settingsMenu .settings-option:hover,
    #settingsMenu .settings-option:focus {
      background: rgba(255, 255, 255, 0.10);
      color: #e0e0e0;
      transform: scale(1.03);
    }

    #settingsMenu .settings-option.selected {
      background: rgba(255, 255, 255, 0.18);
      color: #ffd700;
      font-weight: 500;
    }

    #settingsMenu .settings-divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.10);
      margin: 10px 0;
      border-radius: 1px;
    }

    #settingsMenu .settings-footer {
      padding: 8px 24px 0 24px;
      font-size: 13px;
      color: #b0b0b0;
      text-align: right;
    }

    @media (max-width: 600px) {
      #settingsMenu {
        min-width: 90vw;
        max-width: 98vw;
        padding: 12px 0 6px 0;
        font-size: 15px;
        border-radius: 12px;
      }

      #settingsMenu .settings-title {
        font-size: 16px;
        padding: 0 16px;
      }

      #settingsMenu .settings-option {
        padding: 10px 16px;
        font-size: 15px;
        border-radius: 7px;
      }

      #settingsMenu .settings-footer {
        padding: 6px 16px 0 16px;
        font-size: 12px;
      }
    }
  </style>
  <div id="settingsMenu" class="settings-menu">
    <div class="settings-item" id="playbackSpeedMenu">
      <div class="settings-header">
        <span>Playback Speed</span>
        <span class="current-value">Normal</span>
        <i class="fas fa-chevron-right"></i>
      </div>
    </div>
  </div>

  <!-- Playback Speed Submenu - using CSS for styling -->
  <style>
    /* Modern playback speed submenu styles (no animation) */
    #playbackSpeedSubmenu {
      margin-left: -230px !important;
      margin-bottom: 75px !important;
      overflow: hidden !important;
      max-height: none !important;
      height: auto !important;
      position: fixed !important;
      opacity: 0;
      visibility: visible;
      flex-direction: column;
      background: rgba(30, 32, 36, 0.7);
      border-radius: 16px;
      transform: translateY(-10px) scale(0.98);
      transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s ease;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      backdrop-filter: blur(12px);
      border: 1.5px solid rgba(255, 255, 255, 0.18);
      min-width: 150px;
      max-width: 180px;
      padding: 14px 0 8px 0;
      z-index: 2147483647;
      font-family: 'Segoe UI', 'Netflix Sans', Arial, sans-serif;
      font-size: 16px;
      color: #fff;
      transition: box-shadow 0.25s, background 0.25s, transform 0.25s;
      overflow-x: hidden !important;

    }

    #playbackSpeedSubmenu .submenu-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 17px;
      font-weight: 600;
      margin-bottom: 10px;
      padding: 10px 20px;
      color: #fff;
      letter-spacing: 0.01em;
      background: none;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    #playbackSpeedSubmenu .submenu-option {
      padding: 10px 20px;
      border: none;
      background: none;
      color: #fff;
      font-size: 16px;
      border-radius: 8px;
      margin: 2px 0;
      cursor: pointer;
      transition: background 0.18s, color 0.18s, transform 0.18s;
      overflow-x: hidden !important;
    }

    #playbackSpeedSubmenu .submenu-option:hover,
    #playbackSpeedSubmenu .submenu-option:focus {
      background: rgba(255, 255, 255, 0.10);
      color: #e0e0e0;
      transform: scale(1.03);
    }

    #playbackSpeedSubmenu .submenu-option.selected {
      background: rgba(255, 255, 255, 0.18);
      color: #ffd700;
      font-weight: 500;
    }

    /* Completely remove all scrollbars and ensure content fits */
    #playbackSpeedSubmenu,
    #playbackSpeedSubmenu * {
      overflow: hidden !important;
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
    }

    #playbackSpeedSubmenu::-webkit-scrollbar,
    #playbackSpeedSubmenu *::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }

    #playbackSpeedSubmenu .submenu-options {
      height: auto !important;
      max-height: none !important;
      overflow: visible !important;
    }

    #playbackSpeedSubmenu.visible {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scale(1);
    }

    @media (max-width: 600px) {
      #playbackSpeedSubmenu {
        min-width: 80vw;
        max-width: 95vw;
        padding: 10px 0 6px 0;
        font-size: 15px;
        border-radius: 12px;
        overflow-x: hidden !important;
      }

      #playbackSpeedSubmenu .submenu-header {
        font-size: 15px;
        padding: 0 12px;
        overflow-x: hidden !important;
      }

      #playbackSpeedSubmenu .submenu-option {
        padding: 8px 12px;
        font-size: 15px;
        border-radius: 7px;
        overflow-x: hidden !important;
      }
    }
  </style>
  <div id="playbackSpeedSubmenu" class="settings-submenu">
    <div class="submenu-header">
      <button id="backToMainSettings"><i class="fas fa-arrow-left"></i></button>
      <span>Playback Speed</span>
    </div>
    <div class="submenu-options">
      <div class="submenu-option" data-value="0.5">0.5x</div>
      <div class="submenu-option" data-value="0.75">0.75x</div>
      <div class="submenu-option" data-value="1" data-label="Normal">Normal</div>
      <div class="submenu-option" data-value="1.25">1.25x</div>
      <div class="submenu-option" data-value="1.5">1.5x</div>
      <div class="submenu-option" data-value="1.75">1.75x</div>
      <div class="submenu-option" data-value="2">2x</div>
    </div>
  </div>

  <!-- Subtitle Settings Panel -->
  <div id="subtitleSettings" class="settings-panel" style="display: none;">
    <div class="settings-header">
      <h3>Subtitle Settings</h3>
      <button class="close-settings">×</button>
    </div>
    <div class="settings-content">
      <div class="setting-group">
        <label>Position</label>
        <select id="subtitlePosition">
          <option value="bottom">Bottom</option>
          <option value="middle">Middle</option>
          <option value="top">Top</option>
        </select>
      </div>
      <div class="setting-group">
        <label>Font Size</label>
        <input type="range" id="subtitleSize" min="12" max="48" value="20">
        <span id="subtitleSizeValue">20px</span>
      </div>
      <div class="setting-group">
        <label>Text Color</label>
        <input type="color" id="subtitleColor" value="#ffffff">
      </div>
      <div class="setting-group">
        <label>Background Color</label>
        <input type="color" id="subtitleBgColor" value="#000000">
        <input type="range" id="subtitleBgOpacity" min="0" max="10" value="8">
        <span id="subtitleBgOpacityValue">80%</span>
      </div>
      <div class="setting-group">
        <label>Font Family</label>
        <select id="subtitleFont">
          <option value="'Netflix Sans', Arial, sans-serif">Netflix Sans</option>
          <option value="Arial, sans-serif">Arial</option>
          <option value="'Helvetica Neue', Helvetica, Arial, sans-serif">Helvetica</option>
          <option value="'Times New Roman', Times, serif">Times New Roman</option>
          <option value="'Courier New', Courier, monospace">Courier New</option>
        </select>
      </div>
      <div class="setting-group">
        <label>Text Shadow</label>
        <input type="checkbox" id="subtitleShadow" checked>
      </div>
      <div class="setting-group">
        <label>Background Style</label>
        <select id="subtitleBgStyle">
          <option value="box">Box</option>
          <option value="full">Full Width</option>
          <option value="none">None</option>
        </select>
      </div>
    </div>
  </div>

  <script>


    // Movie database - maps movie titles to their sources
    const movieDatabase = {
      /* Done */
      "tourist family": {
        src: "https://ia601005.us.archive.org/3/items/tourist-family-2025-hindi-1080p/Tourist%20Family-%282025%29-Hindi-1080p.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/tourist-family-2025-hindi-1080p/Tourist-Family-%282025%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "manjummel boys": {
        src: "https://ia800304.us.archive.org/11/items/manjummel-boys-2024/Manjummel%20Boys%20%282024%29.ia.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/manjummel-boys-2024/Manjummel-Boys-%282024%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "kaithi": {
        src: "https://ia601009.us.archive.org/23/items/kaithi-2019-1080p-hindi/Kaithi%2B2019%2B1080p%2BHindi.ia.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/kaithi-2019-1080p-hindi/Kaithi-2019-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "vikram": {
        src: "https://ia601007.us.archive.org/8/items/vikram-2022-lcu.mp-4/Vikram-%282022%29-%5BLCU%5D.mp4.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/vikram-2022-lcu.mp-4/Vikram-%282022%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      "leo": {
        src: "https://ia600602.us.archive.org/19/items/leo-2023-south-hindi-dubbed-un-cut-hd-1080p/Leo-%282023%29-South-Hindi-Dubbed-UnCut-HD-1080p.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/leo-2023-south-hindi-dubbed-un-cut-hd-1080p/Leo-%282023%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "coolie": {
        src: "https://ia601002.us.archive.org/23/items/coolie-2025-1080p-hindi/Coolie-2025-1080p-Hindi.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/coolie-2025-1080p-hindi/Coolie-%282025%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "maharaja": {
        src: "https://ia800404.us.archive.org/14/items/maharaja-2024-hindi-tamil-dual-audio-un-cut-movie-hd-1080p-esub/Maharaja%20%282024%29%20%28Hindi%20%2B%20Tamil%29%20Dual%20Audio%20UnCut%20Movie%20HD%201080p%20ESub.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/maharaja-2024-hindi-tamil-dual-audio-un-cut-movie-hd-1080p-esub/Maharaja-%282024%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "hi papa": {
        src: "https://ia600801.us.archive.org/34/items/hi-papa-hi-nanna-2023-hindi-1080p/Hi%20Papa-%28Hi%20Nanna%29-%282023%29-%7BHindi-1080p%29.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/hi-papa-hi-nanna-2023-hindi-1080p/Hi-Nanna-%282023%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "kantara": {
        src: "https://ia600404.us.archive.org/34/items/kantara-2022-hindi-dubbed-1080p/Kantara%20%282022%29%20Hindi%20Dubbed%201080p.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/kantara-2022-hindi-dubbed-1080p/Kantara-%282022%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "hridayam": {
        src: "https://ia601003.us.archive.org/33/items/hridayam-2022-hindi-1080p/Hridayam%20%282022%29%20Hindi%201080p.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/hridayam-2022-hindi-1080p/Hridayam-%282022%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      "lokah chapter 1": {
        src: "https://ia601709.us.archive.org/32/items/lokah.-chapter.-1-chandra.-2025-hindi/Lokah.Chapter.1-Chandra.2025-hindi.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/lokah.-chapter.-1-chandra-en/Lokah.Chapter.1-Chandra-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "lucky bhaskar": {
        src: "https://ia600301.us.archive.org/4/items/lucky-baskhar-2024-hindi-hd-1080p/Lucky-Baskhar-%282024%29-Hindi-HD-1080p.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/lucky-baskhar-2024-hindi-hd-1080p/Lucky-Baskhar-2024-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "court - state vs. a nobody": {
        src: "https://ia601001.us.archive.org/20/items/court-state-vs-a-nobody-2025-hindi-hd-1080p/Court-State-Vs-A-Nobody-%282025%29-Hindi-HD-1080p.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/court-state-vs-a-nobody-2025-hindi-hd-1080p/court-state-vs-a-nobody-2025-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "master": {
        src: "https://ia902807.us.archive.org/0/items/master-2021-1080p-hindi/Master-2021-1080p-Hindi.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/master-2021-1080p-hindi/MASTER-%282021%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "hit: the first case": {
        src: "https://ia801003.us.archive.org/22/items/hit-the-first-case-2020-1080p-hindi/HIT-The-First-Case-2020-1080p-Hindi.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/hit-the-first-case-2020-1080p-hindi/HIT-The-First-Case-%282020%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "hit: the second case": {
        src: "https://ia801003.us.archive.org/22/items/hit-the-2nd-case-2022-1080p-hindi/HIT-The-2nd-Case-2022-1080p-Hindi.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/hit-the-2nd-case-2022-1080p-hindi/HIT-The-Second-Case-2022-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "hit: the third case": {
        src: "https://ia800505.us.archive.org/35/items/hit-the-third-case-2025-1080p-hindi/HIT-The-Third-Case-2025-1080p-Hindi.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/hit-the-third-case-2025-1080p-hindi/HIT-The-Third-Case-%282025%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "retro": {
        src: "https://ia600301.us.archive.org/10/items/retro-2025-hindi-1080p/Retro-%282025%29-Hindi-1080p.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/retro-2025-hindi-1080p/Retro-2025-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "kuberaa": {
        src: "https://ia601302.us.archive.org/0/items/kuberaa-2025-hindi-1080p/Kuberaa-%282025%29-Hindi-1080p.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/kuberaa-2025-hindi-1080p/kuberaa-2025-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "thalaivan thalaivii": {
        src: "https://ia600201.us.archive.org/14/items/thalaivan-thalaivii-2025-hindi-1080p/Thalaivan-Thalaivii-%282025%29-Hindi-1080p.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/thalaivan-thalaivii-2025-hindi-1080p/Thalaivan-Thalaivii-%282025%29-en.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "dil se..": {
        src: "https://ia801607.us.archive.org/32/items/dil-se..-1998/Dil%20Se..%20%281998%29.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/dil-se..-1998/Dil%20Se..%281998%29.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "mohabbatein": {
        src: "https://ia601207.us.archive.org/5/items/mohabbatein-2000_202511/Mohabbatein-%282000%29.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/mohabbatein-2000_202511/Mohabbatein-%282000%29-Eng.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "bhool bhulaiyaa": {
        src: "https://ia600500.us.archive.org/23/items/bhool-bhulaiyaa-2007/Bhool-Bhulaiyaa-%282007%29.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/bhool-bhulaiyaa-2007/Bhool-Bhulaiyaa-%282007%29.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "dude": {
        src: "https://ia903101.us.archive.org/35/items/dude.-2025.1080p-hindi/Dude.2025.1080p-Hindi.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/dude.-2025.1080p-hindi/Dude.2025.1080p-eng.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "they call him og": {
        src: "https://ia903104.us.archive.org/12/items/they-call-him-og-2025-hindi_202511/They%20Call%20Him%20OG%20%282025%29-%28Hindi%29.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/they-call-him-og-2025-hindi_202511/They%20Call%20Him%20OG%20%282025%29-%28Hindi%29.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "bombay": {
        src: "https://ia601700.us.archive.org/11/items/bombay-1995_202511/Bombay-1995.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/bombay-1995_202511/Bombay-1995-eng.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
      /* Done */
      "dilwale dulhania le jayenge": {
        src: "https://ia801701.us.archive.org/24/items/dilwale-dulhania-le-jayenge-1995_202511/Dilwale%20Dulhania%20Le%20Jayenge%20%281995%29.mp4",
        type: "mp4",
        subtitles: [
          { src: 'https://archive.org/download/dilwale-dulhania-le-jayenge-1995_202511/Dilwale%20Dulhania%20Le%20Jayenge%20%281995%29.vtt', srclang: 'en', label: 'English', default: false }
        ]
      },
    };

    document.addEventListener('DOMContentLoaded', () => {
      // Diagnostic check for fullscreen compatibility
      console.log('=== Fullscreen Diagnostic ===');
      console.log('DOMContentLoaded fired!');
      console.log('Secure context (HTTPS):', window.isSecureContext);
      console.log('Document fullscreenEnabled:', document.fullscreenEnabled);
      console.log('Webkit fullscreen enabled:', 'webkitFullscreenEnabled' in document ? document.webkitFullscreenEnabled : 'N/A');
      console.log('Moz fullscreen enabled:', 'mozFullScreenEnabled' in document ? document.mozFullScreenEnabled : 'N/A');

      // Get URL parameters
      const urlParams = new URLSearchParams(window.location.search);

      // Initialize player elements
      const video = document.getElementById('video');
      // If a start time (?t=seconds) was provided, seek after metadata loads
      const startTimeParam = parseInt(urlParams.get('t') || '0', 10);
      // Block auto-seek to 0:00 if resume progress exists and show modal instead
      if (!isNaN(startTimeParam) && startTimeParam > 0) {
        const applyStartTime = () => {
          try {
            if (video.duration && startTimeParam < video.duration) {
              video.currentTime = startTimeParam;
            } else {
              setTimeout(applyStartTime, 200);
            }
          } catch (e) {
            setTimeout(applyStartTime, 200);
          }
        };
        video.addEventListener('loadedmetadata', applyStartTime, { once: true });
      } else {
        // Check for continue watching progress and block auto-seek to 0:00
        setTimeout(() => {
          if (window.ContinueWatchingManager) {
            let videoSrc = '';
            if (video.src && video.src.length > 0) {
              videoSrc = video.src;
            } else {
              const sourceTag = video.querySelector('source');
              if (sourceTag && sourceTag.src && sourceTag.src.length > 0) {
                videoSrc = sourceTag.src;
              }
            }
            let movieId = urlParams.get('movieId');
            if (!movieId) {
              movieId = btoa(videoSrc).replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);
            }
            const savedProgress = window.ContinueWatchingManager.getMovieProgress(movieId);
            if (savedProgress && savedProgress.currentTime > 0) {
              // Force video to remain paused at 0 until resume modal is handled
              video.currentTime = 0;
              video.pause();
              // Prevent any autoplay
              video.autoplay = false;
              // Resume modal will be shown by player-continue-watching.js
            }
          }
        }, 100);
      }
      const videoContainer = document.getElementById('videoContainer');
      const controlsContainer = document.getElementById('controlsContainer');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const muteBtn = document.getElementById('muteBtn');
      const volumeSlider = document.getElementById('volumeSlider');
      const timeDisplay = document.getElementById('timeDisplay');
      const progressBar = document.getElementById('progressBar');
      const progressBuffer = document.getElementById('progressBuffer');
      const progressBarContainer = document.getElementById('progressContainer');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      const subtitleBtn = document.getElementById('subtitleBtn');

      // Subtitle variables
      let subtitleTracks = [];
      let currentSubtitleTrack = null;
      let currentSubtitleIndex = null;
      let subtitleContainer = null;

      // Initialize subtitle container
      function initSubtitleContainer() {
        // Create subtitle container if it doesn't exist
        if (!subtitleContainer) {
          subtitleContainer = document.createElement('div');
          subtitleContainer.id = 'videoSubtitles';
          subtitleContainer.className = 'video-subtitles';

          // Check if in fullscreen mode
          const isFullscreen = document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement;

          // Set base styles
          subtitleContainer.style.cssText = `
            position: fixed;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9), -1px -1px 2px rgba(0, 0, 0, 0.9);
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.75);
            border-radius: 6px;
            max-width: 85%;
            z-index: 2147483647;
            pointer-events: none;
            transition: opacity 0.3s;
            font-weight: 500;
            line-height: 1.4;
            display: none;
          `;

          // Append to the appropriate parent based on fullscreen state
          if (isFullscreen) {
            const container = document.querySelector('.video-container');
            if (container) {
              container.appendChild(subtitleContainer);
              subtitleContainer.classList.add('fullscreen-subtitles');
            } else {
              videoContainer.appendChild(subtitleContainer);
            }
          } else {
            // Append to video container for proper positioning
            videoContainer.appendChild(subtitleContainer);
          }

          console.log('✓ Subtitle container created and added to DOM');
        }
      }
      const skipBackwardBtn = document.getElementById('skipBackwardBtn');
      const skipForwardBtn = document.getElementById('skipForwardBtn');
      const playPauseOverlay = document.getElementById('playPauseOverlay');
      const seekForwardIndicator = document.getElementById('forwardIndicator');
      const seekBackwardIndicator = document.getElementById('rewindIndicator');
      const scrubber = document.querySelector('.scrubber');
      const scrubberTime = document.querySelector('.scrubber-time');
      const movieTitle = document.getElementById('movieTitle');
      const movieYear = document.getElementById('movieYear');
      const movieRating = document.getElementById('movieRating');
      const movieDescription = document.getElementById('movieDescription');
      const backButton = document.getElementById('backButton');

      // --- Settings Menu Logic ---
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsMenu = document.getElementById('settingsMenu');
      const playbackSpeedMenu = document.getElementById('playbackSpeedMenu');
      const playbackSpeedSubmenu = document.getElementById('playbackSpeedSubmenu');
      const backToMainSettings = document.getElementById('backToMainSettings');

      // Hide all menus initially
      if (settingsMenu) settingsMenu.style.display = 'none';
      if (playbackSpeedSubmenu) playbackSpeedSubmenu.style.display = 'none';

      // Show/hide settings menu on button click - using dynamic positioning like subtitle button
      if (settingsBtn && settingsMenu) {
        settingsBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log('Settings button clicked!');

          // Force remove subtitle menu when opening settings menu
          const subtitleMenu = document.getElementById('subtitleMenu');
          if (subtitleMenu) {
            try {
              subtitleMenu.remove();
            } catch (err) {
              console.log('Error removing subtitle menu:', err);
            }
          }
          // Also remove any subtitle menus by class name as a safety measure
          const subtitleMenusByClass = document.querySelectorAll('.subtitle-menu');
          subtitleMenusByClass.forEach(menu => {
            try {
              menu.remove();
            } catch (err) {
              console.log('Error removing subtitle menu by class:', err);
            }
          });

          // Toggle menu visibility
          const isMenuVisible = settingsMenu.style.display === 'flex';
          console.log('Menu visible before toggle:', isMenuVisible);

          if (!isMenuVisible) {
            // Position above the settings button
            const videoContainer = document.querySelector('.video-container');
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

            // Append to correct parent based on fullscreen state
            if (isFullscreen) {
              const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
              if (settingsMenu.parentElement !== fullscreenElement) {
                fullscreenElement.appendChild(settingsMenu);
              }
            } else {
              if (settingsMenu.parentElement !== document.body) {
                document.body.appendChild(settingsMenu);
              }
            }

            // Get button position
            const rect = settingsBtn.getBoundingClientRect();

            // Position menu above the button, shifted to the left
            settingsMenu.style.display = 'flex';
            settingsMenu.style.position = 'fixed';
            settingsMenu.style.left = `${rect.left - 200}px`;
            settingsMenu.style.setProperty('bottom', `${window.innerHeight - rect.top + 30}px`, 'important');
            settingsMenu.style.right = 'auto';
            settingsMenu.style.top = 'auto';

            console.log('Menu shown!');

            // Hide submenus when opening main menu
            if (playbackSpeedSubmenu) {
              playbackSpeedSubmenu.style.display = 'none';
            }
          } else {
            // Hide the menu
            settingsMenu.style.display = 'none';
            console.log('Menu hidden!');
          }
        });
      } else {
        console.error('Settings button or menu not found!', { settingsBtn, settingsMenu });
      }

      // Open playback speed submenu - using dynamic positioning like settings menu
      if (playbackSpeedMenu && playbackSpeedSubmenu) {
        playbackSpeedMenu.addEventListener('click', (e) => {
          e.stopPropagation();

          // Load saved subtitle settings if any
          loadSubtitleSettings();

          // Initialize subtitle settings panel
          function initSubtitleSettings() {
            const settingsPanel = document.getElementById('subtitleSettings');
            const closeButton = settingsPanel.querySelector('.close-settings');

            // Close button
            closeButton.addEventListener('click', () => {
              settingsPanel.style.display = 'none';
            });

            // Position
            const positionSelect = document.getElementById('subtitlePosition');
            positionSelect.addEventListener('change', (e) => {
              const position = e.target.value;
              const subtitleContainer = document.querySelector('.custom-subtitle');

              // Reset all positions
              subtitleContainer.style.top = '';
              subtitleContainer.style.bottom = '';
              subtitleContainer.style.alignItems = 'center';

              // Apply new position
              if (position === 'top') {
                subtitleContainer.style.top = '80px';
                subtitleContainer.style.bottom = '';
              } else if (position === 'middle') {
                subtitleContainer.style.top = '50%';
                subtitleContainer.style.bottom = '';
                subtitleContainer.style.transform = 'translateY(-50%)';
              } else { // bottom
                subtitleContainer.style.top = '';
                subtitleContainer.style.bottom = '100px';
                subtitleContainer.style.transform = '';
              }

              saveSubtitleSettings('position', position);
            });

            // Font Size
            const sizeSlider = document.getElementById('subtitleSize');
            const sizeValue = document.getElementById('subtitleSizeValue');

            sizeSlider.addEventListener('input', (e) => {
              const size = e.target.value;
              sizeValue.textContent = `${size}px`;

              const subtitleText = document.querySelector('.subtitle-text');
              if (subtitleText) {
                subtitleText.style.fontSize = `${size}px`;
                saveSubtitleSettings('fontSize', size);
              }
            });

            // Text Color
            const colorPicker = document.getElementById('subtitleColor');
            colorPicker.addEventListener('input', (e) => {
              const color = e.target.value;
              const subtitleText = document.querySelector('.subtitle-text');
              if (subtitleText) {
                subtitleText.style.color = color;
                saveSubtitleSettings('textColor', color);
              }
            });

            // Background Color and Opacity
            const bgColorPicker = document.getElementById('subtitleBgColor');
            const bgOpacitySlider = document.getElementById('subtitleBgOpacity');
            const bgOpacityValue = document.getElementById('subtitleBgOpacityValue');

            function updateBackground() {
              const bgColor = bgColorPicker.value;
              const opacity = bgOpacitySlider.value / 10; // Convert 0-10 to 0-1
              bgOpacityValue.textContent = `${Math.round(opacity * 100)}%`;

              const subtitleText = document.querySelector('.subtitle-text');
              if (subtitleText) {
                const rgba = hexToRgba(bgColor, opacity);
                subtitleText.style.backgroundColor = rgba;

                // Save both color and opacity
                saveSubtitleSettings('bgColor', bgColor);
                saveSubtitleSettings('bgOpacity', opacity);
              }
            }

            bgColorPicker.addEventListener('input', updateBackground);
            bgOpacitySlider.addEventListener('input', updateBackground);

            // Font Family
            const fontSelect = document.getElementById('subtitleFont');
            fontSelect.addEventListener('change', (e) => {
              const font = e.target.value;
              const subtitleText = document.querySelector('.subtitle-text');
              if (subtitleText) {
                subtitleText.style.fontFamily = font;
                saveSubtitleSettings('fontFamily', font);
              }
            });

            // Text Shadow
            const shadowCheckbox = document.getElementById('subtitleShadow');
            shadowCheckbox.addEventListener('change', (e) => {
              const hasShadow = e.target.checked;
              const subtitleText = document.querySelector('.subtitle-text');
              if (subtitleText) {
                subtitleText.style.textShadow = hasShadow ? '1px 1px 2px rgba(0, 0, 0, 0.9)' : 'none';
                saveSubtitleSettings('textShadow', hasShadow);
              }
            });

            // Background Style
            const bgStyleSelect = document.getElementById('subtitleBgStyle');
            bgStyleSelect.addEventListener('change', (e) => {
              const style = e.target.value;
              const subtitleText = document.querySelector('.subtitle-text');
              if (!subtitleText) return;

              if (style === 'box') {
                subtitleText.style.borderRadius = '4px';
                subtitleText.style.padding = '8px 16px';
                subtitleText.style.display = 'inline-block';
                subtitleText.style.maxWidth = '80%';
              } else if (style === 'full') {
                subtitleText.style.borderRadius = '0';
                subtitleText.style.padding = '8px 0';
                subtitleText.style.display = 'block';
                subtitleText.style.maxWidth = '100%';
                subtitleText.style.width = '100%';
                subtitleText.style.textAlign = 'center';
              } else { // none
                subtitleText.style.backgroundColor = 'transparent';
                subtitleText.style.padding = '0';
              }

              saveSubtitleSettings('bgStyle', style);
            });
          }

          // Helper function to convert hex color to rgba
          function hexToRgba(hex, alpha = 1) {
            // Remove # if present
            hex = hex.replace('#', '');

            // Parse r, g, b values
            let r, g, b;
            if (hex.length === 3) {
              r = parseInt(hex[0] + hex[0], 16);
              g = parseInt(hex[1] + hex[1], 16);
              b = parseInt(hex[2] + hex[2], 16);
            } else if (hex.length === 6) {
              r = parseInt(hex.substring(0, 2), 16);
              g = parseInt(hex.substring(2, 4), 16);
              b = parseInt(hex.substring(4, 6), 16);
            } else {
              return 'rgba(0, 0, 0, 0.8)'; // Default fallback
            }

            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
          }

          // Save settings to localStorage
          function saveSubtitleSettings(key, value) {
            const settings = JSON.parse(localStorage.getItem('subtitleSettings') || '{}');
            settings[key] = value;
            localStorage.setItem('subtitleSettings', JSON.stringify(settings));
          }

          // Load settings from localStorage
          function loadSubtitleSettings() {
            const settings = JSON.parse(localStorage.getItem('subtitleSettings') || '{}');

            // Apply saved settings
            if (settings.position) {
              document.getElementById('subtitlePosition').value = settings.position;
              document.getElementById('subtitlePosition').dispatchEvent(new Event('change'));
            }

            if (settings.fontSize) {
              document.getElementById('subtitleSize').value = settings.fontSize;
              document.getElementById('subtitleSize').dispatchEvent(new Event('input'));
            }

            if (settings.textColor) {
              document.getElementById('subtitleColor').value = settings.textColor;
              document.getElementById('subtitleColor').dispatchEvent(new Event('input'));
            }

            if (settings.bgColor) {
              document.getElementById('subtitleBgColor').value = settings.bgColor;
              if (settings.bgOpacity) {
                document.getElementById('subtitleBgOpacity').value = settings.bgOpacity * 10;
              }
              document.getElementById('subtitleBgOpacity').dispatchEvent(new Event('input'));
            }

            if (settings.fontFamily) {
              document.getElementById('subtitleFont').value = settings.fontFamily;
              document.getElementById('subtitleFont').dispatchEvent(new Event('change'));
            }

            if (settings.textShadow !== undefined) {
              document.getElementById('subtitleShadow').checked = settings.textShadow;
              document.getElementById('subtitleShadow').dispatchEvent(new Event('change'));
            }

            if (settings.bgStyle) {
              document.getElementById('subtitleBgStyle').value = settings.bgStyle;
              document.getElementById('subtitleBgStyle').dispatchEvent(new Event('change'));
            }
          }

          // Initialize the settings panel when the DOM is loaded
          document.addEventListener('DOMContentLoaded', () => {
            initSubtitleSettings();

            // Add click handler for subtitle settings button
            const subtitleSettingsBtn = document.querySelector('.subtitle-settings-btn');
            if (subtitleSettingsBtn) {
              subtitleSettingsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.getElementById('subtitleSettings').style.display = 'block';
              });
            }
          });

          // Close settings when clicking outside
          document.addEventListener('click', (e) => {
            const settingsPanel = document.getElementById('subtitleSettings');
            if (settingsPanel && !settingsPanel.contains(e.target) &&
              e.target !== document.querySelector('.subtitle-settings-btn')) {
              settingsPanel.style.display = 'none';
            }
          });

          // Animate settings menu out before hiding
          settingsMenu.style.opacity = '0';
          settingsMenu.style.transform = 'translateX(-20px) scale(0.95)';

          setTimeout(() => {
            // Hide the settings menu
            settingsMenu.style.display = 'none';

            // Check if in fullscreen mode
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

            // Append to correct parent based on fullscreen state
            if (isFullscreen) {
              const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
              if (playbackSpeedSubmenu.parentElement !== fullscreenElement) {
                fullscreenElement.appendChild(playbackSpeedSubmenu);
              }
            } else {
              if (playbackSpeedSubmenu.parentElement !== document.body) {
                document.body.appendChild(playbackSpeedSubmenu);
              }
            }

            // Get settings button position
            const rect = settingsBtn.getBoundingClientRect();

            // Adjust positioning based on fullscreen state
            const bottomOffset = isFullscreen ? -40 : -40; // Negative offset in fullscreen to move it down more

            // Position submenu above the button, shifted to the right
            playbackSpeedSubmenu.style.display = 'flex';
            playbackSpeedSubmenu.style.position = 'fixed';
            playbackSpeedSubmenu.style.left = `${rect.left + 20}px`;
            playbackSpeedSubmenu.style.setProperty('bottom', `${window.innerHeight - rect.top + bottomOffset}px`, 'important');
            playbackSpeedSubmenu.style.right = 'auto';
            playbackSpeedSubmenu.style.top = 'auto';

            // Animate submenu in
            playbackSpeedSubmenu.style.opacity = '0';
            playbackSpeedSubmenu.style.transform = 'translateX(20px) scale(0.95)';

            // Trigger animation
            setTimeout(() => {
              playbackSpeedSubmenu.style.opacity = '1';
              playbackSpeedSubmenu.style.transform = 'translateY(0) scale(1)';
            }, 10);
          }, 200);

          // Add mouseleave event listener to close menu when cursor leaves
          const closeMenuOnMouseLeave = (e) => {
            const settingsMenuRect = settingsMenu.getBoundingClientRect();
            const submenuRect = playbackSpeedSubmenu.getBoundingClientRect();

            // Create a path between the menus with buffer zone
            const buffer = 30; // 30px buffer zone
            const pathBounds = {
              left: Math.min(settingsMenuRect.left, submenuRect.left) - buffer,
              right: Math.max(settingsMenuRect.right, submenuRect.right) + buffer,
              top: Math.min(settingsMenuRect.top, submenuRect.top) - buffer,
              bottom: Math.max(settingsMenuRect.bottom, submenuRect.bottom) + buffer
            };

            // Add additional buffer zone between menus
            const menuGapBuffer = {
              left: Math.min(settingsMenuRect.right, submenuRect.left),
              right: Math.max(settingsMenuRect.left, submenuRect.right),
              top: Math.min(settingsMenuRect.bottom, submenuRect.top),
              bottom: Math.max(settingsMenuRect.top, submenuRect.bottom)
            };

            // Check if mouse is outside both the menus and the path between them
            const isOutsideMenus = e.clientX < pathBounds.left ||
              e.clientX > pathBounds.right ||
              e.clientY < pathBounds.top ||
              e.clientY > pathBounds.bottom;

            if (isOutsideAll) {
              // Animate out
              playbackSpeedSubmenu.classList.remove('visible');
              settingsMenu.style.opacity = '0';
              settingsMenu.style.transform = 'translateY(-10px) scale(0.98)';

              // Wait for animation to complete before hiding
              setTimeout(() => {
                playbackSpeedSubmenu.style.display = 'none';
                settingsMenu.style.display = 'none';
                // Reset transforms for next opening
                settingsMenu.style.opacity = '';
                settingsMenu.style.transform = '';
              }, 200);

              document.removeEventListener('mousemove', closeMenuOnMouseLeave);
            }
          };

          // Add the event listener
          document.addEventListener('mousemove', closeMenuOnMouseLeave);
        });
      }

      // Back to main settings from playback speed submenu - using dynamic positioning like settings menu
      if (backToMainSettings) {
        backToMainSettings.addEventListener('click', (e) => {
          e.stopPropagation();

          // Animate submenu out before hiding
          playbackSpeedSubmenu.style.opacity = '0';
          playbackSpeedSubmenu.style.transform = 'translateX(20px) scale(0.95)';

          setTimeout(() => {
            // Hide the playback speed submenu
            playbackSpeedSubmenu.style.display = 'none';

            // Show the main settings menu using CSS positioning
            if (settingsMenu.parentElement !== document.body) {
              document.body.appendChild(settingsMenu);
            }

            // Show the main settings menu
            settingsMenu.style.display = 'flex';

            // Animate settings menu in
            settingsMenu.style.opacity = '0';
            settingsMenu.style.transform = 'translateX(-20px) scale(0.95)';

            // Trigger animation
            setTimeout(() => {
              settingsMenu.style.opacity = '1';
              settingsMenu.style.transform = 'translateY(0) scale(1)';
            }, 10);
          }, 200);
        });
      }

      // No subtitles menu functionality needed

      // Handle playback speed selection
      const playbackOptions = document.querySelectorAll('#playbackSpeedSubmenu .submenu-option');
      if (playbackOptions.length) {
        playbackOptions.forEach(option => {
          option.addEventListener('click', () => {
            // Remove selected class from all options
            playbackOptions.forEach(opt => opt.classList.remove('selected'));
            // Add selected class to clicked option
            option.classList.add('selected');

            // Update playback rate
            const rate = parseFloat(option.getAttribute('data-value'));
            video.playbackRate = rate;

            // Update display in main menu
            const displayLabel = option.getAttribute('data-label') || option.textContent;
            document.querySelector('#playbackSpeedMenu .current-value').textContent = displayLabel;

            // Close submenu and return to main menu
            playbackSpeedSubmenu.style.display = 'none';
            settingsMenu.style.display = 'flex';
          });
        });
      }

      // Hide settings menu when clicking outside
      document.addEventListener('click', (e) => {
        const isSettingsMenuVisible = settingsMenu && settingsMenu.style.display === 'flex';
        const isPlaybackSubmenuVisible = playbackSpeedSubmenu && playbackSpeedSubmenu.style.display === 'flex';

        if (isSettingsMenuVisible) {
          if (!settingsMenu.contains(e.target) && e.target !== settingsBtn) {
            settingsMenu.style.display = 'none';
          }
        }

        if (isPlaybackSubmenuVisible) {
          if (!playbackSpeedSubmenu.contains(e.target) && e.target !== playbackSpeedMenu) {
            playbackSpeedSubmenu.style.display = 'none';
          }
        }
      });

      // No close button needed

      // Set default playback speed option as selected
      const defaultSpeedOption = document.querySelector('#playbackSpeedSubmenu .submenu-option[data-value="1"]');
      if (defaultSpeedOption) {
        defaultSpeedOption.classList.add('selected');
      }

      // Get movie info from URL parameters
      const title = urlParams.get('title') || 'Movie';
      const year = urlParams.get('year') || '';
      const rating = urlParams.get('rating');
      const description = urlParams.get('description') || 'No description available';

      // Generate a consistent movie ID
      let movieId = urlParams.get('movieId');
      if (!movieId) {
        // Create a consistent ID from the title and year
        movieId = `${title.toLowerCase().replace(/[^a-z0-9]+/g, '-')}-${year}`;
        console.log('Generated movieId:', movieId);
      }

      // Store movie info in a global variable for easy access
      window.currentMovie = {
        id: movieId,
        title: title,
        year: year,
        rating: rating,
        description: description,
        // Add a timestamp to ensure uniqueness and track last access
        timestamp: Date.now()
      };
      const poster = urlParams.get('poster') || '';
      let sourceType = urlParams.get('type') || 'mp4';
      let src = urlParams.get('src') || urlParams.get('video') || '';

      // Check movie database for the video source and subtitles
      const normalizedTitle = title.toLowerCase().trim();
      console.log('Looking up movie:', normalizedTitle);
      console.log('Available movies in database:', Object.keys(movieDatabase));

      if (movieDatabase[normalizedTitle]) {
        const movieData = movieDatabase[normalizedTitle];
        src = movieData.src;
        sourceType = movieData.type;
        console.log('✓ Found movie in database:', normalizedTitle, movieData);
      } else {
        console.log('✗ Movie not found in database:', normalizedTitle);
      }

      // Check for subtitle data in URL parameters
      const subtitleParam = urlParams.get('subtitles');
      let subtitleData = null;
      if (subtitleParam) {
        try {
          subtitleData = JSON.parse(decodeURIComponent(subtitleParam));
          console.log('✓ Found subtitle data in URL:', subtitleData);
        } catch (error) {
          console.error('Error parsing subtitle data:', error);
        }
      }

      // Load subtitles if available (either from movie data or URL)
      if (subtitleData && subtitleData.length > 0) {
        console.log('Loading subtitles from URL data:', subtitleData.length, 'tracks');
        loadSubtitles(subtitleData);
      } else if (movieDatabase[normalizedTitle] && movieDatabase[normalizedTitle].subtitles && movieDatabase[normalizedTitle].subtitles.length > 0) {
        console.log('Loading subtitles from movie database:', movieDatabase[normalizedTitle].subtitles.length, 'tracks');
        loadSubtitles(movieDatabase[normalizedTitle].subtitles);
      } else {
        console.log('No subtitle data found');
      }

      // Debug: Log the source URL and parameters
      console.log('Final Source URL:', src);
      console.log('Final Source type:', sourceType);
      console.log('URL parameters:', Object.fromEntries(urlParams.entries()));

      // Initialize time display elements
      if (timeDisplay) timeDisplay.textContent = '0:00 / 0:00';

      // Set movie info
      document.title = `${title}`;
      movieTitle.textContent = title;
      movieYear.textContent = year;
      movieRating.textContent = rating ? `${rating}/10` : 'N/A';
      movieDescription.textContent = description;

      // Set solid black background
      document.querySelector('.video-container').style.background = '#000';

      // System message function using UI toast system
      function showSubtitleNotification(message) {
        // Use the UI toast system to show the notification
        if (window.UIToast) {
          window.UIToast.info('Subtitles', message, 3000);
          // Ensure toast appears above fullscreen content
          const toastWrap = document.querySelector('.toast-wrap');
          if (toastWrap) {
            toastWrap.style.zIndex = '2147483647'; // Max z-index
          }
        } else {
          // Fallback to basic alert if UI toast system is not available
          console.warn('UI Toast system not available, falling back to alert');
          alert(message);
        }
      }

      function showSystemMessage(message, type = 'info') {
        // Use the UI toast system to show the notification
        if (window.UIToast) {
          // Map the type to the appropriate UI toast method
          const toastType = type === 'error' ? 'error' : 'info';
          window.UIToast[toastType](type.charAt(0).toUpperCase() + type.slice(1), message, 3000);
          // Ensure toast appears above fullscreen content
          const toastWrap = document.querySelector('.toast-wrap');
          if (toastWrap) {
            toastWrap.style.zIndex = '2147483647'; // Max z-index
          }
        } else {
          // Fallback to basic alert if UI toast system is not available
          console.warn('UI Toast system not available, falling back to alert');
          alert(`[${type.toUpperCase()}] ${message}`);
        }
      }

      // Initialize continue watching UI
      let continueWatchingUI;

      // Show resume prompt modal when there's saved progress
      function showResumePromptModal(movie) {
        // Create modal if it doesn't exist
        let modal = document.getElementById('resumePromptModal');

        if (!modal) {
          // Create modal HTML
          const modalHTML = `
            <div id="resumePromptModal" class="resume-prompt-modal" style="
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(5px);
            ">
                <div class="resume-prompt-content" style="
                    background: #1a1a1a;
                    padding: 2rem;
                    border-radius: 12px;
                    max-width: 500px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                    border: 1px solid rgba(255, 255, 255, 0.1);
                ">
                    <h3 style="margin-top: 0; color: #fff; font-size: 1.5rem; margin-bottom: 1rem;">
                        Continue Watching?
                    </h3>
                    <p style="color: #ccc; margin-bottom: 2rem;">
                        You were watching <strong>${movie.title}</strong>. Would you like to continue where you left off?
                    </p>
                    <div style="display: flex; gap: 1rem; justify-content: center;">
                        <button id="resumeYes" style="
                            background: #4CAF50;
                            color: white;
                            border: none;
                            padding: 0.75rem 1.5rem;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: 600;
                            transition: background 0.2s;
                        ">Continue Watching</button>
                        <button id="resumeNo" style="
                            background: #333;
                            color: #fff;
                            border: 1px solid #555;
                            padding: 0.75rem 1.5rem;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: 500;
                            transition: background 0.2s;
                        ">Start Over</button>
                    </div>
                </div>
            </div>`;

          // Add modal to the page
          document.body.insertAdjacentHTML('beforeend', modalHTML);
          modal = document.getElementById('resumePromptModal');

          // Set up event listeners
          document.getElementById('resumeYes').addEventListener('click', function () {
            // Close the modal
            modal.remove();

            // Get the saved position and seek to it
            if (window.continueWatchingUI) {
              const savedProgress = window.continueWatchingUI.getSavedProgress(movie.id);
              if (savedProgress && savedProgress.position > 0) {
                video.currentTime = savedProgress.position;
                video.play();
              }
            }
          });

          document.getElementById('resumeNo').addEventListener('click', function () {
            // Close the modal
            modal.remove();

            // Clear the resume position if needed
            if (window.continueWatchingUI && movie.id) {
              window.continueWatchingUI.clearResumePosition(movie.id);
            }

            // Start from the beginning
            video.currentTime = 0;
            video.play();
          });

          // Close modal when clicking outside content
          modal.addEventListener('click', function (e) {
            if (e.target === modal) {
              modal.remove();
            }
          });
        }
      }

      // Initialize video directly (like player.html)
      if (src) {
        console.log('Loading video:', src, 'Type:', sourceType);

        // Ensure window.currentMovie is properly set
        if (!window.currentMovie) {
          const title = urlParams.get('title') || 'Unknown Movie';
          const movieId = urlParams.get('movieId') || `generated-${Date.now()}`;

          window.currentMovie = {
            id: movieId,
            title: title,
            year: urlParams.get('year') || '',
            timestamp: Date.now()
          };

          console.warn('Initialized missing currentMovie:', window.currentMovie);
        }

        const movie = window.currentMovie;

        // Set video attributes
        video.playsInline = true;
        video.preload = 'auto';
        video.muted = false;
        video.autoplay = true;
        video.controls = false;
        video.style.width = '100%';
        video.style.height = '100%';
        video.style.objectFit = 'contain';

        // Create and add source
        const source = document.createElement('source');
        source.src = src;
        source.type = 'video/mp4';
        video.appendChild(source);

        // DISABLED: Old resume code - now handled by player-continue-watching.js
        // These flags are set to true to prevent this old code from running
        let hasSetResumeTime = true; // Disabled - using player-continue-watching.js instead
        let resumePromptShown = true; // Disabled - using player-continue-watching.js instead

        // Function to save current playback position
        const saveCurrentPosition = () => {

          // Only save if video has been playing for more than 5 seconds
          if (video.currentTime > 0) {
            const progress = {
              currentTime: video.currentTime,
              duration: video.duration,
              timestamp: Date.now(),
              title: movie.title || 'Unknown',
              id: movie.id,
              year: movie.year || '',
              progress: (video.currentTime / video.duration) * 100
            };

            console.log('Saving playback position:', progress);
            window.continueWatchingUI.saveProgress(progress);
          }
        };

        // Enhanced function to check and show resume prompt with async/await support
        const checkAndShowResumePrompt = async (source = 'unknown') => {
          console.log(`Resume check triggered by: ${source}`);

          // Make sure video element exists and has metadata
          if (!video || video.readyState < 1) {
            console.log('Video not ready yet, will retry...');
            return false;
          }

          // Ensure we have a valid movie object
          if (!movie || !movie.id) {
            console.warn('No valid movie data available for resume prompt');
            return false;
          }

          console.log(`Checking resume prompt (${source}) for movie:`, movie.id, movie.title);

          // Wait for continueWatchingUI to be available
          if (!window.continueWatchingUI) {
            console.log('continueWatchingUI not available yet, waiting...');
            try {
              await new Promise((resolve) => {
                const maxWaitTime = 5000; // 5 seconds max
                const checkInterval = 100; // check every 100ms
                let elapsed = 0;

                const check = () => {
                  if (window.continueWatchingUI) {
                    console.log('continueWatchingUI is now available');
                    resolve();
                    return;
                  }

                  elapsed += checkInterval;
                  if (elapsed >= maxWaitTime) {
                    console.warn('Timed out waiting for continueWatchingUI');
                    resolve(); // Resolve anyway to continue execution
                    return;
                  }

                  setTimeout(check, checkInterval);
                };

                check();
              });

              // If still not available after waiting, give up
              if (!window.continueWatchingUI) {
                console.warn('continueWatchingUI still not available after waiting');
                return false;
              }

              // Check for saved progress
              const savedProgress = await window.continueWatchingUI.getProgress(movie.id);
              if (savedProgress && savedProgress.currentTime > 0) {
                console.log('Found saved progress:', savedProgress);
                showResumePrompt(savedProgress);
                return true;
              }

            } catch (error) {
              console.error('Error in resume check:', error);
              return false;
            }
          }

          // Get the saved progress using the manager directly
          let savedProgress = null;
          try {
            // Try to get progress using the current ID
            savedProgress = window.continueWatchingUI.getSavedProgress(movie.id);

            // If no progress found, try alternative methods to find the movie
            if (!savedProgress && window.currentMovie && window.currentMovie.title) {
              console.log('No progress found for ID, trying to find by title...');
              const allProgress = window.continueWatchingUI.getAllProgress();
              const titleLower = window.currentMovie.title.toLowerCase();

              // Look for a matching movie by title
              for (const [id, progress] of Object.entries(allProgress)) {
                if (progress.title && progress.title.toLowerCase() === titleLower) {
                  savedProgress = progress;
                  console.log('Found progress by title match:', id);
                  break;
                }
              }
            }

            console.log('Saved progress check result:', {
              movieId: movie.id,
              title: movie.title,
              savedProgress: !!savedProgress,
              progress: savedProgress ? {
                position: savedProgress.currentTime,
                duration: savedProgress.duration,
                progress: savedProgress.progress
              } : null,
              source
            });

          } catch (error) {
            console.error('Error in checkAndShowResumePrompt:', error);
          }
        };

        // Multiple checks at different stages
        const initResumePrompt = () => {
          // Initial check
          checkAndShowResumePrompt('init');

          // Check when continueWatchingUI might be ready
          if (!window.continueWatchingUI) {
            const checkInterval = setInterval(() => {
              if (window.continueWatchingUI) {
                clearInterval(checkInterval);
                checkAndShowResumePrompt('ui-ready');
              }
            }, 100);

            // Timeout after 3 seconds
            setTimeout(() => clearInterval(checkInterval), 3000);
          }
        };

        // Enhanced resume check with better timing and reliability using async/await
        const initResumeCheck = () => {
          console.log('Initializing resume check...');

          // Function to attempt showing resume prompt with retries
          const tryShowResumePrompt = async (attempt = 0, maxAttempts = 10) => {
            console.log(`Attempt ${attempt + 1} to show resume prompt`);

            try {
              await checkAndShowResumePrompt(`attempt-${attempt + 1}`);
              return true;
            } catch (error) {
              console.error('Error in tryShowResumePrompt:', error);

              // If max attempts reached, give up
              if (attempt >= maxAttempts) {
                console.log('Max attempts reached, giving up on resume prompt');
                return false;
              }

              // Otherwise, try again after a delay
              return new Promise(resolve => {
                setTimeout(async () => {
                  const result = await tryShowResumePrompt(attempt + 1, maxAttempts);
                  resolve(result);
                }, 500);
              });
            }
          };

          // Start trying to show the resume prompt
          tryShowResumePrompt(0, 10); // Try up to 10 times with 500ms delay

          // Add event listeners for time updates to save position
          let savePositionTimeout;
          video.addEventListener('timeupdate', () => {
            // Throttle the save operation to run at most once per second
            clearTimeout(savePositionTimeout);
            savePositionTimeout = setTimeout(saveCurrentPosition, 1000);
          });

          // Also save on pause and when navigating away
          video.addEventListener('pause', saveCurrentPosition);
          window.addEventListener('beforeunload', saveCurrentPosition);

          // Add event listeners for various video events
          const events = ['loadedmetadata', 'canplay', 'playing', 'progress'];
          events.forEach(event => {
            video.addEventListener(event, async () => {
              console.log(`Video event: ${event}, readyState: ${video.readyState}`);
              await checkAndShowResumePrompt(`event-${event}`);
            }, { once: true });
          });

          // Final fallback check with a bit more delay
          setTimeout(async () => {
            console.log('Final fallback check for resume prompt');
            await checkAndShowResumePrompt('final-fallback');
          }, 3000);
        };

        // DISABLED: Old resume check - now handled by player-continue-watching.js
        // if (document.readyState === 'loading') {
        //   document.addEventListener('DOMContentLoaded', initResumeCheck);
        // } else {
        //   initResumeCheck();
        // }
        console.log('Old resume check disabled in favor of player-continue-watching.js');

        // Function to set the resume time (only once)
        const setResumeTime = () => {
          if (hasSetResumeTime || !resumeTime || isNaN(resumeTime)) return;

          console.log('Setting resume time to:', resumeTime, 'seconds');
          video.currentTime = resumeTime;
          hasSetResumeTime = true;
        };

        // Set up event listeners for resuming
        video.addEventListener('loadedmetadata', () => {
          console.log('Video metadata loaded, duration:', video.duration);
          if (!isNaN(video.duration) && video.duration > 0) {
            updateTimeDisplay();
            updateProgress();

            // Load subtitles for the current video
            const videoId = urlParams.get('id');
            if (videoId && videoSources[videoId] && videoSources[videoId].subtitles) {
              // Initialize subtitle container first
              initSubtitleContainer();

              // Then load the subtitles
              loadSubtitles(videoSources[videoId].subtitles);

              // Set up cue change handler for the video's text tracks
              const tracks = video.textTracks;
              for (let i = 0; i < tracks.length; i++) {
                tracks[i].addEventListener('cuechange', handleCueChange);
              }
            }

            // Try to set resume time after metadata is loaded
            if (!hasSetResumeTime && resumeTime) {
              setResumeTime();
            }
          }
        });

        // Also try to set resume time when the video can play
        video.addEventListener('canplay', () => {
          if (!hasSetResumeTime && resumeTime) {
            if (Math.abs(video.currentTime - resumeTime) > 1) {
              console.log('Adjusting resume time in canplay event:', resumeTime);
              setResumeTime();
            }
          }
        });

        // Clear the resume time from URL after first successful seek
        video.addEventListener('seeked', () => {
          if (hasSetResumeTime) {
            // Update URL without page reload
            const url = new URL(window.location);
            url.searchParams.delete('t');
            window.history.replaceState({}, '', url);
          }
        });

        video.addEventListener('canplay', () => {
          console.log('Video can play');
          // Suppress autoplay if resume prompt is active
          if (window.__resumePromptActive) { showControls(); return; }
          video.play().catch(e => {
            console.log('Auto-play prevented:', e);
            showControls();
          });
        });

        video.addEventListener('error', (e) => {
          console.error('Video error:', video.error);
          showSystemMessage('Error loading video. Please try another source.', 'error');
        });

        // Load the video
        video.load();
      } else {
        console.error('No video source found');
        showSystemMessage('No video source provided', 'error');
      }

      // Function to fetch remote subtitle and convert to blob URL  
      async function fetchSubtitleAsBlob(url) {
        try {
          console.log('Fetching remote subtitle:', url);

          const proxyCandidates = [];
          let isCrossOrigin = false;

          try {
            isCrossOrigin = new URL(url, window.location.href).origin !== window.location.origin;
          } catch (e) {
            isCrossOrigin = true; // Assume cross-origin if URL parsing fails
          }

          // 1. If same origin, try direct first (fastest)
          if (!isCrossOrigin) {
            proxyCandidates.push({ url: url, name: 'Direct (Local)' });
          }

          // 2. Add robust CORS proxies
          // corsproxy.io is usually fast and reliable
          proxyCandidates.push({ url: `https://corsproxy.io/?${encodeURIComponent(url)}`, name: 'corsproxy.io' });
          // codetabs is a good backup
          proxyCandidates.push({ url: `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`, name: 'codetabs.com' });
          // thingproxy is another option
          proxyCandidates.push({ url: `https://thingproxy.freeboard.io/fetch/${url}`, name: 'thingproxy' });
          // allorigins is another backup
          proxyCandidates.push({ url: `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`, name: 'allorigins.win' });

          // REMOVED: Direct fallback for cross-origin to avoid console errors

          let lastError = null;

          for (let i = 0; i < proxyCandidates.length; i++) {
            const candidate = proxyCandidates[i];
            try {
              console.log(`Trying method ${i + 1}/${proxyCandidates.length}: ${candidate.name}`);

              // Add timeout to prevent hanging
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

              try {
                const response = await fetch(candidate.url, {
                  signal: controller.signal,
                  mode: 'cors',
                  cache: 'default'
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
                }

                const text = await response.text();

                // Verify it's valid VTT content
                if (!text.includes('WEBVTT') && !text.includes('1\n00:')) {
                  // Some VTTs might be simple, but WEBVTT header is standard. 
                  // Relaxed check: if it looks like text and not HTML error page
                  if (text.includes('<!DOCTYPE') || text.includes('<html')) {
                    throw new Error('Received HTML instead of VTT');
                  }
                }

                // Create blob with VTT content
                const blob = new Blob([text], { type: 'text/vtt' });
                const blobUrl = URL.createObjectURL(blob);
                console.log(`✓ Subtitle loaded successfully via ${candidate.name}`);
                return blobUrl;
              } catch (fetchErr) {
                clearTimeout(timeoutId);
                throw fetchErr;
              }
            } catch (err) {
              lastError = err;
              console.warn(`${i + 1}. Failed (${candidate.name}):`, err.name === 'AbortError' ? 'Timeout' : err.message);
              // Continue to next option
              continue;
            }
          }

          // All methods failed
          console.warn('All proxy methods failed. Subtitles unavailable.');
          throw lastError || new Error('All subtitle loading methods failed');
        } catch (error) {
          console.error('Could not load subtitle:', error.message);
          // Silently fail - subtitles are optional
          return null;
        }
      }

      // Subtitle functionality
      async function loadSubtitles(subtitleArray) {
        if (!subtitleArray || subtitleArray.length === 0) {
          console.log('No subtitles to load');
          return;
        }

        console.log('Loading subtitles:', subtitleArray);

        // Remove existing subtitle tracks
        const existingTracks = video.querySelectorAll('track');
        existingTracks.forEach(track => track.remove());

        // Clear existing tracks
        subtitleTracks = [];
        currentSubtitleTrack = null;
        currentSubtitleIndex = null;

        // Initialize subtitle container if it doesn't exist
        if (!subtitleContainer) {
          subtitleContainer = document.createElement('div');
          subtitleContainer.id = 'videoSubtitles';
          subtitleContainer.className = 'video-subtitles';
          video.parentNode.appendChild(subtitleContainer);
          console.log('Created new subtitle container');
        } else {
          // Clear any existing content
          subtitleContainer.innerHTML = '';
          subtitleContainer.style.display = 'none';
        }

        // Process each subtitle file
        for (let i = 0; i < subtitleArray.length; i++) {
          const subtitle = subtitleArray[i];

          // Check if this is a remote URL (http/https)
          const isRemoteUrl = subtitle.src.startsWith('http://') || subtitle.src.startsWith('https://');

          // Fetch and convert to blob URL if it's remote
          let subtitleUrl = subtitle.src;
          if (isRemoteUrl) {
            subtitleUrl = await fetchSubtitleAsBlob(subtitle.src);
            if (!subtitleUrl) {
              console.warn('Skipping subtitle track due to load failure:', subtitle.label);
              continue;
            }
          }

          const track = document.createElement('track');
          track.srclang = subtitle.srclang || 'en';
          track.label = subtitle.label || `Subtitle ${i + 1}`;
          track.kind = 'subtitles';
          track.src = subtitleUrl;
          track.default = subtitle.default || false;

          // Set mode to hidden by default and add event listeners
          track.addEventListener('load', function () {
            console.log('✓ Subtitle track loaded:', this.label);

            // Initially set to hidden for all tracks
            this.track.mode = 'hidden';

            // Keep all tracks hidden by default
            // They will be enabled when the user clicks the subtitle button

            // Add cuechange event listener to this track
            this.track.addEventListener('cuechange', handleCueChange);
          });

          // Add error handler for debugging
          track.addEventListener('error', function (e) {
            console.error('✗ Error loading subtitle track:', this.label, this.src, e);
          });

          // Add to video
          video.appendChild(track);

          // Add to our tracks array
          subtitleTracks.push({
            element: track,
            label: track.label,
            language: track.srclang,
            track: track.track
          });

          console.log('Added subtitle track:', track.label, 'from', isRemoteUrl ? 'remote URL (blob)' : 'local file');
        }

        console.log('✓ All subtitles loaded:', subtitleArray.length, 'tracks');

        // Keep all subtitles disabled by default
        // They will be enabled when the user clicks the subtitle button
        console.log('Subtitles loaded but disabled by default');
      }

      function srtToVtt(srtContent) {
        // Convert SRT format to WebVTT format
        let vttContent = 'WEBVTT\n\n';

        // Split SRT content into blocks
        const blocks = srtContent.trim().split('\n\n');

        blocks.forEach((block, index) => {
          const lines = block.split('\n');
          if (lines.length >= 3) {
            // First line is the sequence number (ignore)
            // Second line is the timestamp
            const timestampLine = lines[1];
            // Remaining lines are the subtitle text
            const textLines = lines.slice(2);

            // Simple timestamp conversion from SRT to VTT format
            const timestamp = timestampLine.replace(/,/g, '.');
            const text = textLines.join('\n');

            if (text.trim()) {
              vttContent += `${timestamp}\n${text}\n\n`;
            }
          }
        });

        return vttContent;
      }

      function toggleSubtitleMenu(e) {
        e.stopPropagation();
        const existingMenu = document.getElementById('subtitleMenu');
        if (existingMenu) {
          existingMenu.remove();
          document.removeEventListener('fullscreenchange', handleFullscreenChange);
          return;
        }

        // Hide settings menu and submenus when opening subtitle menu
        const settingsMenu = document.getElementById('settingsMenu');
        const playbackSpeedSubmenu = document.getElementById('playbackSpeedSubmenu');
        if (settingsMenu) settingsMenu.style.display = 'none';
        if (playbackSpeedSubmenu) playbackSpeedSubmenu.style.display = 'none';

        // Always show the menu when CC button is clicked
        createSubtitleMenu();
      }

      // Fullscreen change handler for subtitle menu
      const handleFullscreenChange = () => {
        const menu = document.getElementById('subtitleMenu');
        if (menu && menu.parentNode) {
          // Remove and recreate menu with correct positioning
          menu.remove();
          setTimeout(() => {
            if (subtitleTracks.length > 0) {
              createSubtitleMenu();
            }
          }, 10);
        }
      };

      function createSubtitleMenu() {
        // Create subtitle menu with same style as settings menu
        const menu = document.createElement('div');
        menu.id = 'subtitleMenu';
        menu.className = 'subtitle-menu';
        menu.style.cssText = `
        position: fixed !important;
        display: flex !important;
        flex-direction: column !important;
        background: rgba(30, 32, 36, 0.7) !important;
        border-radius: 16px !important;
        box-shadow: 0 8px 32px rgba(0,0,0,0.25) !important;
        opacity: 1 !important;
        transform: translateY(0) scale(1) !important;
        transition: opacity 0.2s ease, transform 0.2s ease !important;
        backdrop-filter: blur(12px) !important;
        border: 1.5px solid rgba(255,255,255,0.18) !important;
        min-width: 180px !important;
        max-width: 220px !important;
        padding: 18px 0 10px 0 !important;
        z-index: 2147483647 !important;
        font-family: 'Segoe UI', 'Netflix Sans', Arial, sans-serif !important;
        font-size: 16px !important;
        color: #fff !important;
        pointer-events: auto !important;
      `;

        // Add CSS animation for the menu
        const style = document.createElement('style');
        style.textContent = `
          @keyframes slideInSmooth {
            0% {
              opacity: 0;
              transform: translateY(15px) scale(0.95);
            }
            60% {
              opacity: 0.8;
              transform: translateY(-2px) scale(1.02);
            }
            100% {
              opacity: 1;
              transform: translateY(0) scale(1);
            }
          }

          /* Ensure subtitle menu appears above everything */
          #subtitleMenu {
            position: fixed !important;
            z-index: 2147483647 !important;
            pointer-events: auto !important;
            will-change: transform !important;
          }

          #subtitleMenu:-webkit-full-screen {
            position: fixed !important;
            z-index: 2147483647 !important;
            left: 50% !important;
            top: 20% !important;
            transform: translateX(-50%) translateY(-100%) !important;
          }

          #subtitleMenu:-moz-full-screen {
            position: fixed !important;
            z-index: 2147483647 !important;
            left: 50% !important;
            top: 20% !important;
            transform: translateX(-50%) translateY(-100%) !important;
          }

          #subtitleMenu:fullscreen {
            position: fixed !important;
            z-index: 2147483647 !important;
            left: 50% !important;
            top: 20% !important;
            transform: translateX(-50%) translateY(-100%) !important;
          }

          /* Mobile styles */
          @media (max-width: 768px) {
            .video-subtitles {
              font-size: 18px !important;
              bottom: 70px !important; /* Slightly higher on mobile to avoid controls */
              padding: 6px 12px !important;
              background-color: rgba(0, 0, 0, 0.6) !important;
            }

            /* Ensure body doesn't interfere */
            body {
              overflow: hidden !important;
            }
          }

          /* Ensure body doesn't interfere */
          body {
            overflow: hidden !important;
          }
        `;
        document.head.appendChild(style);

        const fullscreenStyles = document.createElement('style');
        fullscreenStyles.textContent = `
  :fullscreen #subtitleMenu,
  ::-webkit-full-screen #subtitleMenu,
  :-moz-full-screen #subtitleMenu {
    position: fixed !important;
    z-index: 2147483647 !important;
    transform: none !important;
  }
`;
        document.head.appendChild(fullscreenStyles);

        // Add "Off" option
        const offOption = document.createElement('div');
        offOption.className = 'subtitle-option';
        offOption.textContent = 'Off';
        offOption.style.cssText = `
          padding: 12px 24px !important;
          border: none !important;
          background: ${currentSubtitleIndex === null ? 'rgba(255,255,255,0.18)' : 'none'} !important;
          color: ${currentSubtitleIndex === null ? '#ffd700' : '#fff'} !important;
          font-size: 16px !important;
          border-radius: 8px !important;
          margin: 2px 0 !important;
          cursor: pointer !important;
          transition: background 0.18s, color 0.18s, transform 0.18s !important;
          font-weight: ${currentSubtitleIndex === null ? '500' : 'normal'} !important;
        `;
        offOption.addEventListener('mouseenter', () => {
          if (currentSubtitleIndex !== null) {
            offOption.style.background = 'rgba(255,255,255,0.10)';
            offOption.style.color = '#e0e0e0';
            offOption.style.transform = 'scale(1.03)';
          }
        });
        offOption.addEventListener('mouseleave', () => {
          offOption.style.background = currentSubtitleIndex === null ? 'rgba(255,255,255,0.18)' : 'none';
          offOption.style.color = currentSubtitleIndex === null ? '#ffd700' : '#fff';
          offOption.style.transform = 'scale(1)';
        });
        offOption.addEventListener('click', () => {
          selectSubtitle(null);
          menu.remove();
        });
        menu.appendChild(offOption);

        // Add language options
        subtitleTracks.forEach((track, index) => {
          const option = document.createElement('div');
          option.className = 'subtitle-option';
          option.textContent = track.label;
          const isActive = currentSubtitleIndex === index;
          option.style.cssText = `
            padding: 12px 24px !important;
            border: none !important;
            background: ${isActive ? 'rgba(255,255,255,0.18)' : 'none'} !important;
            color: ${isActive ? '#ffd700' : '#fff'} !important;
            font-size: 16px !important;
            border-radius: 8px !important;
            margin: 2px 0 !important;
            cursor: pointer !important;
            transition: background 0.18s, color 0.18s, transform 0.18s !important;
            font-weight: ${isActive ? '500' : 'normal'} !important;
          `;
          option.addEventListener('mouseenter', () => {
            if (!isActive) {
              option.style.background = 'rgba(255,255,255,0.10)';
              option.style.color = '#e0e0e0';
              option.style.transform = 'scale(1.03)';
            }
          });
          option.addEventListener('mouseleave', () => {
            option.style.background = isActive ? 'rgba(255,255,255,0.18)' : 'none';
            option.style.color = isActive ? '#ffd700' : '#fff';
            option.style.transform = 'scale(1)';
          });
          option.addEventListener('click', () => {
            selectSubtitle(index);
            menu.remove();
          });
          menu.appendChild(option);
        });


        // Position relative to the CC button - matching settings menu style
        const subtitleBtn = document.getElementById('subtitleBtn');
        const videoContainer = document.querySelector('.video-container');
        const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);

        if (subtitleBtn) {
          const rect = subtitleBtn.getBoundingClientRect();

          // Append to correct parent based on fullscreen state
          if (isFullscreen) {
            const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
            if (fullscreenElement) {
              fullscreenElement.appendChild(menu);
            } else {
              document.body.appendChild(menu);
            }
          } else {
            document.body.appendChild(menu);
          }

          // Position menu above the button, shifted to the left (matching settings menu)
          menu.style.position = 'fixed';
          menu.style.left = `${rect.left - 100}px`;
          menu.style.setProperty('bottom', `${window.innerHeight - rect.top + 30}px`, 'important');
          menu.style.right = 'auto';
          menu.style.top = 'auto';
        } else {
          // Fallback positioning if button not found
          document.body.appendChild(menu);
          menu.style.position = 'fixed';
          menu.style.top = '50%';
          menu.style.left = '50%';
          menu.style.transform = 'translate(-50%, -50%)';
        }

        // Show current active subtitle indicator
        updateSubtitleIndicators(currentSubtitleIndex);

        // Handle fullscreen change events
        function handleFullscreenChange() {
          const isFullscreen = document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement;

          const container = document.querySelector('.video-container');
          const subtitleElement = document.querySelector('.video-subtitles');

          if (isFullscreen) {
            document.documentElement.classList.add('fullscreen');
            container.classList.add('fullscreen');

            // Ensure the subtitle container is properly positioned in fullscreen
            if (subtitleElement) {
              // Move the subtitle container to the fullscreen element if subtitles are active
              if (currentSubtitleIndex !== null) {
                if (!container.contains(subtitleElement)) {
                  container.appendChild(subtitleElement);
                }
                subtitleElement.style.display = 'block';
                // Apply fullscreen-specific positioning
                subtitleElement.classList.add('fullscreen-subtitles');
              }
            }
          } else {
            document.documentElement.classList.remove('fullscreen');
            container.classList.remove('fullscreen');

            // Move the subtitle container back to body if needed
            if (subtitleElement) {
              if (!document.body.contains(subtitleElement)) {
                document.body.appendChild(subtitleElement);
              }
              // Remove fullscreen class
              subtitleElement.classList.remove('fullscreen-subtitles');
              // Restore visibility if subtitles are active
              subtitleElement.style.display = currentSubtitleIndex !== null ? 'block' : 'none';
            }
          }

          // Force update subtitle position if subtitles are active
          if (currentSubtitleIndex !== null && video && video.textTracks && currentSubtitleTrack) {
            const currentTime = video.currentTime;
            // Force a small update to refresh the subtitle display
            video.textTracks[currentSubtitleIndex].mode = 'hidden';
            setTimeout(() => {
              video.textTracks[currentSubtitleIndex].mode = 'showing';
              if (currentTime > 0) {
                video.currentTime = currentTime + 0.01;
                video.currentTime = currentTime;
              }
            }, 50);
          }
        }

        // Add fullscreen change event listeners for all browsers
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        // Listen for fullscreen changes
        document.addEventListener('fullscreenchange', handleFullscreenChange);

        // Close menu when clicking outside
        setTimeout(() => {
          const closeMenu = (e) => {
            if (!menu.contains(e.target) && e.target !== subtitleBtn) {
              menu.remove();
              document.removeEventListener('click', closeMenu);
              document.removeEventListener('fullscreenchange', handleFullscreenChange);
            }
          };
          document.addEventListener('click', closeMenu);
        }, 100);
      }

      function selectSubtitle(trackIndex) {
        console.log('Selecting subtitle track:', trackIndex);

        // Initialize subtitle container if it doesn't exist
        initSubtitleContainer();

        // Clear any existing cue change listeners
        if (currentSubtitleTrack) {
          currentSubtitleTrack.removeEventListener('cuechange', handleCueChange);
        }

        // If no track is specified, do nothing (keep current state)
        if (trackIndex === undefined) {
          return;
        }

        // First, disable all text tracks
        for (let i = 0; i < video.textTracks.length; i++) {
          video.textTracks[i].mode = 'hidden';
        }

        // If trackIndex is null or same as current, turn off subtitles
        if (trackIndex === null || trackIndex === currentSubtitleIndex) {
          currentSubtitleIndex = null;
          currentSubtitleTrack = null;
          console.log('Subtitles disabled');
          showSubtitleNotification('Subtitles: Off');

          // Hide the subtitle container
          if (subtitleContainer) {
            subtitleContainer.style.display = 'none';
          }
        }
        // If valid track index, enable it
        else if (trackIndex >= 0 && trackIndex < video.textTracks.length) {
          try {
            const track = video.textTracks[trackIndex];
            console.log('Enabling track:', track.label, track);

            // Set up cue change handler
            track.addEventListener('cuechange', handleCueChange);

            // Force a small delay to ensure the track is ready
            setTimeout(() => {
              track.mode = 'showing';
              console.log('Track mode set to showing, current mode:', track.mode);

              // Force a cue change to trigger the display
              if (track.cues && track.cues.length > 0) {
                const event = new Event('cuechange');
                track.dispatchEvent(event);
              }
            }, 100);

            currentSubtitleIndex = trackIndex;
            currentSubtitleTrack = track;
            console.log('Subtitle enabled:', track.label);
            showSubtitleNotification(`Subtitles: ${track.label}`);
          } catch (error) {
            console.error('Error enabling subtitle track:', error);
            showSubtitleNotification('Error enabling subtitles');
          }
        }

        // Update UI to show active state
        updateSubtitleIndicators(currentSubtitleIndex);

        // Remove the menu after selection
        const menu = document.getElementById('subtitleMenu');
        if (menu) menu.remove();
      }

      // Handle cue changes to update the custom subtitle display
      function handleCueChange() {
        console.log('handleCueChange called, currentSubtitleIndex:', currentSubtitleIndex);

        if (!subtitleContainer) {
          console.warn('Subtitle container not found, initializing...');
          initSubtitleContainer();
          if (!subtitleContainer) {
            console.error('Failed to create subtitle container');
            return;
          }
        }

        // Only show subtitles if a track is explicitly selected
        if (currentSubtitleIndex === null || !currentSubtitleTrack) {
          console.log('No subtitle track selected, hiding container');
          subtitleContainer.style.display = 'none';
          return;
        }

        const track = currentSubtitleTrack;
        const activeCues = Array.from(track.activeCues || []);

        console.log('Active cues:', activeCues.length, activeCues);

        if (activeCues.length > 0) {
          // Show active cues
          let subtitleText = '';
          for (let i = 0; i < activeCues.length; i++) {
            if (activeCues[i].text) {
              subtitleText += activeCues[i].text + '\n';
            }
          }

          console.log('Subtitle text:', subtitleText);

          if (subtitleText.trim()) {
            // Ensure the container is visible and has the correct styles
            subtitleContainer.style.display = 'block';
            subtitleContainer.style.visibility = 'visible';
            subtitleContainer.style.opacity = '1';

            // Update the text content
            subtitleContainer.innerHTML = ''; // Clear first to avoid flash of old content
            subtitleContainer.textContent = subtitleText.trim();

            // Add line breaks back in
            subtitleContainer.innerHTML = subtitleText.trim().replace(/\n/g, '<br>');

            console.log('✓ Subtitles displayed');
          } else {
            subtitleContainer.style.display = 'none';
          }
        } else {
          // Hide when no active cues
          console.log('No active cues, hiding subtitles');
          subtitleContainer.style.display = 'none';
        }
      }

      function updateSubtitleIndicators(activeIndex) {
        // Update visual indicators in the menu
        const menu = document.getElementById('subtitleMenu');
        if (menu) {
          const options = menu.querySelectorAll('.subtitle-option');
          options.forEach((option, index) => {
            // Remove existing indicators
            const existingIndicator = option.querySelector('.subtitle-indicator');
            if (existingIndicator) {
              existingIndicator.remove();
            }

            // Add red dot for active subtitle (skip "Off" option at index 0)
            if (activeIndex !== null && index === activeIndex + 1) {
              const dot = document.createElement('span');
              dot.className = 'subtitle-indicator';
              dot.style.cssText = `
                display: inline-block;
                width: 8px;
                height: 8px;
                background-color: #e50914;
                border-radius: 50%;
                margin-right: 8px;
                vertical-align: middle;
              `;
              option.insertBefore(dot, option.firstChild);
            }
          });
        }
      }

      // Initialize continue watching UI
      continueWatchingUI = new ContinueWatchingUI();
      console.log('ContinueWatchingUI initialized:', !!continueWatchingUI);

      // Set movie info from URL parameters
      document.title = `${title}`;
      movieTitle.textContent = title;
      movieYear.textContent = year;
      movieRating.textContent = rating ? `${rating}/10` : 'N/A';
      movieDescription.textContent = description;

      // Function to load video subtitles
      function loadVideoSubtitles() {
        const videoId = urlParams.get('id');
        if (videoId && videoSources[videoId] && videoSources[videoId].subtitles) {
          // Initialize subtitle container first
          initSubtitleContainer();

          // Then load the subtitles
          loadSubtitles(videoSources[videoId].subtitles);

          // Set up cue change handler for the video's text tracks
          const tracks = video.textTracks;
          for (let i = 0; i < tracks.length; i++) {
            tracks[i].addEventListener('cuechange', handleCueChange);
          }
        }
      }

      // Save progress when video is paused or closed
      function saveProgress() {
        try {
          // Ensure we have all required data
          if (!video || !continueWatchingUI || !window.currentMovie) {
            console.log('Save progress skipped - missing required data:', {
              hasVideo: !!video,
              hasContinueWatchingUI: !!continueWatchingUI,
              hasCurrentMovie: !!window.currentMovie
            });
            return;
          }

          // Ensure we have a valid movie ID
          if (!window.currentMovie.id) {
            window.currentMovie.id = `generated-${Date.now()}`;
            console.warn('Generated new movie ID for save:', window.currentMovie);
          }

          const currentTime = video.currentTime;
          const duration = video.duration;

          // Only save if we have a valid duration and position
          if (duration && currentTime > 0) {
            const progress = {
              movieId: window.currentMovie.id,
              title: window.currentMovie.title || 'Unknown Title',
              currentTime: Math.floor(currentTime), // Store as integer to avoid floating point issues
              duration: Math.floor(duration),
              timestamp: Date.now(),
              // Include additional metadata for better identification
              year: window.currentMovie.year || '',
              lastWatched: new Date().toISOString(),
              // Add a unique identifier for this session
              sessionId: window.currentMovie.sessionId || (window.currentMovie.sessionId = `sess-${Date.now()}`)
            };

            console.log('Saving progress:', {
              movieId: progress.movieId,
              title: progress.title,
              currentTime: progress.currentTime,
              duration: progress.duration,
              progressPercent: Math.round((progress.currentTime / progress.duration) * 100) || 0
            });

            // Save using the manager
            if (window.ContinueWatchingManager) {
              window.ContinueWatchingManager.saveMovieProgress(
                progress.movieId,
                {
                  ...progress,
                  // Include additional metadata for the UI
                  thumbnail: window.currentMovie.thumbnail || '',
                  poster: window.currentMovie.poster || ''
                }
              );
            } else if (continueWatchingUI && continueWatchingUI.saveProgress) {
              // Fallback to direct save if manager not available
              continueWatchingUI.saveProgress(
                progress.movieId,
                progress.currentTime,
                progress.duration,
                progress.title
              );
            } else {
              console.error('No valid method to save progress found');
            }
          }
        } catch (error) {
          console.error('Error saving progress:', error);
        }
      }


      // Save progress when video is paused
      video.addEventListener('pause', saveProgress);

      // Save progress when page is unloaded
      window.addEventListener('beforeunload', saveProgress);

      // Make sure subtitles are loaded after video metadata is loaded
      video.addEventListener('loadedmetadata', function () {
        loadVideoSubtitles();
      });

      // Back button functionality
      backButton.addEventListener('click', () => {
        window.location.href = 'index.html';
      });

      // --- Enhanced Player Features ---
      (function enhancePlayer() {
        const video = document.getElementById('video');
        const videoContainer = document.getElementById('videoContainer');
        const controlsContainer = document.getElementById('controlsContainer');
        let spinner = null;

        // 1. Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          switch (e.key.toLowerCase()) {
            case 'spacebar': {
              e.preventDefault();
              // Block play/pause toggles while resume prompt is active
              if (window.__resumePromptActive) { video.pause(); break; }
              video.paused ? video.play() : video.pause();
              break;
            }
            case 'arrowright': video.currentTime += 5; break;
            case 'arrowleft': video.currentTime -= 5; break;
            case 'm': video.muted = !video.muted; break;
            case 'arrowup': video.volume = Math.min(1, video.volume + 0.05); break;
            case 'arrowdown': video.volume = Math.max(0, video.volume - 0.05); break;
            case 'p':
              if (document.pictureInPictureElement) document.exitPictureInPicture();
              else if (video.requestPictureInPicture) video.requestPictureInPicture();
              break;
          }
        });

        // 3. Click/tap overlay to play/pause
        videoContainer.addEventListener('click', (e) => {
          if (e.target === video || e.target === videoContainer) {
            // Block play/pause toggles while resume prompt is active
            if (window.__resumePromptActive) { video.pause(); return; }
            video.paused ? video.play() : video.pause();
          }
        });

        // 4. Animated loading spinner while buffering
        function showSpinner() {
          if (!spinner) {
            spinner = document.createElement('div');
            spinner.className = 'video-loading-spinner';
            videoContainer.appendChild(spinner);
          }
        }
        function hideSpinner() {
          if (spinner) { spinner.remove(); spinner = null; }
        }
        video.addEventListener('waiting', showSpinner);
        video.addEventListener('seeking', showSpinner);
        video.addEventListener('playing', hideSpinner);
        video.addEventListener('canplay', hideSpinner);
        video.addEventListener('canplaythrough', hideSpinner);
        video.addEventListener('ended', hideSpinner);

        // 5. Volume slider with icon feedback (already present, but add feedback)
        const volumeSlider = document.getElementById('volumeSlider');
        const muteBtn = document.getElementById('muteBtn');
        if (volumeSlider && muteBtn) {
          volumeSlider.addEventListener('input', () => {
            if (video.volume === 0 || video.muted) muteBtn.classList.add('muted');
            else muteBtn.classList.remove('muted');
          });
          video.addEventListener('volumechange', () => {
            if (video.volume === 0 || video.muted) muteBtn.classList.add('muted');
            else muteBtn.classList.remove('muted');
          });
        }

        // 6. Skip intro/recap button (if timestamp provided)
        const skipIntroBtn = document.createElement('button');
        skipIntroBtn.textContent = 'Skip Intro';
        skipIntroBtn.className = 'skip-intro-btn';
        skipIntroBtn.style = 'position:absolute;top:16px;right:16px;z-index:1001;padding:0.5em 1.2em;background:#3290ff;color:#fff;border:none;border-radius:6px;font-weight:600;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,0.18);display:none;';
        videoContainer.appendChild(skipIntroBtn);
        let introTime = null;
        // Example: set introTime from URL param ?intro=85
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('intro')) {
          introTime = parseInt(urlParams.get('intro'));
          if (!isNaN(introTime) && introTime > 0) {
            skipIntroBtn.style.display = '';
            skipIntroBtn.onclick = () => { video.currentTime = introTime; skipIntroBtn.style.display = 'none'; };
            video.addEventListener('timeupdate', () => {
              if (video.currentTime > introTime) skipIntroBtn.style.display = 'none';

              // Auto-save progress every 5 seconds
              if (window.continueWatchingUI && video.currentTime % 5 < 0.1) {
                const progressData = {
                  currentTime: video.currentTime,
                  duration: video.duration,
                  title: title,
                  poster: poster,
                  lastWatched: new Date().toISOString()
                };

                if (window.ContinueWatchingManager) {
                  window.ContinueWatchingManager.saveMovieProgress(src, progressData);
                }
              }
            });
          }
        }

        // 7. Picture-in-Picture support (keyboard P)
        // Already handled in keyboard shortcuts above

        // 8. Mini progress bar preview on hover (basic time tooltip)
        if (controlsContainer) {
          const progressBar = document.getElementById('progressBar');
          const progressContainer = document.getElementById('progressContainer');
          let tooltip = document.createElement('div');
          tooltip.className = 'scrubber-time';
          tooltip.style = 'position:absolute;bottom:32px;left:0;z-index:1002;background:rgba(0,0,0,0.85);color:#fff;padding:2px 8px;border-radius:4px;font-size:0.95em;pointer-events:none;display:none;';
          progressContainer.appendChild(tooltip);
          progressContainer.addEventListener('mousemove', (e) => {
            const rect = progressContainer.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            const time = percent * video.duration;
            if (!isNaN(time)) {
              tooltip.textContent = formatTime(time);
              tooltip.style.left = `${e.clientX - rect.left - 18}px`;
              tooltip.style.display = 'block';
            }
          });
          progressContainer.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
          });
        }

        // 9. Remember last volume and playback position
        // Save on change
        video.addEventListener('volumechange', () => {
          localStorage.setItem('playerVolume', video.volume);
          localStorage.setItem('playerMuted', video.muted ? '1' : '0');
        });
        video.addEventListener('timeupdate', () => {
          if (!video.seeking && !video.paused) {
            localStorage.setItem('playerLastTime', video.currentTime);
            localStorage.setItem('playerLastSrc', video.currentSrc);
          }
        });
        // Restore on load
        window.addEventListener('DOMContentLoaded', () => {
          const lastVol = localStorage.getItem('playerVolume');
          const lastMuted = localStorage.getItem('playerMuted');
          if (lastVol !== null) video.volume = parseFloat(lastVol);
          if (lastMuted === '1') video.muted = true;
          const lastSrc = localStorage.getItem('playerLastSrc');
          const lastTime = localStorage.getItem('playerLastTime');
          if (lastSrc === video.currentSrc && lastTime) {
            video.currentTime = parseFloat(lastTime);
          }
        });

        // 10. Responsive controls for mobile/desktop (basic)
        function updateControlsForScreen() {
          if (window.innerWidth < 600) {
            controlsContainer.classList.add('mobile');
          } else {
            controlsContainer.classList.remove('mobile');
          }
        }
        window.addEventListener('resize', updateControlsForScreen);
        updateControlsForScreen();

        // Helper: format time in HH:MM:SS or MM:SS format
        function formatTime(seconds) {
          seconds = Math.floor(seconds);
          const hours = Math.floor(seconds / 3600);
          const minutes = Math.floor((seconds % 3600) / 60);
          const remainingSeconds = seconds % 60;

          const paddedMinutes = minutes.toString().padStart(2, '0');
          const paddedSeconds = remainingSeconds.toString().padStart(2, '0');

          if (hours > 0) {
            return `${hours}:${paddedMinutes}:${paddedSeconds}`;
          } else {
            return `${minutes}:${paddedSeconds}`;
          }
        }
      })();
      // State
      let hideControlsTimeout;
      let isScrubbing = false;
      let wasPlayingBeforeScrubbing = false;
      let lastTapTime = 0;
      let tapCount = 0;
      let tapTimeout;
      const HIDE_CONTROLS_DELAY = 3000;
      const DOUBLE_TAP_DELAY = 300;
      const SEEK_AMOUNT = 10; // seconds

      // Format time in seconds to HH:MM:SS or MM:SS (for durations under 1 hour)
      function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const remainingSeconds = Math.floor(seconds % 60);

        // Always show two digits for minutes and seconds
        const paddedMinutes = String(minutes).padStart(2, '0');
        const paddedSeconds = String(remainingSeconds).padStart(2, '0');

        // Only show hours if the video is 1 hour or longer
        if (hours > 0) {
          return `${hours}:${paddedMinutes}:${paddedSeconds}`;
        } else {
          return `${minutes}:${paddedSeconds}`;
        }
      }

      // Update time display
      function updateTimeDisplay() {
        if (!isNaN(video.duration)) {
          const current = formatTime(video.currentTime);
          const total = formatTime(video.duration);

          if (timeDisplay) timeDisplay.textContent = `${current} / ${total}`;
          if (scrubberTime) scrubberTime.textContent = formatTime(video.currentTime);
        }
      }

      // Update progress bar
      function updateProgress() {
        if (!isScrubbing && !isNaN(video.duration) && video.duration > 0) {
          const progress = (video.currentTime / video.duration) * 100;
          progressBar.style.width = `${progress}%`;

          // Update buffered progress
          if (video.buffered.length > 0) {
            const bufferedEnd = video.buffered.end(video.buffered.length - 1);
            const duration = video.duration;
            if (duration > 0) {
              const bufferedPercent = (bufferedEnd / duration) * 100;
              progressBuffer.style.width = `${bufferedPercent}%`;
            }
          }
        }
        updateTimeDisplay();
      }

      // Toggle play/pause
      function togglePlayPause() {
        // Suppress starting playback when resume prompt is active
        if (window.__resumePromptActive) {
          video.pause();
          playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
          return;
        }
        if (video.paused) {
          video.play();
          playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
        } else {
          video.pause();
          playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
        }
        showPlayPauseOverlay(!video.paused);
        resetHideControlsTimeout();
      }

      // Toggle mute
      function toggleMute() {
        video.muted = !video.muted;
        muteBtn.innerHTML = video.muted ?
          '<i class="fas fa-volume-mute"></i>' :
          '<i class="fas fa-volume-up"></i>';
        if (!video.muted) {
          video.volume = volumeSlider.value;
        }
        resetHideControlsTimeout();
      }

      // Update volume
      function updateVolume() {
        video.volume = volumeSlider.value;
        video.muted = false;
        muteBtn.innerHTML = video.volume > 0 ?
          '<i class="fas fa-volume-up"></i>' :
          '<i class="fas fa-volume-mute"></i>';
      }

      // Toggle fullscreen with better error handling and cross-browser support
      // Also includes CSS-only "pseudo-fullscreen" fallback for restricted contexts
      let usePseudoFullscreen = false;

      async function toggleFullscreen() {
        try {
          const videoContainer = document.getElementById('videoContainer');
          if (!videoContainer) {
            throw new Error('Video container not found');
          }

          // Check current fullscreen state (real fullscreen)
          const isRealFullscreen = document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement;

          // Check pseudo-fullscreen state
          const isPseudoFullscreen = document.body.classList.contains('pseudo-fullscreen');

          if (!isRealFullscreen && !isPseudoFullscreen) {
            // Try to enter fullscreen
            let fullscreenSuccess = false;

            try {
              // Try real fullscreen first
              if (videoContainer.requestFullscreen) {
                await videoContainer.requestFullscreen();
                fullscreenSuccess = true;
                usePseudoFullscreen = false;
              } else if (videoContainer.webkitRequestFullscreen) {
                await videoContainer.webkitRequestFullscreen();
                fullscreenSuccess = true;
                usePseudoFullscreen = false;
              } else if (videoContainer.mozRequestFullScreen) {
                await videoContainer.mozRequestFullScreen();
                fullscreenSuccess = true;
                usePseudoFullscreen = false;
              } else if (videoContainer.msRequestFullscreen) {
                await videoContainer.msRequestFullscreen();
                fullscreenSuccess = true;
                usePseudoFullscreen = false;
              } else if (video && video.webkitEnterFullscreen) {
                // iOS Safari
                await video.webkitEnterFullscreen();
                fullscreenSuccess = true;
                usePseudoFullscreen = false;
              } else {
                // No fullscreen API found, will try pseudo-fullscreen
                console.warn('Fullscreen API not available, using CSS-based pseudo-fullscreen');
              }
            } catch (fsErr) {
              console.warn('Real fullscreen failed, falling back to pseudo-fullscreen:', fsErr.message);
            }

            // If real fullscreen failed, use pseudo-fullscreen
            if (!fullscreenSuccess) {
              document.body.classList.add('pseudo-fullscreen');
              usePseudoFullscreen = true;
            }

            // Update UI after successful fullscreen (both real and pseudo)
            if (fullscreenBtn) {
              fullscreenBtn.innerHTML = '<i class="fas fa-compress"></i>';
            }

            // Move subtitle container to video container for proper positioning in fullscreen
            if (subtitleContainer && subtitleContainer.parentElement !== videoContainer) {
              videoContainer.appendChild(subtitleContainer);
              subtitleContainer.style.display = 'block';
              void subtitleContainer.offsetWidth; // Force reflow
            }

            // Add fullscreen class to body for CSS targeting (real fullscreen)
            if (isRealFullscreen) {
              document.body.classList.add('fullscreen');
            }

            // Force a re-layout
            setTimeout(() => {
              videoContainer.style.display = 'block';
              void videoContainer.offsetWidth;
            }, 0);
          } else {
            // Exit fullscreen (both real and pseudo)
            if (isRealFullscreen) {
              if (document.exitFullscreen) {
                await document.exitFullscreen();
              } else if (document.webkitExitFullscreen) {
                await document.webkitExitFullscreen();
              } else if (document.mozCancelFullScreen) {
                await document.mozCancelFullScreen();
              } else if (document.msExitFullscreen) {
                await document.msExitFullscreen();
              }
              document.body.classList.remove('fullscreen');
            }

            // Exit pseudo-fullscreen
            if (isPseudoFullscreen) {
              document.body.classList.remove('pseudo-fullscreen');
              usePseudoFullscreen = false;
            }

            // Update UI after exiting fullscreen
            if (fullscreenBtn) {
              fullscreenBtn.innerHTML = '<i class="fas fa-expand"></i>';
            }

            // Move subtitle container back to body when exiting fullscreen
            if (subtitleContainer && subtitleContainer.parentElement === videoContainer) {
              document.body.appendChild(subtitleContainer);
              void subtitleContainer.offsetWidth; // Force reflow
            }
          }

          // Force update controls and reset timeout
          resetHideControlsTimeout();

        } catch (err) {
          console.error('Fullscreen error:', err);
          console.error('Error name:', err.name);
          console.error('Error message:', err.message);

          // Provide more specific error messages
          let errorMsg = 'Fullscreen mode activated using CSS rendering. ';

          if (err.name === 'NotAllowedError' || err.message.includes('Permissions check failed')) {
            errorMsg = 'Browser blocked real fullscreen, but activated CSS-based fullscreen mode instead.';
          }

          showSystemMessage(errorMsg, 'info');
        }
      }

      // We're now using CSS for menu positioning in fullscreen mode
      // No JavaScript positioning is needed

      // Seek to specific time
      function seekToTime(e) {
        const rect = progressContainer.getBoundingClientRect();
        const pos = (e.clientX - rect.left) / rect.width;
        video.currentTime = pos * video.duration;
      }

      // Show/hide controls
      function showControls() {
        controlsContainer.classList.add('visible');
      }

      function hideControls() {
        // Don't hide controls if settings menu or submenu is open
        const settingsMenuOpen = settingsMenu && settingsMenu.style.display === 'flex';
        const submenuOpen = playbackSpeedSubmenu && playbackSpeedSubmenu.style.display === 'flex';
        const subtitleMenuOpen = document.getElementById('subtitleMenu') !== null;

        if (!video.paused && !settingsMenuOpen && !submenuOpen && !subtitleMenuOpen) {
          controlsContainer.classList.remove('visible');
        }
      }

      function resetHideControlsTimeout() {
        clearTimeout(hideControlsTimeout);
        controlsContainer.classList.add('visible');
        hideControlsTimeout = setTimeout(hideControls, HIDE_CONTROLS_DELAY);
      }

      // Show play/pause overlay
      function showPlayPauseOverlay(isPlaying) {
        const icon = playPauseOverlay.querySelector('i');
        icon.className = isPlaying ? 'fas fa-pause' : 'fas fa-play';
        playPauseOverlay.classList.add('visible');

        clearTimeout(playPauseOverlay.timeout);
        playPauseOverlay.timeout = setTimeout(() => {
          playPauseOverlay.classList.remove('visible');
        }, 500);
      }

      // Handle mouse double click for seeking (desktop)
      function handleMouseDoubleClick(e) {
        e.preventDefault();
        const rect = video.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const videoWidth = rect.width;

        // If click is on the left side, rewind 10 seconds
        if (clickX < videoWidth / 2) {
          video.currentTime = Math.max(0, video.currentTime - SEEK_AMOUNT);
          showSeekIndicator(rewindIndicator);
          console.log('Mouse: Rewind 10 seconds');
        }
        // If click is on the right side, forward 10 seconds
        else {
          video.currentTime = Math.min(video.duration, video.currentTime + SEEK_AMOUNT);
          showSeekIndicator(forwardIndicator);
          console.log('Mouse: Forward 10 seconds');
        }

        updateProgress();
        resetHideControlsTimeout();
      }

      // Handle single click for play/pause (desktop)
      function handleSingleClick(e) {
        e.preventDefault();
        clearTimeout(tapTimeout);
        tapTimeout = setTimeout(() => {
          togglePlayPause();
        }, 200);
      }

      // Handle touch events for seeking (mobile)
      function handleDoubleTap(e) {
        e.preventDefault();
        const currentTime = Date.now();
        const tapLength = currentTime - lastTapTime;

        if (tapLength < DOUBLE_TAP_DELAY && tapLength > 0) {
          // Double tap detected
          clearTimeout(tapTimeout);
          tapCount = 0;

          const touch = e.changedTouches[0];
          const rect = video.getBoundingClientRect();
          const tapX = touch.clientX - rect.left;
          const videoWidth = rect.width;

          // If tap is on the left side, rewind 10 seconds
          if (tapX < videoWidth / 2) {
            video.currentTime = Math.max(0, video.currentTime - SEEK_AMOUNT);
            showSeekIndicator(rewindIndicator);
            console.log('Touch: Rewind 10 seconds');
          }
          // If tap is on the right side, forward 10 seconds
          else {
            video.currentTime = Math.min(video.duration, video.currentTime + SEEK_AMOUNT);
            showSeekIndicator(forwardIndicator);
            console.log('Touch: Forward 10 seconds');
          }

          updateProgress();
          resetHideControlsTimeout();
          return;
        }

        // Single tap - prepare for potential double tap
        tapCount++;
        if (tapCount === 1) {
          tapTimeout = setTimeout(() => {
            if (tapCount === 1) {
              // Single tap - toggle play/pause
              togglePlayPause();
            }
            tapCount = 0;
          }, DOUBLE_TAP_DELAY);
        }

        lastTapTime = currentTime;
      }

      // Show seek indicator
      function showSeekIndicator(indicator) {
        if (!indicator) return;

        // Remove any existing visible indicators first
        document.querySelectorAll('.seek-indicator.visible').forEach(el => {
          el.classList.remove('visible');
        });

        indicator.classList.add('visible');
        clearTimeout(indicator.timeout);
        indicator.timeout = setTimeout(() => {
          indicator.classList.remove('visible');
        }, 1000);
      }

      // Handle scrubbing
      function startScrubbing(e) {
        if (e.type === 'mousedown' && e.button !== 0) return; // Only left mouse button

        isScrubbing = true;
        wasPlayingBeforeScrubbing = !video.paused;
        if (wasPlayingBeforeScrubbing) {
          video.pause();
        }

        // Show scrubber
        scrubber.classList.add('active');
        updateScrubberPosition(e);

        // Prevent default for touch events
        e.preventDefault();
      }

      function updateScrubberPosition(e) {
        if (!isScrubbing) return;

        const rect = video.getBoundingClientRect();
        let pos = 0;

        if (e.type.includes('touch')) {
          const touch = e.touches[0] || e.changedTouches[0];
          pos = (touch.clientX - rect.left) / rect.width;
        } else {
          pos = (e.clientX - rect.left) / rect.width;
        }

        pos = Math.max(0, Math.min(1, pos));

        // Update scrubber position
        const scrubberLine = document.querySelector('.scrubber-line');
        scrubberLine.style.left = `${pos * 100}%`;

        // Update scrubber time
        const time = pos * video.duration;
        scrubberTime.textContent = formatTime(time);

        // Update progress bar during scrubbing
        progressBar.style.width = `${pos * 100}%`;

        // Update current time display
        currentTimeDisplay.textContent = formatTime(time);
      }

      function endScrubbing(e) {
        if (!isScrubbing) return;

        const rect = video.getBoundingClientRect();
        let pos = 0;

        if (e.type.includes('touch')) {
          const touch = e.changedTouches[0];
          pos = (touch.clientX - rect.left) / rect.width;
        } else {
          pos = (e.clientX - rect.left) / rect.width;
        }

        pos = Math.max(0, Math.min(1, pos));
        video.currentTime = pos * video.duration;

        if (wasPlayingBeforeScrubbing && !window.__resumePromptActive) {
          video.play();
        } else {
          video.pause();
        }

        isScrubbing = false;
        scrubber.classList.remove('active');
        resetHideControlsTimeout();
      }

      // Skip notification state
      let skipAccumulator = 0;
      let skipDirection = null; // 'forward' or 'backward'
      let skipTimeout = null;

      // Skip forward/backward functions
      function skipBackward() {
        video.currentTime = Math.max(0, video.currentTime - SEEK_AMOUNT);
        showSeekIndicator(rewindIndicator);
        showSkipNotification(-SEEK_AMOUNT);
        resetHideControlsTimeout();
      }

      function skipForward() {
        video.currentTime = Math.min(video.duration, video.currentTime + SEEK_AMOUNT);
        showSeekIndicator(forwardIndicator);
        showSkipNotification(SEEK_AMOUNT);
        resetHideControlsTimeout();
      }

      // Show skip notification with accumulation
      function showSkipNotification(seconds) {
        const notification = document.getElementById('skipNotification');
        const skipText = document.getElementById('skipText');
        const icon = notification.querySelector('i');

        const currentDirection = seconds > 0 ? 'forward' : 'backward';

        // If direction changed, reset accumulator
        if (skipDirection !== null && skipDirection !== currentDirection) {
          skipAccumulator = 0;
        }

        // Update direction and accumulate
        skipDirection = currentDirection;
        skipAccumulator += Math.abs(seconds);

        // Update text and icon based on direction
        if (currentDirection === 'forward') {
          skipText.textContent = `+${skipAccumulator}s`;
          icon.className = 'fas fa-forward';
          notification.classList.remove('backward');
          notification.classList.add('forward');
        } else {
          skipText.textContent = `-${skipAccumulator}s`;
          icon.className = 'fas fa-backward';
          notification.classList.remove('forward');
          notification.classList.add('backward');
        }

        // Show notification
        notification.classList.add('visible');

        // Clear existing timeout
        if (skipTimeout) {
          clearTimeout(skipTimeout);
        }

        // Hide after 3 seconds of no activity
        skipTimeout = setTimeout(() => {
          notification.classList.remove('visible');
          // Reset accumulator after hiding
          setTimeout(() => {
            skipAccumulator = 0;
            skipDirection = null;
          }, 300); // Wait for fade out animation
        }, 3000);
      }

      // Event Listeners
      skipBackwardBtn.addEventListener('click', skipBackward);
      skipForwardBtn.addEventListener('click', skipForward);

      // Handle touch events for mobile
      video.addEventListener('touchend', handleDoubleTap);
      // Handle mouse events for desktop
      video.addEventListener('dblclick', handleMouseDoubleClick);
      video.addEventListener('click', handleSingleClick);
      video.addEventListener('play', () => {
        playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
        resetHideControlsTimeout();
      });
      video.addEventListener('pause', () => {
        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
      });
      video.addEventListener('timeupdate', updateProgress);
      video.addEventListener('loadedmetadata', updateProgress);
      video.addEventListener('ended', () => {
        playPauseBtn.innerHTML = '<i class="fas fa-redo"></i>';
      });

      // Touch events for mobile

      // Mouse events for desktop
      video.addEventListener('mousedown', startScrubbing);
      video.addEventListener('mousemove', updateScrubberPosition);
      video.addEventListener('mouseup', endScrubbing);
      video.addEventListener('mouseleave', () => {
        if (isScrubbing) {
          endScrubbing({ type: 'mouseup', clientX: 0 });
        }
      });

      // Controls events
      playPauseBtn.addEventListener('click', togglePlayPause);
      muteBtn.addEventListener('click', toggleMute);
      volumeSlider.addEventListener('input', updateVolume);
      fullscreenBtn.addEventListener('click', toggleFullscreen);
      if (subtitleBtn) {
        subtitleBtn.addEventListener('click', toggleSubtitleMenu);
      }

      // Global fullscreen change handler for subtitles
      const handleGlobalFullscreenChange = () => {
        const isFullscreen = document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement;

        const container = document.querySelector('.video-container');
        const subtitleElement = document.querySelector('.video-subtitles');

        if (!subtitleElement || currentSubtitleIndex === null) return;

        if (isFullscreen) {
          // Moving to fullscreen
          if (!container.contains(subtitleElement)) {
            container.appendChild(subtitleElement);
          }
          subtitleElement.classList.add('fullscreen-subtitles');
        } else {
          // Exiting fullscreen
          if (!document.body.contains(subtitleElement)) {
            document.body.appendChild(subtitleElement);
          }
          subtitleElement.classList.remove('fullscreen-subtitles');
        }
      };

      // Register global fullscreen change listeners
      document.addEventListener('fullscreenchange', handleGlobalFullscreenChange);
      document.addEventListener('webkitfullscreenchange', handleGlobalFullscreenChange);
      document.addEventListener('mozfullscreenchange', handleGlobalFullscreenChange);
      document.addEventListener('MSFullscreenChange', handleGlobalFullscreenChange);

      // Force landscape orientation on fullscreen in portrait mode (mobile)
      function forceLandscapeOnFullscreen() {
        const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        if (isFullscreen && window.screen.orientation) {
          // Only force if currently portrait
          if (window.matchMedia('(orientation: portrait)').matches) {
            window.screen.orientation.lock('landscape').catch(() => { });
          }
        } else if (window.screen.orientation) {
          // Unlock when exiting fullscreen
          window.screen.orientation.unlock && window.screen.orientation.unlock();
        }
      }

      document.addEventListener('fullscreenchange', forceLandscapeOnFullscreen);
      document.addEventListener('webkitfullscreenchange', forceLandscapeOnFullscreen);
      document.addEventListener('mozfullscreenchange', forceLandscapeOnFullscreen);
      document.addEventListener('MSFullscreenChange', forceLandscapeOnFullscreen);

      // Progress bar click to seek
      progressContainer.addEventListener('click', (e) => {
        seekToTime(e);
        resetHideControlsTimeout();
      });

      // Show controls on mouse move or touch
      videoContainer.addEventListener('mousemove', resetHideControlsTimeout);
      videoContainer.addEventListener('touchstart', resetHideControlsTimeout);

      // Hide controls when mouse leaves the video container (desktop only)
      videoContainer.addEventListener('mouseleave', () => {
        if (!video.paused) {
          hideControls();
        }
      });

      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        // Space or K key to play/pause
        if (e.code === 'Space' || e.code === 'KeyK') {
          e.preventDefault();
          togglePlayPause();
        }
        // M key to mute/unmute
        else if (e.code === 'KeyM') {
          e.preventDefault();
          toggleMute();
        }
        // F key to toggle fullscreen
        else if (e.code === 'KeyF') {
          e.preventDefault();
          toggleFullscreen();
        }
        // Left/Right arrow keys to seek
        else if (e.code === 'ArrowLeft') {
          e.preventDefault();
          skipBackward();
        }
        else if (e.code === 'ArrowRight') {
          e.preventDefault();
          skipForward();
        }
      });

      // Initialize controls
      resetHideControlsTimeout();
      // Screen mode controls
      var screenModeBtn = document.getElementById('screenModeToggle');
      var screenModeIcon = document.getElementById('screenModeIcon');
      var modes = [
        { fit: 'fill', icon: 'fa-expand-arrows-alt', label: 'Stretch' },
        { fit: 'cover', icon: 'fa-arrows-alt-h', label: 'Wide' },
        { fit: 'contain', icon: 'fa-compress', label: 'Contain' }
      ];
      var currentMode = 0;
      function updateScreenMode() {
        video.style.objectFit = modes[currentMode].fit;
        screenModeIcon.className = 'fas ' + modes[currentMode].icon;
        screenModeBtn.setAttribute('data-tooltip', modes[currentMode].label);
        screenModeBtn.setAttribute('title', modes[currentMode].label);
      }
      if (video && screenModeBtn && screenModeIcon) {
        screenModeBtn.addEventListener('click', function () {
          currentMode = (currentMode + 1) % modes.length;
          updateScreenMode();
        });
        updateScreenMode();
      }
    });
  </script>
  <!-- Add the subtitles CSS -->
  <link rel="stylesheet" href="css/subtitles.css">
</body>

</html>